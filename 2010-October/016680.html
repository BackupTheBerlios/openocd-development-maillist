<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-development] BSDL target, how to use JTAG?
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-development/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20BSDL%20target%2C%20how%20to%20use%20JTAG%3F&In-Reply-To=%3C4CADBFE1.3030305%40amontec.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016678.html">
   <LINK REL="Next"  HREF="016688.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-development] BSDL target, how to use JTAG?</H1>
    <B>Laurent Gauch</B> 
    <A HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20BSDL%20target%2C%20how%20to%20use%20JTAG%3F&In-Reply-To=%3C4CADBFE1.3030305%40amontec.com%3E"
       TITLE="[Openocd-development] BSDL target, how to use JTAG?">laurent.gauch at amontec.com
       </A><BR>
    <I>Thu Oct  7 14:41:05 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="016678.html">[Openocd-development] BSDL target, how to use JTAG?
</A></li>
        <LI>Next message: <A HREF="016688.html">[Openocd-development] BSDL target, how to use JTAG?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16680">[ date ]</a>
              <a href="thread.html#16680">[ thread ]</a>
              <a href="subject.html#16680">[ subject ]</a>
              <a href="author.html#16680">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Rick,

Great job.

One comment concerning your note :

&gt;<i> +Note that the logic of this procedure will only work if the chip that is being boarded is
</I>&gt;<i> +at rest.  The PCB probably provides ways of doing that, not in the last place by holding
</I>&gt;<i> +the system reset signal active by pressing a reset button.  Where supported, the JTAG
</I>&gt;<i> +cable or the boundary scan logiccould be used to achieve a halted system.
</I>&gt;<i>   
</I>
This is true for some specific processors. But wrong for CPLD , FPGA, 
...., and some ARM having methods to select Boundary Scan or internal 
Debug via external pin setup ...

If you want to indirect Flash a memory over JTAG Boundary Scan from a 
FPGA, you only need TCK TMS TDI TDO  JTAG Signals:-) !

Please remove this comment, or replace &quot;chip&quot; by &quot;some processors&quot;

Regards,
Laurent
 <A HREF="http://www.amontec.com">http://www.amontec.com</A>

Amontec JTAGkey-2  : USB JTAG Debugger with up to 30Mhz JTAG frequency 
over High-Speed USB 2.0


&gt;<i> Hello Oyvind,
</I>&gt;<i>
</I>&gt;<i> &gt;/ OpenOCD 0.4.0 is getting a bit long in the tooth for getting help on this
</I>&gt;<i> /&gt;/ list. You'll want to move to the master branch.
</I>&gt;<i> /
</I>&gt;<i> OK, I'll setup git.  I wanted to get started on stable code, but if things
</I>&gt;<i> I'm running into were already resolved in git that's not worth it.
</I>&gt;<i>
</I>&gt;<i> &gt;/ Also, it could help if you posted a patch of the code you're trying to
</I>&gt;<i> /&gt;/ implement.
</I>&gt;<i> /
</I>&gt;<i> The patch is attached.  Thanks for anything you can teach me.  The big
</I>&gt;<i> problem appears to be lack of documentation, not bugs, which is why
</I>&gt;<i> I wrote to this list.  The patch is incomplete but it has a docfile.
</I>&gt;<i>
</I>&gt;<i> Thanks,
</I>&gt;<i>  -Rick
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> diff -Nur openocd-0.4.0-orig/doc/bsdl.txt openocd-0.4.0-plus_bsdl/doc/bsdl.txt
</I>&gt;<i> --- openocd-0.4.0-orig/doc/bsdl.txt	1970-01-01 00:00:00.000000000 +0000
</I>&gt;<i> +++ openocd-0.4.0-plus_bsdl/doc/bsdl.txt	2010-09-27 21:50:29.000000000 +0000
</I>&gt;<i> @@ -0,0 +1,134 @@
</I>&gt;<i> +Generic support for Boundary Scan Definitions
</I>&gt;<i> +=============================================
</I>&gt;<i> +
</I>&gt;<i> +This style of bus access can often be used to control a PCB without knowing
</I>&gt;<i> +very much about the main chips on it.  Using the general technique of
</I>&gt;<i> +boundary scans, the pins on the device can be controlled from software, thus
</I>&gt;<i> +enabling access to most of the logic components on the PCB.
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +Working principle
</I>&gt;<i> +-----------------
</I>&gt;<i> +
</I>&gt;<i> +OpenOCD supports generic access to the boundary scan facilities that are defined and
</I>&gt;<i> +published for many chips.  Even if the detailed test/debug specifications are hidden,
</I>&gt;<i> +there usually is a boundary scan definition to aid in PCB debugging.  This is why it
</I>&gt;<i> +is fruitful to have a generic module to use such definitions.
</I>&gt;<i> +
</I>&gt;<i> +The so-called Boundary Scan Definition Language, or BSDL for short, specifies which
</I>&gt;<i> +registers are accessible over JTAG, and how they are related to pins that are usually
</I>&gt;<i> +made available externally.  It specifies scan bits to be inputs, outputs or bidirectional
</I>&gt;<i> +or, very interesting, which internal scan bits are used to control others; this is
</I>&gt;<i> +often used to set output lines into high-impedance mode where external signals win over
</I>&gt;<i> +the internally generated ones.  In other words, it makes pins behave like inputs.
</I>&gt;<i> +
</I>&gt;<i> +When doing a boundary scan, pin values are clocked into the chip while the older pin
</I>&gt;<i> +values are clocked out.  While this serial shift process is taking place, the pins
</I>&gt;<i> +will be held to their old values.  So by sending proper values to a chip, it is
</I>&gt;<i> +possible to set its external pins to desired values, and when making another round
</I>&gt;<i> +it is possible to read in the values on input and high-impedance pins.  All in all,
</I>&gt;<i> +the JTAG interface enables us to control chips on the PCB which can handle elongated
</I>&gt;<i> +signaling from the processor chip.
</I>&gt;<i> +
</I>&gt;<i> +In all this, the internal structure of the processor is no required knowledge; only
</I>&gt;<i> +its boundary scan definition is, and that is usually public.  There are quicker ways
</I>&gt;<i> +of accessing (say) a flash chip on a bus if the processor co-operates, but when faced
</I>&gt;<i> +with nothing but the BSDL definition, this generic approach may be the only chance
</I>&gt;<i> +we have of accessing chips on the PCB under program control.
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +Reading flash
</I>&gt;<i> +-------------
</I>&gt;<i> +
</I>&gt;<i> +To read the contents of a flash memory, the pins of a processor are set and reset as
</I>&gt;<i> +decreed by the datasheet of the chip (or our intuition, our measurements, ...) and
</I>&gt;<i> +specifically we set an address to be read on the chip's address lines.  We clock
</I>&gt;<i> +it into the chip and apply it to the pins.  The second run of the same process will
</I>&gt;<i> +clock out the value read on the data pins.
</I>&gt;<i> +
</I>&gt;<i> +Mostly, a bus uses strobe signals, such as a MEMREAD pulse that temporary changes
</I>&gt;<i> +from its default setting.  If this is the case, clocking in the values to the chip
</I>&gt;<i> +happens in a few more stages: first all data, then the same data with read strobe
</I>&gt;<i> +signals inverted, then the same data with the strobe back to normal while the data
</I>&gt;<i> +is being clocked out.
</I>&gt;<i> +
</I>&gt;<i> +The cycle for a read therefore comprises of:
</I>&gt;<i> +
</I>&gt;<i> +1. Clock all signals to the chip, including address lines but with inactive strobe signals;
</I>&gt;<i> +
</I>&gt;<i> +2. Clock the same to the chip, but now with activated read strobe signals;
</I>&gt;<i> +
</I>&gt;<i> +3. Clock the same to the chip, with read strobe made inactive again; at the same time,
</I>&gt;<i> +   clock the read values out of the chip by reading the data bits.
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +Writing flash
</I>&gt;<i> +-------------
</I>&gt;<i> +
</I>&gt;<i> +TODO
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +Specification commands
</I>&gt;<i> +----------------------
</I>&gt;<i> +
</I>&gt;<i> +The following command creates a target xyz for TAP xy.z::
</I>&gt;<i> +
</I>&gt;<i> +	target create xyz generic_bsdl -chain-position xy.z
</I>&gt;<i> +
</I>&gt;<i> +A target continues to read in a BSDL file holding the chip's boundary scan
</I>&gt;<i> +definition:
</I>&gt;<i> +
</I>&gt;<i> +	xy.z bsdlfile /path/to/somechip.bsdl
</I>&gt;<i> +
</I>&gt;<i> +Output and bidirectional bits can be set to their resting state which may be
</I>&gt;<i> +set, reset or float::
</I>&gt;<i> +
</I>&gt;<i> +	xy.z force float K L M
</I>&gt;<i> +	xy.z force set   N O P
</I>&gt;<i> +	xy.z force reset Q R S(*)
</I>&gt;<i> +
</I>&gt;<i> +Note the form S(*) which covers all elements of an array, so S(0), S(1), and so on.
</I>&gt;<i> +If it is needed to revert these forced settings of pins at some later stage, then
</I>&gt;<i> +a statement can be issued for that:
</I>&gt;<i> +
</I>&gt;<i> +	xy.z force none
</I>&gt;<i> +
</I>&gt;<i> +A few signals must be specified explicitly, to allow control over them by programs
</I>&gt;<i> +such as memory dumpers; these are the address and data lines::
</I>&gt;<i> +
</I>&gt;<i> +	xy.z define address A(*)
</I>&gt;<i> +	xy.z define data D(*)
</I>&gt;<i> +
</I>&gt;<i> +Strobe signals can be setup for reading and writing operations separately.
</I>&gt;<i> +The duration of all these strobe signals will last considerably longer than
</I>&gt;<i> +under live control by the chip.  Strobes are defined as follows::
</I>&gt;<i> +
</I>&gt;<i> +	xy.z define readstrobe  MEMSEL
</I>&gt;<i> +	xy.z define writestrobe MEMSEL RD_NOTWR
</I>&gt;<i> +
</I>&gt;<i> +It is good practice to have read_not_write signals set to a resting state that represents
</I>&gt;<i> +reading, and only pulse them to writing mode with a strobe.  The same is also true for
</I>&gt;<i> +chip-select or bus-select kind of signals signals.
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +Performance
</I>&gt;<i> +-----------
</I>&gt;<i> +
</I>&gt;<i> +The overall performance of flash chip access through this method depends on the speeds
</I>&gt;<i> +that can be achieved over thus JTAG interface.  Generally, the number of bits that
</I>&gt;<i> +constitute a boundary scan must be clocked in several times for a single operation,
</I>&gt;<i> +so there is quite a bit of overhead.
</I>&gt;<i> +
</I>&gt;<i> +For example, consider using a 6 MHz interface to access a 1 MB flash at 16 bits, if the
</I>&gt;<i> +total boundary scan contains 114 bits.  Let's assume about 125 bits of data are actually
</I>&gt;<i> +passed around per boundary scan.  Reading takes 3 boundary scans (375 bits) and since the
</I>&gt;<i> +1 MB flash can be loaded in 16 bit words, 512*1024 of those boundary scan series must be
</I>&gt;<i> +made (196608000 bits).  At 6 MHz, that would take up 33 seconds.
</I>&gt;<i> +
</I>&gt;<i> +Note that the logic of this procedure will only work if the chip that is being boarded is
</I>&gt;<i> +at rest.  The PCB probably provides ways of doing that, not in the last place by holding
</I>&gt;<i> +the system reset signal active by pressing a reset button.  Where supported, the JTAG
</I>&gt;<i> +cable or the boundary scan logiccould be used to achieve a halted system.
</I>&gt;<i> +
</I>&gt;<i> diff -Nur openocd-0.4.0-orig/src/jtag/core.c openocd-0.4.0-plus_bsdl/src/jtag/core.c
</I>&gt;<i> --- openocd-0.4.0-orig/src/jtag/core.c	2010-02-21 20:17:07.000000000 +0000
</I>&gt;<i> +++ openocd-0.4.0-plus_bsdl/src/jtag/core.c	2010-10-06 21:55:40.000000000 +0000
</I>&gt;<i> @@ -335,6 +335,7 @@
</I>&gt;<i>  
</I>&gt;<i>  static void jtag_checks(void)
</I>&gt;<i>  {
</I>&gt;<i> +printf (&quot;jtag_trst=%d\n&quot;, jtag_trst);
</I>&gt;<i>  	assert(jtag_trst == 0);
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i> diff -Nur openocd-0.4.0-orig/src/target/Makefile.am openocd-0.4.0-plus_bsdl/src/target/Makefile.am
</I>&gt;<i> --- openocd-0.4.0-orig/src/target/Makefile.am	2010-02-21 20:17:07.000000000 +0000
</I>&gt;<i> +++ openocd-0.4.0-plus_bsdl/src/target/Makefile.am	2010-09-22 14:40:37.000000000 +0000
</I>&gt;<i> @@ -35,7 +35,8 @@
</I>&gt;<i>  	$(MIPS32_SRC) \
</I>&gt;<i>  	avrt.c \
</I>&gt;<i>  	dsp563xx.c \
</I>&gt;<i> -	dsp563xx_once.c
</I>&gt;<i> +	dsp563xx_once.c \
</I>&gt;<i> +	generic_bsdl.c
</I>&gt;<i>  
</I>&gt;<i>  TARGET_CORE_SRC = \
</I>&gt;<i>  	algorithm.c \
</I>&gt;<i> @@ -44,7 +45,8 @@
</I>&gt;<i>  	breakpoints.c \
</I>&gt;<i>  	target.c \
</I>&gt;<i>  	target_request.c \
</I>&gt;<i> -	testee.c
</I>&gt;<i> +	testee.c \
</I>&gt;<i> +	generic_bsdl.c
</I>&gt;<i>  
</I>&gt;<i>  ARMV4_5_SRC = \
</I>&gt;<i>  	armv4_5.c \
</I>&gt;<i> diff -Nur openocd-0.4.0-orig/src/target/Makefile.in openocd-0.4.0-plus_bsdl/src/target/Makefile.in
</I>&gt;<i> --- openocd-0.4.0-orig/src/target/Makefile.in	2010-02-21 20:39:55.000000000 +0000
</I>&gt;<i> +++ openocd-0.4.0-plus_bsdl/src/target/Makefile.in	2010-09-22 14:41:01.000000000 +0000
</I>&gt;<i> @@ -75,7 +75,7 @@
</I>&gt;<i>  am_libtarget_la_OBJECTS = $(am__objects_1) $(am__objects_3) \
</I>&gt;<i>  	$(am__objects_5) $(am__objects_6) $(am__objects_7) \
</I>&gt;<i>  	$(am__objects_8) $(am__objects_9) avrt.lo dsp563xx.lo \
</I>&gt;<i> -	dsp563xx_once.lo
</I>&gt;<i> +	dsp563xx_once.lo generic_bsdl.lo
</I>&gt;<i>  libtarget_la_OBJECTS = $(am_libtarget_la_OBJECTS)
</I>&gt;<i>  DEFAULT_INCLUDES = -I. at am__isrc &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">https://lists.berlios.de/mailman/listinfo/openocd-development</A>&gt;@ -I$(top_builddir)
</I>&gt;<i>  depcomp = $(SHELL) $(top_srcdir)/depcomp
</I>&gt;<i> diff -Nur openocd-0.4.0-orig/src/target/generic_bsdl.c openocd-0.4.0-plus_bsdl/src/target/generic_bsdl.c
</I>&gt;<i> --- openocd-0.4.0-orig/src/target/generic_bsdl.c	1970-01-01 00:00:00.000000000 +0000
</I>&gt;<i> +++ openocd-0.4.0-plus_bsdl/src/target/generic_bsdl.c	2010-10-06 21:59:04.000000000 +0000
</I>&gt;<i> @@ -0,0 +1,873 @@
</I>&gt;<i> +/*
</I>&gt;<i> + * GENERIC BSDL flash and command handling.
</I>&gt;<i> + *
</I>&gt;<i> + * This BSDL interface forms a generic target template that can be applied to any TAP that
</I>&gt;<i> + * hosts a BSDL-compliant chip.  Any chip, really.
</I>&gt;<i> + *
</I>&gt;<i> + * The use of this interface is twofold:
</I>&gt;<i> + *  (1) set pins and see how other react (possibly interactive with poking at the hardware)
</I>&gt;<i> + *  (2) generic access to external flash chips by only altering a chip's pins
</I>&gt;<i> + *
</I>&gt;<i> + * This code is shared by OpenFortress Digital signatures, under the same licensing rules
</I>&gt;<i> + * as the rest of OpenOCD.  <A HREF="http://openfortress.nl/">http://openfortress.nl/</A>
</I>&gt;<i> + *
</I>&gt;<i> + * From: Rick van Rein &lt;rick at openfortress.nl &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">https://lists.berlios.de/mailman/listinfo/openocd-development</A>&gt;&gt;
</I>&gt;<i> + */
</I>&gt;<i> + 
</I>&gt;<i> +
</I>&gt;<i> +#ifdef HAVE_CONFIG_H
</I>&gt;<i> +#include &quot;config.h&quot;
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;helper/types.h&gt;
</I>&gt;<i> +#include &lt;helper/jim.h&gt;
</I>&gt;<i> +#include &lt;helper/time_support.h&gt;
</I>&gt;<i> +#include &lt;helper/log.h&gt;
</I>&gt;<i> +#include &lt;helper/command.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;jtag/jtag.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;target/register.h&gt;
</I>&gt;<i> +#include &lt;target/target.h&gt;
</I>&gt;<i> +#include &lt;target/target_type.h&gt;
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *	DATA STRUCTURES
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/* Normal scanbits are not very exciting.  It gets interesting when their
</I>&gt;<i> + * values are controlled by another scanbit.  A controlled scanbit refers
</I>&gt;<i> + * to its controlling bit, and indicates whether it is controlled when
</I>&gt;<i> + * that bit is ZERO, or ONE.  Also, it indicates if control causes the
</I>&gt;<i> + * scanbit to be SET, RESET or FLOATed.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +enum scanbittype {
</I>&gt;<i> +	SBT_IN,
</I>&gt;<i> +	SBT_OUT,
</I>&gt;<i> +	SBT_BIDIR,
</I>&gt;<i> +	SBT_CONTROL,
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +#define SBF_CONTROL_BY_ONE	0x00000001
</I>&gt;<i> +#define SBF_CONTROL_BY_ZERO	0x00000002
</I>&gt;<i> +
</I>&gt;<i> +#define SBF_DEFAULT_SET		0x00000010
</I>&gt;<i> +#define SBF_DEFAULT_RESET	0x00000020
</I>&gt;<i> +
</I>&gt;<i> +#define SBF_CONTROLLED_SET	0x00000100
</I>&gt;<i> +#define SBF_CONTROLLED_RESET	0x00000200
</I>&gt;<i> +#define SBF_CONTROLLED_FLOAT	0x00000400
</I>&gt;<i> +
</I>&gt;<i> +#define SBF_FORCE_SET		0x00001000
</I>&gt;<i> +#define SBF_FORCE_RESET		0x00002000
</I>&gt;<i> +#define SBF_FORCE_FLOAT		0x00004000
</I>&gt;<i> +
</I>&gt;<i> +#define SBF_DEFINE_READSTROBE	0x00000001
</I>&gt;<i> +#define SBF_DEFINE_WRITESTROBE	0x00000002
</I>&gt;<i> +#define SBF_DEFINE_ADDRESSLINE	0x00000004
</I>&gt;<i> +#define SBF_DEFINE_DATALINE	0x00000008
</I>&gt;<i> +
</I>&gt;<i> +#define SBF_CURRENTLY_SET	0x00000008
</I>&gt;<i> +
</I>&gt;<i> +struct scanbit {
</I>&gt;<i> +	char *sb_name;
</I>&gt;<i> +	enum scanbittype sb_type;
</I>&gt;<i> +	struct scanbit *sb_controller;
</I>&gt;<i> +	uint32_t sb_flags;
</I>&gt;<i> +	uint16_t sb_linebit;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct businfo {
</I>&gt;<i> +	uint16_t bus_first;
</I>&gt;<i> +	uint16_t bus_size;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +struct bsdl_info {
</I>&gt;<i> +	unsigned int num_scanbits;
</I>&gt;<i> +	struct scanbit *all_scanbits;
</I>&gt;<i> +	uint32_t instr_sample;
</I>&gt;<i> +	struct businfo bus_address, bus_data;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +//TODO:ONEDAY// #define target_bsdl_info(tgt) ((struct bsdl_info *) (tgt)-&gt;arch_info)
</I>&gt;<i> +#define target_bsdl_info(tgt) (&amp;bsdl_info_tms320vc5401pge)
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *	TODO -- TODO	TODO -- TODO	TODO -- TODO	TODO -- TODO	TODO -- TODO
</I>&gt;<i> + *
</I>&gt;<i> + *	STATIC DEFINITIONS FOR ONE PARTICULAR CHIP TYPE -- IN LIEU OF A BSDL PARSER
</I>&gt;<i> + *
</I>&gt;<i> + *	TODO -- TODO	TODO -- TODO	TODO -- TODO	TODO -- TODO	TODO -- TODO
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +static struct scanbit sb_tms320vc5401pge [] = {
</I>&gt;<i> +	{ &quot;HCS_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;HPIENA&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;HBIL&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;HRW_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;HAS_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;HCNTL(0)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;HCNTL(1)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;HDS1_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;HDS2_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ &quot;HD(0)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [9], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HD(1)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [10], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HD(2)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [11], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HD(3)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [12], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HD(4)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [13], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HD(5)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [14], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HD(6)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [15], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HD(7)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [16], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HINT&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HRDY&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ &quot;BFSX(1)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [29], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;BDX(1)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [28], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;BFSR(1)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [31], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;BDR(1)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;BCLKR(1)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [27], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;BCLKX(1)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [30], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ &quot;BFSX(0)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [40], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;BDX(0)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [39], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;BFSR(0)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [42], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;BDR(0)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;BCLKR(0)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [38], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;BCLKX(0)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [41], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;CLKMD(3)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;CLKMD(2)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;CLKMD(1)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;NMI_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;INT_NEG(3)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;INT_NEG(2)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;INT_NEG(1)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;INT_NEG(0)&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;READY&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;RS_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;MP_MC_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ &quot;BIO_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ &quot;HOLD_NEG&quot;, SBT_IN, NULL, 0, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ NULL, SBT_CONTROL, NULL, SBF_DEFAULT_SET, 0 },
</I>&gt;<i> +	{ &quot;A(16)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;A(17)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;A(18)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;A(19)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;D(0)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;D(1)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 1 },
</I>&gt;<i> +	{ &quot;D(2)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 2 },
</I>&gt;<i> +	{ &quot;D(3)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 3 },
</I>&gt;<i> +	{ &quot;D(4)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 4 },
</I>&gt;<i> +	{ &quot;D(5)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 5 },
</I>&gt;<i> +	{ &quot;D(6)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 6 },
</I>&gt;<i> +	{ &quot;D(7)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 7 },
</I>&gt;<i> +	{ &quot;D(8)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 8 },
</I>&gt;<i> +	{ &quot;D(9)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 9 },
</I>&gt;<i> +	{ &quot;D(10)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 10 },
</I>&gt;<i> +	{ &quot;D(11)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 11 },
</I>&gt;<i> +	{ &quot;D(12)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 12 },
</I>&gt;<i> +	{ &quot;D(13)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 13 },
</I>&gt;<i> +	{ &quot;D(14)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 14 },
</I>&gt;<i> +	{ &quot;D(15)&quot;, SBT_BIDIR, &amp;sb_tms320vc5401pge [64], SBF_DEFINE_DATALINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 15 },
</I>&gt;<i> +	{ &quot;TOUT0&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;CLKOUT&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;IAQ_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;MSC_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;HOLDA_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;IOSTRB_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;R_W_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;MSTRB_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;IS_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;PS_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;DS_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;XF&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;IACK_NEG&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [63], SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;A(0)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 0 },
</I>&gt;<i> +	{ &quot;A(1)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 1 },
</I>&gt;<i> +	{ &quot;A(2)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 2 },
</I>&gt;<i> +	{ &quot;A(3)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 3 },
</I>&gt;<i> +	{ &quot;A(4)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 4 },
</I>&gt;<i> +	{ &quot;A(5)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 5 },
</I>&gt;<i> +	{ &quot;A(6)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 6 },
</I>&gt;<i> +	{ &quot;A(7)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 7 },
</I>&gt;<i> +	{ &quot;A(8)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 8 },
</I>&gt;<i> +	{ &quot;A(9)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 9 },
</I>&gt;<i> +	{ &quot;A(10)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 10 },
</I>&gt;<i> +	{ &quot;A(11)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 11 },
</I>&gt;<i> +	{ &quot;A(12)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 12 },
</I>&gt;<i> +	{ &quot;A(13)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 13 },
</I>&gt;<i> +	{ &quot;A(14)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 14 },
</I>&gt;<i> +	{ &quot;A(15)&quot;, SBT_OUT, &amp;sb_tms320vc5401pge [61], SBF_DEFINE_ADDRESSLINE | SBF_CONTROL_BY_ONE | SBF_CONTROLLED_FLOAT, 15 },
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static struct bsdl_info bsdl_info_tms320vc5401pge = {
</I>&gt;<i> +	114, sb_tms320vc5401pge, 0x00000002,
</I>&gt;<i> +	{ 0, 16 },
</I>&gt;<i> +	{ 0, 16 },
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *	RESET OPERATIONS
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *	JTAG OPERATIONS
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#ifdef TODO_FUTURE_OPERATION_PERHAPS
</I>&gt;<i> +static int bsdl_get_data_size (struct target *tgt, uint32_t *bits) {
</I>&gt;<i> +	/* TODO: Logic is flawed for some not-per-byte chips, like TMS320C54x */
</I>&gt;<i> +	uint8_t fst = target_bsdl_info(tgt)-&gt;bus_address.bus_first;
</I>&gt;<i> +	uint8_t snd = target_bsdl_info(tgt)-&gt;bus_data.bus_size;
</I>&gt;<i> +	if (fst &lt; 255) {
</I>&gt;<i> +		*bits = 8 &lt;&lt; fst;
</I>&gt;<i> +		if ((snd &lt; 255) &amp;&amp; (snd - 3 &gt; fst)) {
</I>&gt;<i> +			*bits = 1 &lt;&lt; snd;
</I>&gt;<i> +		}
</I>&gt;<i> +		return ERROR_OK;
</I>&gt;<i> +	} else if (snd &lt; 255) {
</I>&gt;<i> +		*bits = 1 &lt;&lt; snd;
</I>&gt;<i> +		return ERROR_OK;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		return ERROR_FAIL;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +#ifdef TODO_FUTURE_OPERATION_PERHAPS
</I>&gt;<i> +static int bsdl_get_address_size (struct target *tgt, uint32_t *bits) {
</I>&gt;<i> +	uint8_t siz = target_bsdl_info(tgt)-&gt;bus_address.bus_size;
</I>&gt;<i> +	if (siz &lt; 255) {
</I>&gt;<i> +		*bits = siz;
</I>&gt;<i> +		return ERROR_OK;
</I>&gt;<i> +	} else {
</I>&gt;<i> +		return ERROR_FAIL;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_read_word (struct target *tgt, uint32_t addr, uint32_t *data) {
</I>&gt;<i> +	struct bsdl_info *bi = target_bsdl_info (tgt);
</I>&gt;<i> +	struct scan_field irfield, drfield [3];
</I>&gt;<i> +	uint8_t instr[4];
</I>&gt;<i> +	uint16_t i, j;
</I>&gt;<i> +	int retval;
</I>&gt;<i> +	bool strobe, readnow;
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * 0. Determine current values for each scanbit.  Do not keep track
</I>&gt;<i> +	 *    of floating values here, because those cannot be clocked in or
</I>&gt;<i> +	 *    out.  Instead, the control bits in the JTAG chain will do this
</I>&gt;<i> +	 *    for us.
</I>&gt;<i> +	 */
</I>&gt;<i> +	for (j=0; j&lt;bi-&gt;num_scanbits; j++) {
</I>&gt;<i> +		register uint32_t flags = bi-&gt;all_scanbits [j].sb_flags;
</I>&gt;<i> +		register bool bitvalue;
</I>&gt;<i> +		/* 0.1. Setup default value as current value */
</I>&gt;<i> +		if (flags &amp; SBF_DEFAULT_SET) {
</I>&gt;<i> +			bitvalue = 1;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			bitvalue = 0;
</I>&gt;<i> +		}
</I>&gt;<i> +		/* 0.2. Override with address/data line value */
</I>&gt;<i> +		if (flags &amp; SBF_DEFINE_ADDRESSLINE) {
</I>&gt;<i> +			// TODO: Insert address line bit
</I>&gt;<i> +		}
</I>&gt;<i> +		if (flags &amp; SBF_DEFINE_DATALINE) {
</I>&gt;<i> +			// TODO: Insert data line bit (for writes, otherwise set to 1)
</I>&gt;<i> +		}
</I>&gt;<i> +		/* 0.3. Override with SBF_FORCE_xxx */
</I>&gt;<i> +		if (flags &amp; SBF_FORCE_SET) {
</I>&gt;<i> +			bitvalue = 1;
</I>&gt;<i> +		} else if (flags &amp; SBF_FORCE_RESET) {
</I>&gt;<i> +			bitvalue = 0;
</I>&gt;<i> +		}
</I>&gt;<i> +		/* 0.4. Override with SBF_CONTROL_xxx is left to the control bit hardware */
</I>&gt;<i> +		;
</I>&gt;<i> +		/* 0.5. Store outcome in scanbit flags field */
</I>&gt;<i> +		if (bitvalue) {
</I>&gt;<i> +			bi-&gt;all_scanbits [j].sb_flags |=  SBF_CURRENTLY_SET;
</I>&gt;<i> +		} else {
</I>&gt;<i> +			bi-&gt;all_scanbits [j].sb_flags &amp;= ~SBF_CURRENTLY_SET;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * 1. Setup JTAG for single chip access to boundary scan register
</I>&gt;<i> +	 */
</I>&gt;<i> +	irfield.tap = tgt-&gt;tap;
</I>&gt;<i> +	irfield.num_bits = irfield.tap-&gt;ir_length;
</I>&gt;<i> +	irfield.out_value = instr;
</I>&gt;<i> +	buf_set_u32 (irfield.out_value, 0, irfield.num_bits, bi-&gt;instr_sample);
</I>&gt;<i> +	irfield.in_value = NULL;
</I>&gt;<i> +// printf (&quot;idle or... %d\n&quot;, jtag_add_statemove (TAP_IDLE));
</I>&gt;<i> +// printf (&quot;irshift or... %d\n&quot;, jtag_add_statemove (TAP_IRSHIFT));
</I>&gt;<i> +// printf (&quot;execute or... %d\n&quot;, jtag_execute_queue ());
</I>&gt;<i> +	jtag_add_ir_scan (1, &amp;irfield, jtag_get_end_state ()); /* Other TAPs enter BYPASS */
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * 2. Setup neutral bits, fill address bus, float data bus  (makes drfield [0])
</I>&gt;<i> +	 * 4. As 2. but flip readstrobe pins                        (makes drfield [1])
</I>&gt;<i> +	 * 6. As 2. (so: As 4. but flip readstrobe pins once more)  (makes drfield [2])
</I>&gt;<i> +	 */
</I>&gt;<i> +	for (i=0; i&lt;3; i++) {
</I>&gt;<i> +		strobe  = (i==1);
</I>&gt;<i> +		readnow = (i==2);
</I>&gt;<i> +		drfield [i].tap = tgt-&gt;tap;
</I>&gt;<i> +		drfield [i].num_bits = bi-&gt;num_scanbits;
</I>&gt;<i> +		/*
</I>&gt;<i> +		 * Allocate appropriate fields, using calloc() to zero the bytes.
</I>&gt;<i> +		 */
</I>&gt;<i> +		// TODO: drfield [i].out_value = calloc (DIV_ROUND_UP (bi-&gt;num_scanbits, 8), 1) || exit (1);
</I>&gt;<i> +		drfield [i].out_value = calloc (DIV_ROUND_UP (bi-&gt;num_scanbits, 8), 1);
</I>&gt;<i> +		if (readnow) {
</I>&gt;<i> +			// TODO: drfield [i].in_value = calloc (DIV_ROUND_UP (bi-&gt;num_scanbits, 8), 1) || exit (1);
</I>&gt;<i> +			drfield [i].in_value = calloc (DIV_ROUND_UP (bi-&gt;num_scanbits, 8), 1);
</I>&gt;<i> +		} else {
</I>&gt;<i> +			drfield [i].in_value = NULL;
</I>&gt;<i> +		}
</I>&gt;<i> +		/*
</I>&gt;<i> +		 * Fill up the buffers with the various bits.  Bits are read and written from
</I>&gt;<i> +		 * left to right, that is the bytes from xxx_value [0] to the last, where the
</I>&gt;<i> +		 * highest-value bits of the last byte xxx_value [N-1] contain the last few bits.
</I>&gt;<i> +		 */
</I>&gt;<i> +		for (j=0; j&lt;bi-&gt;num_scanbits; j++) {
</I>&gt;<i> +			register uint32_t flags = bi-&gt;all_scanbits [j].sb_flags;
</I>&gt;<i> +			register bool bitvalue = (flags &amp; SBF_CURRENTLY_SET) != 0;
</I>&gt;<i> +			/* Invert strobe bits if this is the strobe phase being written */
</I>&gt;<i> +			if (strobe &amp;&amp; (flags &amp; SBF_DEFINE_READSTROBE)) {
</I>&gt;<i> +				bitvalue = !bitvalue;
</I>&gt;<i> +			}
</I>&gt;<i> +			/* If the bit must be set, make it so in the JTAG clock-out bit set */
</I>&gt;<i> +			if (bitvalue) {
</I>&gt;<i> +				drfield [i].out_value [j &gt;&gt; 3] |= 0x80 &gt;&gt; (j &amp; 0x0007);
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * 3. JTAG cycle on 2.
</I>&gt;<i> +	 * 5. JTAG cycle on 4.
</I>&gt;<i> +	 * 7. JTAG cycle on 6, collecting data bus from what is clocked out
</I>&gt;<i> +	 */
</I>&gt;<i> +	printf (&quot;drshift or... %d\n&quot;, jtag_add_statemove (TAP_DRSHIFT));
</I>&gt;<i> +	jtag_add_dr_scan (3, drfield, jtag_get_end_state ()); /* TAP selected by IR scan */
</I>&gt;<i> +	/*
</I>&gt;<i> +	 * 8. Harvest results from previous actions, notably data bus from last DR scan
</I>&gt;<i> +	 */
</I>&gt;<i> +	retval = jtag_execute_queue ();
</I>&gt;<i> +	if (retval != ERROR_OK) {
</I>&gt;<i> +		jtag_error_clear ();
</I>&gt;<i> +		return retval;
</I>&gt;<i> +	}
</I>&gt;<i> +	// TODO:HARVEST_DATA_FROM_drfield[2].in_value
</I>&gt;<i> +	// TODO:return ERROR_OK;
</I>&gt;<i> +	return ERROR_FAIL;	/* Not implemented yet */
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_write_word (struct target *tgt, uint32_t addr, uint32_t *data, uint8_t bits) {
</I>&gt;<i> +	return ERROR_FAIL;	/* Not implemented yet */
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *	MEMORY ACCESS OPERATIONS
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_virt2phys (struct target *target, uint32_t address, uint32_t *physical) {
</I>&gt;<i> +	*physical = address;
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_read_memory (struct target *tgt, uint32_t adr, uint32_t sz, uint32_t count, uint8_t *buf) {
</I>&gt;<i> +	uint32_t dta;
</I>&gt;<i> +	uint32_t szi;
</I>&gt;<i> +	int ok;
</I>&gt;<i> +	while (count-- &gt; 0) {
</I>&gt;<i> +		szi = sz;
</I>&gt;<i> +		ok = bsdl_read_word (tgt, adr, &amp;dta);
</I>&gt;<i> +		if (ok != ERROR_OK) {
</I>&gt;<i> +			return ok;
</I>&gt;<i> +		}
</I>&gt;<i> +		while (szi-- &gt; 0) {
</I>&gt;<i> +			*buf++ = dta &gt;&gt; (szi &lt;&lt; 3);
</I>&gt;<i> +		}
</I>&gt;<i> +		adr += sz;
</I>&gt;<i> +	}
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_write_memory (struct target *tgt, uint32_t adr, uint32_t sz, uint32_t count, uint8_t *buf) {
</I>&gt;<i> +	uint32_t dta;
</I>&gt;<i> +	uint32_t szi;
</I>&gt;<i> +	int ok;
</I>&gt;<i> +	while (count-- &gt; 0) {
</I>&gt;<i> +		szi = sz;
</I>&gt;<i> +		ok = bsdl_write_word (tgt, adr, &amp;dta, sz &lt;&lt; 3);
</I>&gt;<i> +		if (ok != ERROR_OK) {
</I>&gt;<i> +			return ok;
</I>&gt;<i> +		}
</I>&gt;<i> +		while (szi-- &gt; 0) {
</I>&gt;<i> +			*buf++ = dta &gt;&gt; (szi &lt;&lt; 3);
</I>&gt;<i> +		}
</I>&gt;<i> +		adr += sz;
</I>&gt;<i> +	}
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_bulk_write_memory (struct target *tgt, uint32_t adr, uint32_t count, uint8_t *buf) {
</I>&gt;<i> +	fputs (&quot;Not implemented yet: bsdl_bulk_write_memory()\n&quot;, stderr);
</I>&gt;<i> +	return ERROR_FAIL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_checksum_memory (struct target *tgt, uint32_t adr, uint32_t count, uint32_t *csum) {
</I>&gt;<i> +	fputs (&quot;Not implemented yet: bsdl_checksum_memory()\n&quot;, stderr);
</I>&gt;<i> +	return ERROR_FAIL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_blank_check_memory (struct target *tgt, uint32_t adr, uint32_t count, uint32_t *blank) {
</I>&gt;<i> +	fputs (&quot;Not implemented yet: bsdl_blank_check_memory()\n&quot;, stderr);
</I>&gt;<i> +	return ERROR_FAIL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_mmu (struct target *tgt, int * enabled) {
</I>&gt;<i> +	*enabled = 0;
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *	COMMAND INTERFACE OPERATIONS
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +static int bsdl_target_create (struct target *tgt, Jim_Interp *interp) {
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_loadfile) {
</I>&gt;<i> +	command_print (CMD_CTX, &quot;Not implemented yet: bsdl_loadfile()\n&quot;);
</I>&gt;<i> +	return ERROR_FAIL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_loadfile_urjtag) {
</I>&gt;<i> +	command_print (CMD_CTX, &quot;Not implemented yet: bsdl_loadfile_urjtag()\n&quot;);
</I>&gt;<i> +	return ERROR_FAIL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HELPER (bsdl_forcepins, unsigned int wish, unsigned int unwish) {
</I>&gt;<i> +	struct target *tgt;
</I>&gt;<i> +	int retval = ERROR_OK;
</I>&gt;<i> +	struct scanbit *thisbit;
</I>&gt;<i> +	int bits2go;
</I>&gt;<i> +	unsigned int thisarg;
</I>&gt;<i> +
</I>&gt;<i> +	/* Find the target and its boundary scan info */
</I>&gt;<i> +	tgt = get_current_target (CMD_CTX);
</I>&gt;<i> +
</I>&gt;<i> +	/* Iterate over the bits and assign the intended flag */
</I>&gt;<i> +	for (thisarg=0; thisarg&lt;CMD_ARGC; thisarg++) {
</I>&gt;<i> +		const char *bitstr = CMD_ARGV [thisarg];
</I>&gt;<i> +		int bitlen = strlen (bitstr);
</I>&gt;<i> +		bool found = 0;
</I>&gt;<i> +		/* Scan bit names ending in (*) count as a wildcard match */
</I>&gt;<i> +		if ((bitlen &gt; 3) &amp;&amp; !strcmp (bitstr+bitlen-3, &quot;(*)&quot;)) {
</I>&gt;<i> +			bitlen -= 2;	/* Compare scan bit names up to and including '(' */
</I>&gt;<i> +		} else {
</I>&gt;<i> +			bitlen ++;	/* Include '\0' but for safety use strncmp() instead of memcmp() */
</I>&gt;<i> +		}
</I>&gt;<i> +		thisbit = target_bsdl_info (tgt)-&gt;all_scanbits;
</I>&gt;<i> +		bits2go = target_bsdl_info (tgt)-&gt;num_scanbits;
</I>&gt;<i> +		while (bits2go &gt; 0) {
</I>&gt;<i> +			/* For each of the bits, check if the name matches bitstr/bitlen */
</I>&gt;<i> +			if ((thisbit-&gt;sb_name != NULL) &amp;&amp; !strncmp (bitstr, thisbit-&gt;sb_name, bitlen)) {
</I>&gt;<i> +				if (wish == SBF_FORCE_FLOAT) {
</I>&gt;<i> +					if ((!thisbit-&gt;sb_controller) || !(thisbit-&gt;sb_flags &amp; SBF_CONTROLLED_FLOAT))  {
</I>&gt;<i> +						command_print (CMD_CTX, &quot;Error: Bit %s cannot be floated\n&quot;,
</I>&gt;<i> +								thisbit-&gt;sb_name);
</I>&gt;<i> +					} else {
</I>&gt;<i> +						int newflag = thisbit-&gt;sb_controller-&gt;sb_flags;
</I>&gt;<i> +						if (thisbit-&gt;sb_flags &amp; SBF_CONTROL_BY_ONE) {
</I>&gt;<i> +							newflag |= SBF_FORCE_SET;
</I>&gt;<i> +						} else {
</I>&gt;<i> +							newflag |= SBF_FORCE_RESET;
</I>&gt;<i> +						}
</I>&gt;<i> +						if (((SBF_FORCE_SET | SBF_FORCE_RESET) &amp; ~newflag) != 0) {
</I>&gt;<i> +							thisbit-&gt;sb_controller-&gt;sb_flags = newflag;
</I>&gt;<i> +						} else {
</I>&gt;<i> +							command_print (CMD_CTX, &quot;It is not possible to force set and reset %s's controller %s\n&quot;,
</I>&gt;<i> +									thisbit-&gt;sb_name, thisbit-&gt;sb_controller-&gt;sb_name? thisbit-&gt;sb_controller-&gt;sb_name: &quot;&quot;);
</I>&gt;<i> +						}
</I>&gt;<i> +					}
</I>&gt;<i> +				}
</I>&gt;<i> +				if (thisbit-&gt;sb_flags &amp; unwish) {
</I>&gt;<i> +					command_print (CMD_CTX, &quot;Info: Overruling older setting for %s\n&quot;,
</I>&gt;<i> +								thisbit-&gt;sb_name);
</I>&gt;<i> +				}
</I>&gt;<i> +				thisbit-&gt;sb_flags = (thisbit-&gt;sb_flags &amp; ~unwish) | wish;
</I>&gt;<i> +				found++;
</I>&gt;<i> +			}
</I>&gt;<i> +			bits2go--;
</I>&gt;<i> +			thisbit++;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (found == 0) {
</I>&gt;<i> +			command_print (CMD_CTX, &quot;Error: Found no scan bits matching %s\n&quot;,
</I>&gt;<i> +					bitstr);
</I>&gt;<i> +			retval = ERROR_FAIL;
</I>&gt;<i> +		} else if (found &gt; 1) {
</I>&gt;<i> +			command_print (CMD_CTX, &quot;Info: Changed %d scanbits matching %s\n&quot;,
</I>&gt;<i> +					found, bitstr);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Check if any bits have been implicitly set to &quot;float&quot; */
</I>&gt;<i> +	thisbit = target_bsdl_info (tgt)-&gt;all_scanbits;
</I>&gt;<i> +	bits2go = target_bsdl_info (tgt)-&gt;num_scanbits;
</I>&gt;<i> +	while (bits2go &gt; 0) {
</I>&gt;<i> +		if (thisbit-&gt;sb_controller) {
</I>&gt;<i> +			if (thisbit-&gt;sb_controller-&gt;sb_flags &amp; (SBF_FORCE_SET | SBF_FORCE_RESET)) {
</I>&gt;<i> +				if (!thisbit-&gt;sb_flags &amp; SBF_FORCE_FLOAT) {
</I>&gt;<i> +					thisbit-&gt;sb_flags |= SBF_FORCE_FLOAT;
</I>&gt;<i> +					command_print (CMD_CTX, &quot;Warning: Implicit selection of float &quot;
</I>&gt;<i> +							&quot;mode on %s\n&quot;, thisbit-&gt;sb_name);
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +		thisbit++;
</I>&gt;<i> +		bits2go--;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Return the end result */
</I>&gt;<i> +	return retval;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_forcepins_set) {
</I>&gt;<i> +	return CALL_COMMAND_HANDLER (bsdl_forcepins, SBF_FORCE_SET, SBF_FORCE_RESET);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_forcepins_reset) {
</I>&gt;<i> +	return CALL_COMMAND_HANDLER (bsdl_forcepins, SBF_FORCE_RESET, SBF_FORCE_SET);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_forcepins_float) {
</I>&gt;<i> +	return CALL_COMMAND_HANDLER (bsdl_forcepins, SBF_FORCE_FLOAT, 0);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_forcenone) {
</I>&gt;<i> +	struct target *tgt;
</I>&gt;<i> +	struct scanbit *thisbit;
</I>&gt;<i> +	int bits2go;
</I>&gt;<i> +
</I>&gt;<i> +	/* Find the target and its boundary scan info */
</I>&gt;<i> +	tgt = get_current_target (CMD_CTX);
</I>&gt;<i> +
</I>&gt;<i> +	/* Iterate over scanbits and clean any forcing flags */
</I>&gt;<i> +	thisbit = target_bsdl_info (tgt)-&gt;all_scanbits;
</I>&gt;<i> +	bits2go = target_bsdl_info (tgt)-&gt;num_scanbits;
</I>&gt;<i> +	while (bits2go &gt; 0) {
</I>&gt;<i> +		thisbit-&gt;sb_flags &amp;= ~ (SBF_FORCE_SET | SBF_FORCE_RESET | SBF_FORCE_FLOAT);
</I>&gt;<i> +		thisbit++;
</I>&gt;<i> +		bits2go--;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Return the end result */
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HELPER (bsdl_strobepins, uint32_t strobeflag) {
</I>&gt;<i> +	struct target *tgt;
</I>&gt;<i> +	int retval = ERROR_OK;
</I>&gt;<i> +	struct scanbit *thisbit;
</I>&gt;<i> +	int bits2go;
</I>&gt;<i> +	unsigned int thisarg;
</I>&gt;<i> +
</I>&gt;<i> +	/* Find the target and its boundary scan info */
</I>&gt;<i> +	tgt = get_current_target (CMD_CTX);
</I>&gt;<i> +
</I>&gt;<i> +	/* Iterate over the bits and assign the intended flag */
</I>&gt;<i> +	for (thisarg=0; thisarg&lt;CMD_ARGC; thisarg++) {
</I>&gt;<i> +		const char *bitstr = CMD_ARGV [thisarg];
</I>&gt;<i> +		int bitlen = strlen (bitstr);
</I>&gt;<i> +		bool found = 0;
</I>&gt;<i> +		/* Scan bit names ending in (*) count as a wildcard match */
</I>&gt;<i> +		if ((bitlen &gt; 3) &amp;&amp; !strcmp (bitstr+bitlen-3, &quot;(*)&quot;)) {
</I>&gt;<i> +			bitlen -= 2;	/* Compare scan bit names up to and including '(' */
</I>&gt;<i> +		} else {
</I>&gt;<i> +			bitlen ++;	/* Include '\0' but for safety use strncmp() instead of memcmp() */
</I>&gt;<i> +		}
</I>&gt;<i> +		thisbit = target_bsdl_info (tgt)-&gt;all_scanbits;
</I>&gt;<i> +		bits2go = target_bsdl_info (tgt)-&gt;num_scanbits;
</I>&gt;<i> +		while (bits2go &gt; 0) {
</I>&gt;<i> +			/* For each of the bits, check if the name matches bitstr/bitlen */
</I>&gt;<i> +			if ((thisbit-&gt;sb_name != NULL) &amp;&amp; !strncmp (bitstr, thisbit-&gt;sb_name, bitlen)) {
</I>&gt;<i> +				thisbit-&gt;sb_flags |= strobeflag;
</I>&gt;<i> +				found++;
</I>&gt;<i> +			}
</I>&gt;<i> +			bits2go--;
</I>&gt;<i> +			thisbit++;
</I>&gt;<i> +		}
</I>&gt;<i> +		if (found == 0) {
</I>&gt;<i> +			command_print (CMD_CTX, &quot;Error: Found no scan bits matching %s\n&quot;,
</I>&gt;<i> +					bitstr);
</I>&gt;<i> +			retval = ERROR_FAIL;
</I>&gt;<i> +		} else if (found &gt; 1) {
</I>&gt;<i> +			command_print (CMD_CTX, &quot;Info: Changed %d scanbits matching %s\n&quot;,
</I>&gt;<i> +					found, bitstr);
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* Return the end result */
</I>&gt;<i> +	return retval;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_define_readstrobe) {
</I>&gt;<i> +	return CALL_COMMAND_HANDLER (bsdl_strobepins, SBF_DEFINE_READSTROBE);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_define_writestrobe) {
</I>&gt;<i> +	return CALL_COMMAND_HANDLER (bsdl_strobepins, SBF_DEFINE_WRITESTROBE);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HELPER (bsdl_buspins, struct target *tgt, struct businfo *bus, uint32_t bustp) {
</I>&gt;<i> +	int retval = ERROR_OK;
</I>&gt;<i> +	const char *bitstr;
</I>&gt;<i> +	int bitlen;
</I>&gt;<i> +	unsigned int testbit;
</I>&gt;<i> +	/* Check arguments */
</I>&gt;<i> +	if (CMD_ARGC != 1) {
</I>&gt;<i> +		retval = ERROR_INVALID_ARGUMENTS;
</I>&gt;<i> +	}
</I>&gt;<i> +	bitstr = CMD_ARGV [0];
</I>&gt;<i> +	bitlen = strlen (bitstr);
</I>&gt;<i> +	if ((bitlen &lt; 4) || (strcmp (bitstr+bitlen-3, &quot;(*)&quot;))) {
</I>&gt;<i> +		command_print (CMD_CTX, &quot;Please specify BUS(*) instead of %s\n&quot;, bitstr);
</I>&gt;<i> +		retval = ERROR_INVALID_ARGUMENTS;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (bitlen &gt; 100) {
</I>&gt;<i> +		command_print (CMD_CTX, &quot;Scan bit names should not exceed 100 positions\n&quot;);
</I>&gt;<i> +		retval = ERROR_INVALID_ARGUMENTS;
</I>&gt;<i> +	}
</I>&gt;<i> +	if (retval != ERROR_OK) {
</I>&gt;<i> +		return retval;
</I>&gt;<i> +	}
</I>&gt;<i> +	/* Construct the bus */
</I>&gt;<i> +	bus-&gt;bus_first = 255;
</I>&gt;<i> +	bus-&gt;bus_size = 255;
</I>&gt;<i> +	for (testbit=0; testbit &lt; target_bsdl_info(tgt)-&gt;num_scanbits; testbit++) {
</I>&gt;<i> +		char testarea [120];
</I>&gt;<i> +		struct scanbit *thisbit = target_bsdl_info(tgt)-&gt;all_scanbits;
</I>&gt;<i> +		int bits2go = target_bsdl_info(tgt)-&gt;num_scanbits;
</I>&gt;<i> +		strcpy (testarea, bitstr);
</I>&gt;<i> +		snprintf (testarea + bitlen - 3, 110+3-bitlen, &quot;(%d)&quot;, testbit);
</I>&gt;<i> +		while (bits2go &gt; 0) {
</I>&gt;<i> +			if (thisbit-&gt;sb_name &amp;&amp; !strcmp (testarea, thisbit-&gt;sb_name)) {
</I>&gt;<i> +				if (bus-&gt;bus_first == 255) {
</I>&gt;<i> +					bus-&gt;bus_first = testbit;
</I>&gt;<i> +				} else if (bus-&gt;bus_size != testbit) {
</I>&gt;<i> +					command_print (CMD_CTX, &quot;Error: Bus pins are not incrementally numbered&quot;);
</I>&gt;<i> +					retval = ERROR_FAIL;
</I>&gt;<i> +				}
</I>&gt;<i> +				if (thisbit-&gt;sb_flags &amp; (SBF_DEFINE_ADDRESSLINE | SBF_DEFINE_DATALINE) &amp; ~bustp) {
</I>&gt;<i> +					command_print (CMD_CTX, &quot;Error: A pin cannot be part of data bus as well as address bus\n&quot;);
</I>&gt;<i> +					retval = ERROR_FAIL;
</I>&gt;<i> +				} else {
</I>&gt;<i> +					thisbit-&gt;sb_flags |= bustp;
</I>&gt;<i> +				}
</I>&gt;<i> +				bus-&gt;bus_size = testbit + 1;
</I>&gt;<i> +				thisbit-&gt;sb_linebit = testbit;
</I>&gt;<i> +			}
</I>&gt;<i> +			thisbit++;
</I>&gt;<i> +			bits2go--;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	/* Return if we were successful overall */
</I>&gt;<i> +	return retval;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_define_address) {
</I>&gt;<i> +	struct target *tgt = get_current_target (CMD_CTX);
</I>&gt;<i> +	struct businfo *bus = &amp;target_bsdl_info(tgt)-&gt;bus_address;
</I>&gt;<i> +	return CALL_COMMAND_HANDLER (bsdl_buspins, tgt, bus, SBF_DEFINE_ADDRESSLINE);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +COMMAND_HANDLER (bsdl_define_data) {
</I>&gt;<i> +	struct target *tgt = get_current_target (CMD_CTX);
</I>&gt;<i> +	struct businfo *bus = &amp;target_bsdl_info(tgt)-&gt;bus_data;
</I>&gt;<i> +	return CALL_COMMAND_HANDLER (bsdl_buspins, tgt, bus, SBF_DEFINE_DATALINE);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *	GENERIC ROUTINES
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +#if 0
</I>&gt;<i> +COMMAND_HANDLER (bsdl_noop) {
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +int bsdl_init (struct command_context *cmd_ctx, struct target *target) {
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +int bsdl_poll (struct target *target) {
</I>&gt;<i> +	return ERROR_OK;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + *	DRIVER DESCRIPTIVE STRUCTURES
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +static const struct command_registration bsdl_commands_define[] = {
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;address&quot;,
</I>&gt;<i> +		.usage = &quot;pinname...&quot;,
</I>&gt;<i> +		.help = &quot;When accessing memory, place the target address on these pins&quot;,
</I>&gt;<i> +		.handler = bsdl_define_address,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;data&quot;,
</I>&gt;<i> +		.usage = &quot;pinname...&quot;,
</I>&gt;<i> +		.help = &quot;When accessing memory, exchange data over these pins&quot;,
</I>&gt;<i> +		.handler = bsdl_define_data,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;readstrobe&quot;,
</I>&gt;<i> +		.usage = &quot;pinname...&quot;,
</I>&gt;<i> +		.help = &quot;When reading from memory, temporarily change these pins to send a strobe signal&quot;,
</I>&gt;<i> +		.handler = bsdl_define_readstrobe,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;writestrobe&quot;,
</I>&gt;<i> +		.usage = &quot;pinname...&quot;,
</I>&gt;<i> +		.help = &quot;When writing to memory, temporarily change these pins to send a strobe signal&quot;,
</I>&gt;<i> +		.handler = bsdl_define_writestrobe,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	COMMAND_REGISTRATION_DONE
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static const struct command_registration bsdl_commands_force[] = {
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;set&quot;,
</I>&gt;<i> +		.usage = &quot;pinname...&quot;,
</I>&gt;<i> +		.help = &quot;During future boundary scans, make sure to set the named pins to 1&quot;,
</I>&gt;<i> +		.handler = bsdl_forcepins_set,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;reset&quot;,
</I>&gt;<i> +		.usage = &quot;pinname...&quot;,
</I>&gt;<i> +		.help = &quot;During future boundary scans, make sure to set the named pins to 0&quot;,
</I>&gt;<i> +		.handler = bsdl_forcepins_reset,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;float&quot;,
</I>&gt;<i> +		.usage = &quot;pinname...&quot;,
</I>&gt;<i> +		.help = &quot;During future boundary scans, make sure to make the named pins float&quot;,
</I>&gt;<i> +		.handler = bsdl_forcepins_float,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;none&quot;,
</I>&gt;<i> +		.usage = &quot;&quot;,
</I>&gt;<i> +		.help = &quot;During future boundary scans, do not force any pin values&quot;,
</I>&gt;<i> +		.handler = bsdl_forcenone,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	COMMAND_REGISTRATION_DONE
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +static const struct command_registration bsdl_commands[] = {
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;bsdlfile&quot;,
</I>&gt;<i> +		.usage = &quot;filename&quot;,
</I>&gt;<i> +		.help = &quot;Load BSDL description from named file&quot;,
</I>&gt;<i> +		.handler = bsdl_loadfile,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;urjtagfile&quot;,
</I>&gt;<i> +		.usage = &quot;filename&quot;,
</I>&gt;<i> +		.help = &quot;DEPRECATED: Load JTAG description from named file, created by UrJTAG's bsdl2jtag&quot;,
</I>&gt;<i> +		.handler = bsdl_loadfile_urjtag,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;force&quot;,
</I>&gt;<i> +		.usage = &quot;'set' ... | 'reset' ... | 'float' ... | 'none'&quot;,
</I>&gt;<i> +		.help = &quot;Commands to force the state of pins during upcoming boundary scans&quot;,
</I>&gt;<i> +		.chain = bsdl_commands_force,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	{
</I>&gt;<i> +		.name = &quot;define&quot;,
</I>&gt;<i> +		.usage = &quot;'address' ... | 'data' ... | 'readstrobe' ... | 'writestrobe' ...&quot;,
</I>&gt;<i> +		.help = &quot;Commands to define the functions of pins&quot;,
</I>&gt;<i> +		.chain = bsdl_commands_define,
</I>&gt;<i> +		.mode = COMMAND_ANY,
</I>&gt;<i> +	},
</I>&gt;<i> +	COMMAND_REGISTRATION_DONE
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +const struct target_type generic_bsdl_target = {
</I>&gt;<i> +
</I>&gt;<i> +	/* Constants */
</I>&gt;<i> +	.name = &quot;generic_bsdl&quot;,
</I>&gt;<i> +	.commands = bsdl_commands,
</I>&gt;<i> +
</I>&gt;<i> +	/* Reset */
</I>&gt;<i> +
</I>&gt;<i> +	/* JTAG */
</I>&gt;<i> +
</I>&gt;<i> +	/* Memory */
</I>&gt;<i> +	.read_memory = bsdl_read_memory,
</I>&gt;<i> +	.read_memory_imp = bsdl_read_memory,
</I>&gt;<i> +	.read_phys_memory = bsdl_read_memory,
</I>&gt;<i> +	.write_memory = bsdl_write_memory,
</I>&gt;<i> +	.write_memory_imp = bsdl_write_memory,
</I>&gt;<i> +	.write_phys_memory = bsdl_write_memory,
</I>&gt;<i> +	.bulk_write_memory = bsdl_bulk_write_memory,
</I>&gt;<i> +	.checksum_memory = bsdl_checksum_memory,
</I>&gt;<i> +	.blank_check_memory = bsdl_blank_check_memory,
</I>&gt;<i> +	.mmu = bsdl_mmu,
</I>&gt;<i> +	.virt2phys = bsdl_virt2phys,
</I>&gt;<i> +
</I>&gt;<i> +	/* Commands */
</I>&gt;<i> +	.target_create = bsdl_target_create,
</I>&gt;<i> +
</I>&gt;<i> +	/* General setup */
</I>&gt;<i> +	.init_target = bsdl_init,
</I>&gt;<i> +	.poll = bsdl_poll,
</I>&gt;<i> +
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> diff -Nur openocd-0.4.0-orig/src/target/target.c openocd-0.4.0-plus_bsdl/src/target/target.c
</I>&gt;<i> --- openocd-0.4.0-orig/src/target/target.c	2010-02-21 20:17:07.000000000 +0000
</I>&gt;<i> +++ openocd-0.4.0-plus_bsdl/src/target/target.c	2010-10-06 11:02:01.000000000 +0000
</I>&gt;<i> @@ -68,6 +68,7 @@
</I>&gt;<i>  extern struct target_type avr_target;
</I>&gt;<i>  extern struct target_type dsp563xx_target;
</I>&gt;<i>  extern struct target_type testee_target;
</I>&gt;<i> +extern struct target_type generic_bsdl_target;
</I>&gt;<i>  
</I>&gt;<i>  struct target_type *target_types[] =
</I>&gt;<i>  {
</I>&gt;<i> @@ -88,6 +89,7 @@
</I>&gt;<i>  	&amp;avr_target,
</I>&gt;<i>  	&amp;dsp563xx_target,
</I>&gt;<i>  	&amp;testee_target,
</I>&gt;<i> +	&amp;generic_bsdl_target,
</I>&gt;<i>  	NULL,
</I>&gt;<i>  };
</I>&gt;<i>  
</I>&gt;<i> @@ -3905,7 +3907,7 @@
</I>&gt;<i>  	Jim_GetOptInfo goi;
</I>&gt;<i>  	Jim_GetOpt_Setup(&amp;goi, interp, argc - 1, argv + 1);
</I>&gt;<i>  
</I>&gt;<i> -	if ((goi.argc == 2) || (goi.argc == 3))
</I>&gt;<i> +	if ((goi.argc == 3) || (goi.argc == 4))
</I>&gt;<i>  	{
</I>&gt;<i>  		Jim_SetResult_sprintf(goi.interp,
</I>&gt;<i>  				&quot;usage: %s &lt;address&gt; [&lt;count&gt;]&quot;, cmd_name);
</I>&gt;<i>   
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016678.html">[Openocd-development] BSDL target, how to use JTAG?
</A></li>
	<LI>Next message: <A HREF="016688.html">[Openocd-development] BSDL target, how to use JTAG?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16680">[ date ]</a>
              <a href="thread.html#16680">[ thread ]</a>
              <a href="subject.html#16680">[ subject ]</a>
              <a href="author.html#16680">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-development">More information about the Openocd-development
mailing list</a><br>
</body></html>
