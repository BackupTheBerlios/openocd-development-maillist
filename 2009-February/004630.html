<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-development] [PATCH] Cable Driver Helper API
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-development/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20%5BPATCH%5D%20Cable%20Driver%20Helper%20API&In-Reply-To=%3C80039006-139E-4619-B145-65EA6D8B5312%40kc8apf.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004773.html">
   <LINK REL="Next"  HREF="004632.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-development] [PATCH] Cable Driver Helper API</H1>
    <B>Rick Altherr</B> 
    <A HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20%5BPATCH%5D%20Cable%20Driver%20Helper%20API&In-Reply-To=%3C80039006-139E-4619-B145-65EA6D8B5312%40kc8apf.net%3E"
       TITLE="[Openocd-development] [PATCH] Cable Driver Helper API">kc8apf at kc8apf.net
       </A><BR>
    <I>Sun Feb  1 21:25:39 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="004773.html">[Openocd-development] tap_move in src/jtag/jtag.c
</A></li>
        <LI>Next message: <A HREF="004632.html">[Openocd-development] [PATCH] Cable Driver Helper API
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4630">[ date ]</a>
              <a href="thread.html#4630">[ thread ]</a>
              <a href="subject.html#4630">[ subject ]</a>
              <a href="author.html#4630">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'm not trying to be picky, but this particular patch is hard to  
read.  It looks like a bunch of formatting changes were made (probably  
via your uncrustify script that I plan to commit soon) in addition to  
the cable driver helper API.  Would it be possible to split those into  
2 patches?  As it stands, I can't find where you've changed things for  
the cable driver helper API in this patch.

Rick


On Jan 31, 2009, at 2:00 PM, Dick Hollenbeck wrote:

&gt;<i> This patch implements a &quot;Cable Helper API&quot; and is quite extensive.
</I>&gt;<i>
</I>&gt;<i> Please see the comments and API docs in jtag.h contained within the  
</I>&gt;<i> delimiters:
</I>&gt;<i>
</I>&gt;<i> /*-----&lt;Cable Helper API&gt;-------------------------------------------*/
</I>&gt;<i>
</I>&gt;<i> here is the good stuff
</I>&gt;<i>
</I>&gt;<i> /*-----&lt;/Cable Helper API&gt;------------------------------------------*/
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The comments within this region are Doxygen compatible and will  
</I>&gt;<i> generate nice HTML docs from the Doxyfile patch I submitted earlier.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The motivation for this was three fold:
</I>&gt;<i>
</I>&gt;<i> 1) Document the stuff cable drivers can use to make their lives  
</I>&gt;<i> easier.
</I>&gt;<i>
</I>&gt;<i> 2) Get to a point where no TAP state changes can happen without them  
</I>&gt;<i> being logged by a cable driver via the new tap_set_state()  
</I>&gt;<i> function.  Think of this function like a reporter or a broadcast  
</I>&gt;<i> service now.  If a driver is going to affect a state change in a  
</I>&gt;<i> real TAP controller on the cable, then it should tell this function  
</I>&gt;<i> about EVERY transition.  The overhead is nil, but if compiled with  
</I>&gt;<i> JTAG_DEBUG_IO enabled, the state changes can be logged.
</I>&gt;<i> Note that no driver is at this point yet, but I will be pushing the  
</I>&gt;<i> ft2232.c driver there as soon as this patch is committed.  I did not  
</I>&gt;<i> want to introduce too many changes at once.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 3)  Information hiding, reduction of global variables.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> 4) Move away from so damn many arrays, which are prone to out of  
</I>&gt;<i> bounds problems and cannot be documented as well as functions.   
</I>&gt;<i> Switches and functions are used instead.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> This is about 80% of what I wanted to accomplish.  The state  
</I>&gt;<i> tracking is simple from here and that is still coming for my driver.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> For example:
</I>&gt;<i>
</I>&gt;<i>   tap_set_state() and tap_get_state() replace cur_state.
</I>&gt;<i>
</I>&gt;<i> Generate the docs with Doxygen, and read the jtag.h file's output.
</I>&gt;<i>
</I>&gt;<i> Dick
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Index: src/helper/binarybuffer.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/helper/binarybuffer.c	(revision 1363)
</I>&gt;<i> +++ src/helper/binarybuffer.c	(working copy)
</I>&gt;<i> @@ -32,23 +32,23 @@
</I>&gt;<i>
</I>&gt;<i> #include &quot;binarybuffer.h&quot;
</I>&gt;<i>
</I>&gt;<i> -const unsigned char bit_reverse_table256[] =
</I>&gt;<i> +const unsigned char bit_reverse_table256[] =
</I>&gt;<i> {
</I>&gt;<i> -  0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50,  
</I>&gt;<i> 0xD0, 0x30, 0xB0, 0x70, 0xF0,
</I>&gt;<i> -  0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58,  
</I>&gt;<i> 0xD8, 0x38, 0xB8, 0x78, 0xF8,
</I>&gt;<i> -  0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54,  
</I>&gt;<i> 0xD4, 0x34, 0xB4, 0x74, 0xF4,
</I>&gt;<i> -  0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C,  
</I>&gt;<i> 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
</I>&gt;<i> -  0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52,  
</I>&gt;<i> 0xD2, 0x32, 0xB2, 0x72, 0xF2,
</I>&gt;<i> +  0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50,  
</I>&gt;<i> 0xD0, 0x30, 0xB0, 0x70, 0xF0,
</I>&gt;<i> +  0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58,  
</I>&gt;<i> 0xD8, 0x38, 0xB8, 0x78, 0xF8,
</I>&gt;<i> +  0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54,  
</I>&gt;<i> 0xD4, 0x34, 0xB4, 0x74, 0xF4,
</I>&gt;<i> +  0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C,  
</I>&gt;<i> 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
</I>&gt;<i> +  0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52,  
</I>&gt;<i> 0xD2, 0x32, 0xB2, 0x72, 0xF2,
</I>&gt;<i>   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A,  
</I>&gt;<i> 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
</I>&gt;<i> -  0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56,  
</I>&gt;<i> 0xD6, 0x36, 0xB6, 0x76, 0xF6,
</I>&gt;<i> +  0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56,  
</I>&gt;<i> 0xD6, 0x36, 0xB6, 0x76, 0xF6,
</I>&gt;<i>   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E,  
</I>&gt;<i> 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
</I>&gt;<i>   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51,  
</I>&gt;<i> 0xD1, 0x31, 0xB1, 0x71, 0xF1,
</I>&gt;<i> -  0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59,  
</I>&gt;<i> 0xD9, 0x39, 0xB9, 0x79, 0xF9,
</I>&gt;<i> +  0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59,  
</I>&gt;<i> 0xD9, 0x39, 0xB9, 0x79, 0xF9,
</I>&gt;<i>   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55,  
</I>&gt;<i> 0xD5, 0x35, 0xB5, 0x75, 0xF5,
</I>&gt;<i>   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D,  
</I>&gt;<i> 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
</I>&gt;<i> -  0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53,  
</I>&gt;<i> 0xD3, 0x33, 0xB3, 0x73, 0xF3,
</I>&gt;<i> +  0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53,  
</I>&gt;<i> 0xD3, 0x33, 0xB3, 0x73, 0xF3,
</I>&gt;<i>   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B,  
</I>&gt;<i> 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
</I>&gt;<i> -  0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57,  
</I>&gt;<i> 0xD7, 0x37, 0xB7, 0x77, 0xF7,
</I>&gt;<i> +  0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57,  
</I>&gt;<i> 0xD7, 0x37, 0xB7, 0x77, 0xF7,
</I>&gt;<i>   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F,  
</I>&gt;<i> 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> @@ -63,8 +63,8 @@
</I>&gt;<i>
</I>&gt;<i> 	for (i = 0; i &lt; num_bytes; i++)
</I>&gt;<i> 		to[i] = from[i];
</I>&gt;<i> -	
</I>&gt;<i> -	/* mask out bits that don't belong to the buffer */	
</I>&gt;<i> +
</I>&gt;<i> +	/* mask out bits that don't belong to the buffer */
</I>&gt;<i> 	if (size % 8)
</I>&gt;<i> 	{
</I>&gt;<i> 		to[size / 8] &amp;= (0xff &gt;&gt; (8 - (size % 8)));
</I>&gt;<i> @@ -111,7 +111,7 @@
</I>&gt;<i> 		/* mask out bits that don't really belong to the buffer if size  
</I>&gt;<i> isn't a multiple of 8 bits */
</I>&gt;<i> 		if ((size % 8) &amp;&amp; (i == num_bytes -1 ))
</I>&gt;<i> 		{
</I>&gt;<i> -			if ((buf1[i] &amp; ((1 &lt;&lt; (size % 8)) - 1) &amp; mask[i]) !=
</I>&gt;<i> +			if ((buf1[i] &amp; ((1 &lt;&lt; (size % 8)) - 1) &amp; mask[i]) !=
</I>&gt;<i> 				(buf2[i] &amp; ((1 &lt;&lt; (size % 8)) - 1) &amp; mask[i]))
</I>&gt;<i> 				return 1;
</I>&gt;<i> 		}
</I>&gt;<i> @@ -136,10 +136,10 @@
</I>&gt;<i> 			buf[i] = 0xff;
</I>&gt;<i> 		else
</I>&gt;<i> 			buf[i] = (1 &lt;&lt; count) - 1;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 		count -= 8;
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return buf;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -147,7 +147,7 @@
</I>&gt;<i> {
</I>&gt;<i> 	int src_idx = src_start, dst_idx = dst_start;
</I>&gt;<i> 	int i;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	for (i = 0; i &lt; len; i++)
</I>&gt;<i> 	{
</I>&gt;<i> 		if (((src[src_idx/8] &gt;&gt; (src_idx % 8)) &amp; 1) == 1)
</I>&gt;<i> @@ -164,9 +164,9 @@
</I>&gt;<i> u32 flip_u32(u32 value, unsigned int num)
</I>&gt;<i> {
</I>&gt;<i> 	u32 c;
</I>&gt;<i> -	
</I>&gt;<i> -	c = (bit_reverse_table256[value &amp; 0xff] &lt;&lt; 24) |
</I>&gt;<i> -		(bit_reverse_table256[(value &gt;&gt; 8) &amp; 0xff] &lt;&lt; 16) |
</I>&gt;<i> +
</I>&gt;<i> +	c = (bit_reverse_table256[value &amp; 0xff] &lt;&lt; 24) |
</I>&gt;<i> +		(bit_reverse_table256[(value &gt;&gt; 8) &amp; 0xff] &lt;&lt; 16) |
</I>&gt;<i> 		(bit_reverse_table256[(value &gt;&gt; 16) &amp; 0xff] &lt;&lt; 8) |
</I>&gt;<i> 		(bit_reverse_table256[(value &gt;&gt; 24) &amp; 0xff]);
</I>&gt;<i>
</I>&gt;<i> @@ -179,21 +179,21 @@
</I>&gt;<i> int ceil_f_to_u32(float x)
</I>&gt;<i> {
</I>&gt;<i> 	u32 y;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if (x &lt; 0)	/* return zero for negative numbers */
</I>&gt;<i> 		return 0;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	y = x;	/* cut off fraction */
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if ((x - y) &gt; 0.0) /* if there was a fractional part, increase by  
</I>&gt;<i> one */
</I>&gt;<i> 		y++;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return y;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> char* buf_to_str(const u8 *buf, int buf_len, int radix)
</I>&gt;<i> {
</I>&gt;<i> -	const char *DIGITS = &quot;0123456789abcdef&quot;;
</I>&gt;<i> +	const char *DIGITS = &quot;0123456789ABCDEF&quot;;
</I>&gt;<i> 	float factor;
</I>&gt;<i> 	char *str;
</I>&gt;<i> 	int str_len;
</I>&gt;<i> @@ -202,7 +202,7 @@
</I>&gt;<i>
</I>&gt;<i> 	int j; /* base-256 digits */
</I>&gt;<i> 	int i; /* output digits (radix) */
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if (radix == 16)
</I>&gt;<i> 	{
</I>&gt;<i> 		factor = 2.0;   /* log(256) / log(16) = 2.0 */
</I>&gt;<i> @@ -217,10 +217,10 @@
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> 		return NULL;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	str_len = ceil_f_to_u32(CEIL(buf_len, 8) * factor);
</I>&gt;<i> 	str = calloc(str_len + 1, 1);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	for (i = b256_len - 1; i &gt;= 0; i--)
</I>&gt;<i> 	{
</I>&gt;<i> 		tmp = buf[i];
</I>&gt;<i> @@ -237,7 +237,7 @@
</I>&gt;<i>
</I>&gt;<i> 	for (j = 0; j &lt; str_len; j++)
</I>&gt;<i> 		str[j] = DIGITS[(int)str[j]];
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return str;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -247,12 +247,12 @@
</I>&gt;<i> 	u32 tmp;
</I>&gt;<i> 	float factor;
</I>&gt;<i> 	u8 *b256_buf;
</I>&gt;<i> -	int b256_len;
</I>&gt;<i> -	
</I>&gt;<i> +	int b256_len;
</I>&gt;<i> +
</I>&gt;<i> 	int j; /* base-256 digits */
</I>&gt;<i> 	int i; /* input digits (ASCII) */
</I>&gt;<i> -	
</I>&gt;<i> -	if (radix == 0)	
</I>&gt;<i> +
</I>&gt;<i> +	if (radix == 0)
</I>&gt;<i> 	{
</I>&gt;<i> 		/* identify radix, and skip radix-prefix (0, 0x or 0X) */
</I>&gt;<i> 		if ((str[0] == '0') &amp;&amp; (str[1] &amp;&amp; ((str[1] == 'x') || (str[1] ==  
</I>&gt;<i> 'X'))))
</I>&gt;<i> @@ -272,7 +272,7 @@
</I>&gt;<i> 			radix = 10;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if (radix == 16)
</I>&gt;<i> 		factor = 0.5; /* log(16) / log(256) = 0.5 */
</I>&gt;<i> 	else if (radix == 10)
</I>&gt;<i> @@ -286,14 +286,14 @@
</I>&gt;<i> 	charbuf = malloc(str_len + 1);
</I>&gt;<i> 	memcpy(charbuf, str, str_len);
</I>&gt;<i> 	charbuf[str_len] = '\0';
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	/* number of digits in base-256 notation */
</I>&gt;<i> 	b256_len = ceil_f_to_u32(str_len * factor);
</I>&gt;<i> 	b256_buf = calloc(b256_len, 1);
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 	/* go through zero terminated buffer */
</I>&gt;<i> 	for (i = 0; charbuf[i]; i++)
</I>&gt;<i> -	{
</I>&gt;<i> +	{
</I>&gt;<i> 		tmp = charbuf[i];
</I>&gt;<i> 		if ((tmp &gt;= '0') &amp;&amp; (tmp &lt;= '9'))
</I>&gt;<i> 			tmp = (tmp - '0');
</I>&gt;<i> @@ -302,19 +302,19 @@
</I>&gt;<i> 		else if ((tmp &gt;= 'A') &amp;&amp; (tmp &lt;= 'F'))
</I>&gt;<i> 			tmp = (tmp - 'A' + 10);
</I>&gt;<i> 		else continue;	/* skip characters other than [0-9,a-f,A-F] */
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		if (tmp &gt;= radix)
</I>&gt;<i> -			continue;	/* skip digits invalid for the current radix */
</I>&gt;<i> -		
</I>&gt;<i> +			continue;	/* skip digits invalid for the current radix */
</I>&gt;<i> +
</I>&gt;<i> 		for (j = 0; j &lt; b256_len; j++)
</I>&gt;<i> 		{
</I>&gt;<i> 			tmp += (u32)b256_buf[j] * radix;
</I>&gt;<i> 			b256_buf[j] = (u8)(tmp &amp; 0xFF);
</I>&gt;<i> 			tmp &gt;&gt;= 8;
</I>&gt;<i> 		}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	for (j = 0; j &lt; CEIL(buf_len, 8); j++)
</I>&gt;<i> 	{
</I>&gt;<i> 		if (j &lt; b256_len)
</I>&gt;<i> @@ -326,18 +326,18 @@
</I>&gt;<i> 	/* mask out bits that don't belong to the buffer */
</I>&gt;<i> 	if (buf_len % 8)
</I>&gt;<i> 		buf[(buf_len / 8)] &amp;= 0xff &gt;&gt; (8 - (buf_len % 8));
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 	free(b256_buf);
</I>&gt;<i> 	free(charbuf);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return i;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int buf_to_u32_handler(u8 *in_buf, void *priv, struct scan_field_s  
</I>&gt;<i> *field)
</I>&gt;<i> {
</I>&gt;<i> 	u32 *dest = priv;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	*dest = buf_get_u32(in_buf, 0, 32);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i> Index: src/jtag/rlink/rlink.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/rlink/rlink.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/rlink/rlink.c	(working copy)
</I>&gt;<i> @@ -122,7 +122,7 @@
</I>&gt;<i> 		*usb_buffer_p++ = va_arg(ap, int);
</I>&gt;<i> 		length--;
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	memset(
</I>&gt;<i> 		usb_buffer_p,
</I>&gt;<i> 		0,
</I>&gt;<i> @@ -176,7 +176,7 @@
</I>&gt;<i> 		usb_buffer[2] = addr;
</I>&gt;<i> 		usb_buffer[3] = length;
</I>&gt;<i>
</I>&gt;<i> -      		usb_ret = usb_bulk_write(
</I>&gt;<i> +			usb_ret = usb_bulk_write(
</I>&gt;<i> 			pHDev, USB_EP1OUT_ADDR,
</I>&gt;<i> 			usb_buffer, sizeof(usb_buffer),
</I>&gt;<i> 			USB_TIMEOUT_MS
</I>&gt;<i> @@ -185,7 +185,7 @@
</I>&gt;<i> 		if(usb_ret &lt; sizeof(usb_buffer)) {
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		usb_ret = usb_bulk_read(
</I>&gt;<i> 			pHDev, USB_EP1IN_ADDR,
</I>&gt;<i> 			buffer, length,
</I>&gt;<i> @@ -195,7 +195,7 @@
</I>&gt;<i> 		if(usb_ret &lt; length) {
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		addr += length;
</I>&gt;<i> 		buffer += length;
</I>&gt;<i> 		count += length;
</I>&gt;<i> @@ -247,7 +247,7 @@
</I>&gt;<i> 			sizeof(usb_buffer) - 4 - length
</I>&gt;<i> 		);
</I>&gt;<i>
</I>&gt;<i> -      		usb_ret = usb_bulk_write(
</I>&gt;<i> +			usb_ret = usb_bulk_write(
</I>&gt;<i> 			pHDev, USB_EP1OUT_ADDR,
</I>&gt;<i> 			(char *)usb_buffer, sizeof(usb_buffer),
</I>&gt;<i> 			USB_TIMEOUT_MS
</I>&gt;<i> @@ -256,7 +256,7 @@
</I>&gt;<i> 		if(usb_ret &lt; sizeof(usb_buffer)) {
</I>&gt;<i> 			break;
</I>&gt;<i> 		}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		addr += length;
</I>&gt;<i> 		buffer += length;
</I>&gt;<i> 		count += length;
</I>&gt;<i> @@ -343,7 +343,7 @@
</I>&gt;<i> 			LOG_ERROR(&quot;Malformed DTC image\n&quot;);
</I>&gt;<i> 			exit(1);
</I>&gt;<i> 		}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		header = (struct header_s *)buffer;
</I>&gt;<i> 		buffer += sizeof(*header);
</I>&gt;<i> 		length -= sizeof(*header);
</I>&gt;<i> @@ -352,7 +352,7 @@
</I>&gt;<i> 			LOG_ERROR(&quot;Malformed DTC image\n&quot;);
</I>&gt;<i> 			exit(1);
</I>&gt;<i> 		}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		switch(header-&gt;type) {
</I>&gt;<i> 			case DTCLOAD_COMMENT:
</I>&gt;<i> 				break;
</I>&gt;<i> @@ -365,7 +365,7 @@
</I>&gt;<i> 				break;
</I>&gt;<i>
</I>&gt;<i> 			case DTCLOAD_LOAD:
</I>&gt;<i> -   				/* Send the DTC program to ST7 RAM. */
</I>&gt;<i> +				/* Send the DTC program to ST7 RAM. */
</I>&gt;<i> 				usb_err = ep1_memory_write(
</I>&gt;<i> 					pHDev,
</I>&gt;<i> 					DTC_LOAD_BUFFER,
</I>&gt;<i> @@ -398,9 +398,9 @@
</I>&gt;<i> 			case DTCLOAD_LUT_START:
</I>&gt;<i> 				lut_start = buffer[0];
</I>&gt;<i> 				break;
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 			case DTCLOAD_LUT:
</I>&gt;<i> -   				usb_err = ep1_memory_write(
</I>&gt;<i> +				usb_err = ep1_memory_write(
</I>&gt;<i> 					pHDev,
</I>&gt;<i> 					ST7_USB_BUF_EP0OUT + lut_start,
</I>&gt;<i> 					header-&gt;length + 1, buffer
</I>&gt;<i> @@ -413,7 +413,7 @@
</I>&gt;<i> 				exit(1);
</I>&gt;<i> 				break;
</I>&gt;<i> 		}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		buffer += (header-&gt;length + 1);
</I>&gt;<i> 		length -= (header-&gt;length + 1);
</I>&gt;<i> 	}
</I>&gt;<i> @@ -434,7 +434,7 @@
</I>&gt;<i> 	/* set up for download mode and make sure EP2 is set up to transmit  
</I>&gt;<i> */
</I>&gt;<i> 	usb_err = ep1_generic_commandl(
</I>&gt;<i> 		pHDev, 7,
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		EP1_CMD_DTC_STOP,
</I>&gt;<i> 		EP1_CMD_SET_UPLOAD,
</I>&gt;<i> 		EP1_CMD_SET_DOWNLOAD,
</I>&gt;<i> @@ -455,7 +455,7 @@
</I>&gt;<i>
</I>&gt;<i> 	usb_err = ep1_generic_commandl(
</I>&gt;<i> 		pHDev, 13,
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		EP1_CMD_MEMORY_WRITE,	/* preinitialize poll byte */
</I>&gt;<i> 			DTC_STATUS_POLL_BYTE &gt;&gt; 8,
</I>&gt;<i> 			DTC_STATUS_POLL_BYTE,
</I>&gt;<i> @@ -682,7 +682,7 @@
</I>&gt;<i> 		usb_err = dtc_run_download(pHDev,
</I>&gt;<i> 			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
</I>&gt;<i> 			NULL, 0
</I>&gt;<i> -		);	
</I>&gt;<i> +		);
</I>&gt;<i> 		if(usb_err &lt; 0) {
</I>&gt;<i> 			LOG_ERROR(&quot;dtc_run_download: %s\n&quot;, usb_strerror());
</I>&gt;<i> 			exit(1);
</I>&gt;<i> @@ -691,7 +691,7 @@
</I>&gt;<i> 		usb_err = dtc_run_download(pHDev,
</I>&gt;<i> 			dtc_queue.cmd_buffer, dtc_queue.cmd_index,
</I>&gt;<i> 			reply_buffer, dtc_queue.reply_index
</I>&gt;<i> -		);	
</I>&gt;<i> +		);
</I>&gt;<i> 		if(usb_err &lt; 0) {
</I>&gt;<i> 			LOG_ERROR(&quot;dtc_run_download: %s\n&quot;, usb_strerror());
</I>&gt;<i> 			exit(1);
</I>&gt;<i> @@ -726,7 +726,7 @@
</I>&gt;<i> 						} else {
</I>&gt;<i> 							*tdo_p &amp;=~ tdo_mask;
</I>&gt;<i> 						}
</I>&gt;<i> -						
</I>&gt;<i> +
</I>&gt;<i> 						dtc_mask &gt;&gt;= 1;
</I>&gt;<i> 						if(dtc_mask == 0) {
</I>&gt;<i> 							dtc_p++;
</I>&gt;<i> @@ -772,7 +772,7 @@
</I>&gt;<i> 							tdo_p++;
</I>&gt;<i> 							tdo_mask = 1;
</I>&gt;<i> 						}
</I>&gt;<i> -								
</I>&gt;<i> +
</I>&gt;<i> 					}
</I>&gt;<i> 				}
</I>&gt;<i>
</I>&gt;<i> @@ -825,7 +825,7 @@
</I>&gt;<i> 	bits = 1;
</I>&gt;<i> 	byte = 0;
</I>&gt;<i> 	for(i = tap_state_queue.length; i--;) {
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		byte &lt;&lt;= 1;
</I>&gt;<i> 		if(tap_state_queue.buffer &amp; 1) {
</I>&gt;<i> 			byte |= 1;
</I>&gt;<i> @@ -892,8 +892,8 @@
</I>&gt;<i> static
</I>&gt;<i> void rlink_end_state(enum tap_state state)
</I>&gt;<i> {
</I>&gt;<i> -	if (tap_move_map[state] != -1)
</I>&gt;<i> -		end_state = state;
</I>&gt;<i> +	if (tap_is_state_stable(state))
</I>&gt;<i> +		tap_set_end_state(state);
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
</I>&gt;<i> @@ -906,7 +906,7 @@
</I>&gt;<i> void rlink_state_move(void) {
</I>&gt;<i>
</I>&gt;<i> 	int i=0, tms=0;
</I>&gt;<i> -	u8 tms_scan = TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +	u8 tms_scan = tap_get_tms_path(tap_get_state(),  
</I>&gt;<i> tap_get_end_state());
</I>&gt;<i>
</I>&gt;<i> 	for (i = 0; i &lt; 7; i++)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -914,7 +914,7 @@
</I>&gt;<i> 		tap_state_queue_append(tms);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(tap_get_end_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> static
</I>&gt;<i> @@ -927,28 +927,28 @@
</I>&gt;<i> 	state_count = 0;
</I>&gt;<i> 	while (num_states)
</I>&gt;<i> 	{
</I>&gt;<i> -		if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
</I>&gt;<i> +		if (tap_state_transition(tap_get_state(), FALSE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			tms = 0;
</I>&gt;<i> 		}
</I>&gt;<i> -		else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
</I>&gt;<i> +		else if (tap_state_transition(tap_get_state(), TRUE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			tms = 1;
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(tap_get_state()), tap_state_name(cmd- 
</I>&gt;<i> &gt;path[state_count]));
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		tap_state_queue_append(tms);
</I>&gt;<i>
</I>&gt;<i> -		cur_state = cmd-&gt;path[state_count];
</I>&gt;<i> +		tap_set_state(cmd-&gt;path[state_count]);
</I>&gt;<i> 		state_count++;
</I>&gt;<i> 		num_states--;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	end_state = cur_state;
</I>&gt;<i> +	tap_set_end_state(tap_get_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -957,10 +957,10 @@
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	enum tap_state saved_end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> 	/* only do a state_move when we're not already in RTI */
</I>&gt;<i> -	if (cur_state != TAP_IDLE)
</I>&gt;<i> +	if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> 	{
</I>&gt;<i> 		rlink_end_state(TAP_IDLE);
</I>&gt;<i> 		rlink_state_move();
</I>&gt;<i> @@ -974,7 +974,7 @@
</I>&gt;<i>
</I>&gt;<i> 	/* finish in end_state */
</I>&gt;<i> 	rlink_end_state(saved_end_state);
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 		rlink_state_move();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -997,7 +997,7 @@
</I>&gt;<i>
</I>&gt;<i> 	usb_err = ep1_generic_commandl(
</I>&gt;<i> 		pHDev, 6,
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		EP1_CMD_MEMORY_WRITE,
</I>&gt;<i> 			ST7_PADR &gt;&gt; 8,
</I>&gt;<i> 			ST7_PADR,
</I>&gt;<i> @@ -1051,11 +1051,11 @@
</I>&gt;<i>
</I>&gt;<i> 	/* Move to the proper state before starting to shift TDI/TDO. */
</I>&gt;<i> 	if (!(
</I>&gt;<i> -		(!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT))
</I>&gt;<i> +		(!ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT))
</I>&gt;<i> 		||
</I>&gt;<i> -		(ir_scan &amp;&amp; (cur_state == TAP_IRSHIFT))
</I>&gt;<i> +		(ir_scan &amp;&amp; (tap_get_state() == TAP_IRSHIFT))
</I>&gt;<i> 	)) {
</I>&gt;<i> -		saved_end_state = end_state;
</I>&gt;<i> +		saved_end_state = tap_get_end_state();
</I>&gt;<i> 		rlink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
</I>&gt;<i> 		rlink_state_move();
</I>&gt;<i> 		rlink_end_state(saved_end_state);
</I>&gt;<i> @@ -1102,7 +1102,7 @@
</I>&gt;<i>
</I>&gt;<i> 		x = 0;
</I>&gt;<i> 		dtc_mask = 1 &lt;&lt; (extra_bits - 1);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 		while(extra_bits--) {
</I>&gt;<i> 			if(*tdi_p &amp; tdi_mask) {
</I>&gt;<i> 				x |= dtc_mask;
</I>&gt;<i> @@ -1170,7 +1170,7 @@
</I>&gt;<i> 				LOG_ERROR(&quot;enqueuing DTC reply entry: %s\n&quot;, strerror(errno));
</I>&gt;<i> 				exit(1);
</I>&gt;<i> 			}
</I>&gt;<i> -			
</I>&gt;<i> +
</I>&gt;<i> 			tdi_bit_offset += chunk_bits;
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> @@ -1193,12 +1193,12 @@
</I>&gt;<i> 		if(type != SCAN_IN) {
</I>&gt;<i> 			x = 0;
</I>&gt;<i> 			dtc_mask = 1 &lt;&lt; (8 - 1);
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 			while(chunk_bits--) {
</I>&gt;<i> 				if(*tdi_p &amp; tdi_mask) {
</I>&gt;<i> 					x |= dtc_mask;
</I>&gt;<i> 				}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 				dtc_mask &gt;&gt;= 1;
</I>&gt;<i> 				if(dtc_mask == 0) {
</I>&gt;<i> 					dtc_queue.cmd_buffer[dtc_queue.cmd_index++] = x;
</I>&gt;<i> @@ -1206,7 +1206,7 @@
</I>&gt;<i> 					x = 0;
</I>&gt;<i> 					dtc_mask = 1 &lt;&lt; (8 - 1);
</I>&gt;<i> 				}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 				tdi_mask &lt;&lt;= 1;
</I>&gt;<i> 				if(tdi_mask == 0) {
</I>&gt;<i> 					tdi_p++;
</I>&gt;<i> @@ -1235,7 +1235,7 @@
</I>&gt;<i> 			LOG_ERROR(&quot;enqueuing DTC reply entry: %s\n&quot;, strerror(errno));
</I>&gt;<i> 			exit(1);
</I>&gt;<i> 		}
</I>&gt;<i> -			
</I>&gt;<i> +
</I>&gt;<i> 		tdi_bit_offset += extra_bits;
</I>&gt;<i>
</I>&gt;<i> 		if(type == SCAN_IN) {
</I>&gt;<i> @@ -1248,14 +1248,14 @@
</I>&gt;<i>
</I>&gt;<i> 			x = 0;
</I>&gt;<i> 			dtc_mask = 1 &lt;&lt; (8 - 1);
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 			while(extra_bits--) {
</I>&gt;<i> 				if(*tdi_p &amp; tdi_mask) {
</I>&gt;<i> 					x |= dtc_mask;
</I>&gt;<i> 				}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 				dtc_mask &gt;&gt;= 1;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 				tdi_mask &lt;&lt;= 1;
</I>&gt;<i> 				if(tdi_mask == 0) {
</I>&gt;<i> 					tdi_p++;
</I>&gt;<i> @@ -1293,8 +1293,8 @@
</I>&gt;<i> 				LOG_ERROR(&quot;enqueuing DTC reply entry: %s\n&quot;, strerror(errno));
</I>&gt;<i> 				exit(1);
</I>&gt;<i> 			}
</I>&gt;<i> -			
</I>&gt;<i> -			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
</I>&gt;<i> +
</I>&gt;<i> +			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
</I>&gt;<i> 				DTC_CMD_SHIFT_TMS_TDI_BIT_PAIR(1, (*tdi_p &amp; tdi_mask), 1);
</I>&gt;<i>
</I>&gt;<i> 			dtc_queue.reply_index++;
</I>&gt;<i> @@ -1303,8 +1303,8 @@
</I>&gt;<i>
</I>&gt;<i> 	/* Move to pause state */
</I>&gt;<i> 	tap_state_queue_append(0);
</I>&gt;<i> -	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
</I>&gt;<i> -	if (cur_state != end_state) rlink_state_move();
</I>&gt;<i> +	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state()) rlink_state_move();
</I>&gt;<i>
</I>&gt;<i> 	return(0);
</I>&gt;<i> }
</I>&gt;<i> @@ -1363,7 +1363,7 @@
</I>&gt;<i> #endif
</I>&gt;<i> 				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp;  
</I>&gt;<i> (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
</I>&gt;<i> 				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> +					tap_set_state(TAP_RESET);
</I>&gt;<i> 				}
</I>&gt;<i> 				rlink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i> 				break;
</I>&gt;<i> @@ -1451,7 +1451,7 @@
</I>&gt;<i> 				LOG_ERROR(&quot;An error occurred while trying to load DTC code for  
</I>&gt;<i> speed \&quot;%d\&quot;.\n&quot;, speed);
</I>&gt;<i> 				exit(1);
</I>&gt;<i> 			}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 			if(dtc_start_download() &lt; 0) {
</I>&gt;<i> 				LOG_ERROR(&quot;%s, %d: starting DTC: %s&quot;,
</I>&gt;<i> 					__FILE__, __LINE__,
</I>&gt;<i> @@ -1605,7 +1605,7 @@
</I>&gt;<i>
</I>&gt;<i> 						/* usb_set_configuration required under win32 */
</I>&gt;<i> 						usb_set_configuration(pHDev, dev- 
</I>&gt;<i> &gt;config[0].bConfigurationValue);
</I>&gt;<i> -						
</I>&gt;<i> +
</I>&gt;<i> 						retries = 3;
</I>&gt;<i> 						do
</I>&gt;<i> 						{
</I>&gt;<i> Index: src/jtag/bitq.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/bitq.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/bitq.c	(working copy)
</I>&gt;<i> @@ -1,22 +1,22 @@
</I>&gt;<i> / 
</I>&gt;<i> ***************************************************************************
</I>&gt;<i> - *   Copyright (C) 2007 by Pavel  
</I>&gt;<i> Chromy                                    *
</I>&gt;<i> - *    
</I>&gt;<i> chromy 
</I>&gt;<i> @asix.cz                                                        *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   This program is free software; you can redistribute it and/or  
</I>&gt;<i> modify  *
</I>&gt;<i> - *   it under the terms of the GNU General Public License as  
</I>&gt;<i> published by  *
</I>&gt;<i> - *   the Free Software Foundation; either version 2 of the License,  
</I>&gt;<i> or     *
</I>&gt;<i> - *   (at your option) any later  
</I>&gt;<i> version.                                   *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   This program is distributed in the hope that it will be  
</I>&gt;<i> useful,       *
</I>&gt;<i> - *   but WITHOUT ANY WARRANTY; without even the implied warranty  
</I>&gt;<i> of        *
</I>&gt;<i> - *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See  
</I>&gt;<i> the         *
</I>&gt;<i> - *   GNU General Public License for more  
</I>&gt;<i> details.                          *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   You should have received a copy of the GNU General Public  
</I>&gt;<i> License     *
</I>&gt;<i> - *   along with this program; if not, write to  
</I>&gt;<i> the                         *
</I>&gt;<i> - *   Free Software Foundation,  
</I>&gt;<i> Inc.,                                       *
</I>&gt;<i> - *   59 Temple Place - Suite 330, Boston, MA  02111-1307,  
</I>&gt;<i> USA.             *
</I>&gt;<i> -  
</I>&gt;<i> ***************************************************************************/
</I>&gt;<i> +*   Copyright (C) 2007 by Pavel  
</I>&gt;<i> Chromy                                    *
</I>&gt;<i> +*    
</I>&gt;<i> chromy 
</I>&gt;<i> @asix.cz                                                        *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   This program is free software; you can redistribute it and/or  
</I>&gt;<i> modify  *
</I>&gt;<i> +*   it under the terms of the GNU General Public License as  
</I>&gt;<i> published by  *
</I>&gt;<i> +*   the Free Software Foundation; either version 2 of the License,  
</I>&gt;<i> or     *
</I>&gt;<i> +*   (at your option) any later  
</I>&gt;<i> version.                                   *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   This program is distributed in the hope that it will be  
</I>&gt;<i> useful,       *
</I>&gt;<i> +*   but WITHOUT ANY WARRANTY; without even the implied warranty  
</I>&gt;<i> of        *
</I>&gt;<i> +*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See  
</I>&gt;<i> the         *
</I>&gt;<i> +*   GNU General Public License for more  
</I>&gt;<i> details.                          *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   You should have received a copy of the GNU General Public  
</I>&gt;<i> License     *
</I>&gt;<i> +*   along with this program; if not, write to  
</I>&gt;<i> the                         *
</I>&gt;<i> +*   Free Software Foundation,  
</I>&gt;<i> Inc.,                                       *
</I>&gt;<i> +*   59 Temple Place - Suite 330, Boston, MA  02111-1307,  
</I>&gt;<i> USA.             *
</I>&gt;<i> + 
</I>&gt;<i> ***************************************************************************/
</I>&gt;<i> #ifdef HAVE_CONFIG_H
</I>&gt;<i> #include &quot;config.h&quot;
</I>&gt;<i> #endif
</I>&gt;<i> @@ -34,12 +34,12 @@
</I>&gt;<i> #include &lt;stdlib.h&gt;
</I>&gt;<i> #include &lt;unistd.h&gt;
</I>&gt;<i>
</I>&gt;<i> -bitq_interface_t *bitq_interface; /* low level bit queue interface */
</I>&gt;<i> +bitq_interface_t* bitq_interface;       /* low level bit queue  
</I>&gt;<i> interface */
</I>&gt;<i>
</I>&gt;<i> -bitq_state_t bitq_in_state; /* state of input queue */
</I>&gt;<i> +bitq_state_t      bitq_in_state;        /* state of input queue */
</I>&gt;<i>
</I>&gt;<i> -u8 *bitq_in_buffer; /* buffer dynamically reallocated as needed */
</I>&gt;<i> -unsigned long bitq_in_bufsize=32; /* min. buffer size */
</I>&gt;<i> +u8* bitq_in_buffer;                     /* buffer dynamically  
</I>&gt;<i> reallocated as needed */
</I>&gt;<i> +unsigned long     bitq_in_bufsize = 32; /* min. buffer size */
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i>  * input queue processing does not use jtag_read_buffer() to avoid  
</I>&gt;<i> unnecessary overhead
</I>&gt;<i> @@ -49,284 +49,338 @@
</I>&gt;<i> void bitq_in_proc(void)
</I>&gt;<i> {
</I>&gt;<i> 	/* static information preserved between calls to increase  
</I>&gt;<i> performance */
</I>&gt;<i> -	static u8 *in_buff; /* pointer to buffer for scanned data */
</I>&gt;<i> -	static int in_idx; /* index of byte being scanned */
</I>&gt;<i> -	static u8 in_mask; /* mask of next bit to be scanned */
</I>&gt;<i> +	static u8*    in_buff;  /* pointer to buffer for scanned data */
</I>&gt;<i> +	static int    in_idx;   /* index of byte being scanned */
</I>&gt;<i> +	static u8     in_mask;  /* mask of next bit to be scanned */
</I>&gt;<i>
</I>&gt;<i> -	scan_field_t *field;
</I>&gt;<i> -	int tdo;
</I>&gt;<i> +	scan_field_t* field;
</I>&gt;<i> +	int           tdo;
</I>&gt;<i>
</I>&gt;<i> 	/* loop through the queue */
</I>&gt;<i> -	while (bitq_in_state.cmd) {
</I>&gt;<i> +	while (bitq_in_state.cmd)
</I>&gt;<i> +	{
</I>&gt;<i> 		/* only JTAG_SCAN command may return data */
</I>&gt;<i> -		if (bitq_in_state.cmd-&gt;type==JTAG_SCAN) {
</I>&gt;<i> +		if (bitq_in_state.cmd-&gt;type==JTAG_SCAN)
</I>&gt;<i> +		{
</I>&gt;<i> 			/* loop through the fields */
</I>&gt;<i> -			while (bitq_in_state.field_idx&lt;bitq_in_state.cmd-&gt;cmd.scan- 
</I>&gt;<i> &gt;num_fields) {
</I>&gt;<i> -
</I>&gt;<i> -				field=&amp;bitq_in_state.cmd-&gt;cmd.scan- 
</I>&gt;<i> &gt;fields[bitq_in_state.field_idx];
</I>&gt;<i> -				if ( field-&gt;in_value || field-&gt;in_handler) {
</I>&gt;<i> -
</I>&gt;<i> -					if (bitq_in_state.bit_pos==0) {
</I>&gt;<i> +			while (bitq_in_state.field_idx&lt;bitq_in_state.cmd-&gt;cmd.scan- 
</I>&gt;<i> &gt;num_fields)
</I>&gt;<i> +			{
</I>&gt;<i> +				field = &amp;bitq_in_state.cmd-&gt;cmd.scan- 
</I>&gt;<i> &gt;fields[bitq_in_state.field_idx];
</I>&gt;<i> +				if (field-&gt;in_value || field-&gt;in_handler)
</I>&gt;<i> +				{
</I>&gt;<i> +					if (bitq_in_state.bit_pos==0)
</I>&gt;<i> +					{
</I>&gt;<i> 						/* initialize field scanning */
</I>&gt;<i> -						in_mask=0x01;
</I>&gt;<i> -						in_idx=0;
</I>&gt;<i> -						if (field-&gt;in_value) in_buff=field-&gt;in_value;
</I>&gt;<i> -						else {
</I>&gt;<i> +						in_mask = 0x01;
</I>&gt;<i> +						in_idx  = 0;
</I>&gt;<i> +						if (field-&gt;in_value)
</I>&gt;<i> +							in_buff = field-&gt;in_value;
</I>&gt;<i> +						else
</I>&gt;<i> +						{
</I>&gt;<i> 							/* buffer reallocation needed? */
</I>&gt;<i> -							if (field-&gt;num_bits&gt;bitq_in_bufsize*8) {
</I>&gt;<i> +							if (field-&gt;num_bits&gt;bitq_in_bufsize * 8)
</I>&gt;<i> +							{
</I>&gt;<i> 								/* buffer previously allocated? */
</I>&gt;<i> -								if (bitq_in_buffer!=NULL) {
</I>&gt;<i> +								if (bitq_in_buffer!=NULL)
</I>&gt;<i> +								{
</I>&gt;<i> 									/* free it */
</I>&gt;<i> 									free(bitq_in_buffer);
</I>&gt;<i> -									bitq_in_buffer=NULL;
</I>&gt;<i> +									bitq_in_buffer = NULL;
</I>&gt;<i> 								}
</I>&gt;<i> 								/* double the buffer size until it fits */
</I>&gt;<i> -								while (field-&gt;num_bits&gt;bitq_in_bufsize*8) bitq_in_bufsize*=2;
</I>&gt;<i> +								while (field-&gt;num_bits&gt;bitq_in_bufsize * 8)
</I>&gt;<i> +									bitq_in_bufsize *= 2;
</I>&gt;<i> 							}
</I>&gt;<i> 							/* if necessary, allocate buffer and check for malloc error */
</I>&gt;<i> -							if (bitq_in_buffer==NULL &amp;&amp;  
</I>&gt;<i> (bitq_in_buffer=malloc(bitq_in_bufsize))==NULL) {
</I>&gt;<i> +							if (bitq_in_buffer==NULL &amp;&amp; ( bitq_in_buffer =  
</I>&gt;<i> malloc(bitq_in_bufsize) )==NULL)
</I>&gt;<i> +							{
</I>&gt;<i> 								LOG_ERROR(&quot;malloc error&quot;);
</I>&gt;<i> 								exit(-1);
</I>&gt;<i> 							}
</I>&gt;<i> -							in_buff=(void *)bitq_in_buffer;
</I>&gt;<i> +							in_buff = (void*) bitq_in_buffer;
</I>&gt;<i> 						}
</I>&gt;<i> 					}
</I>&gt;<i>
</I>&gt;<i> 					/* field scanning */
</I>&gt;<i> -					while (bitq_in_state.bit_pos&lt;field-&gt;num_bits) {
</I>&gt;<i> -						if ((tdo=bitq_interface-&gt;in())&lt;0) {
</I>&gt;<i> +					while (bitq_in_state.bit_pos&lt;field-&gt;num_bits)
</I>&gt;<i> +					{
</I>&gt;<i> +						if ( ( tdo = bitq_interface-&gt;in() )&lt;0 )
</I>&gt;<i> +						{
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> 							LOG_DEBUG(&quot;bitq in EOF&quot;);
</I>&gt;<i> #endif
</I>&gt;<i> 							return;
</I>&gt;<i> 						}
</I>&gt;<i> -						if (in_mask==0x01) in_buff[in_idx]=0;
</I>&gt;<i> -						if (tdo) in_buff[in_idx]|=in_mask;
</I>&gt;<i> -						if (in_mask==0x80) {
</I>&gt;<i> -							in_mask=0x01;
</I>&gt;<i> +						if (in_mask==0x01)
</I>&gt;<i> +							in_buff[in_idx] = 0;
</I>&gt;<i> +						if (tdo)
</I>&gt;<i> +							in_buff[in_idx] |= in_mask;
</I>&gt;<i> +						if (in_mask==0x80)
</I>&gt;<i> +						{
</I>&gt;<i> +							in_mask = 0x01;
</I>&gt;<i> 							in_idx++;
</I>&gt;<i> 						}
</I>&gt;<i> -						else in_mask&lt;&lt;=1;
</I>&gt;<i> +						else
</I>&gt;<i> +							in_mask &lt;&lt;= 1;
</I>&gt;<i> 						bitq_in_state.bit_pos++;
</I>&gt;<i> 					}
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -					if (field-&gt;in_handler &amp;&amp; bitq_in_state.status==ERROR_OK) {
</I>&gt;<i> -						bitq_in_state.status=(*field-&gt;in_handler)(in_buff, field- 
</I>&gt;<i> &gt;in_handler_priv, field);
</I>&gt;<i> +					if (field-&gt;in_handler &amp;&amp; bitq_in_state.status==ERROR_OK)
</I>&gt;<i> +					{
</I>&gt;<i> +						bitq_in_state.status = (*field-&gt;in_handler)(in_buff, field- 
</I>&gt;<i> &gt;in_handler_priv, field);
</I>&gt;<i> 					}
</I>&gt;<i> -
</I>&gt;<i> 				}
</I>&gt;<i>
</I>&gt;<i> -				bitq_in_state.field_idx++; /* advance to next field */
</I>&gt;<i> -				bitq_in_state.bit_pos=0; /* start next field from the first bit  
</I>&gt;<i> */
</I>&gt;<i> +				bitq_in_state.field_idx++;  /* advance to next field */
</I>&gt;<i> +				bitq_in_state.bit_pos = 0;  /* start next field from the first  
</I>&gt;<i> bit */
</I>&gt;<i> 			}
</I>&gt;<i> -
</I>&gt;<i> 		}
</I>&gt;<i> -		bitq_in_state.cmd=bitq_in_state.cmd-&gt;next; /* advance to next  
</I>&gt;<i> command */
</I>&gt;<i> -		bitq_in_state.field_idx=0; /* preselect first field */
</I>&gt;<i> +		bitq_in_state.cmd = bitq_in_state.cmd-&gt;next;    /* advance to  
</I>&gt;<i> next command */
</I>&gt;<i> +		bitq_in_state.field_idx = 0;                    /* preselect  
</I>&gt;<i> first field */
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void bitq_io(int tms, int tdi, int tdo_req)
</I>&gt;<i> {
</I>&gt;<i> 	bitq_interface-&gt;out(tms, tdi, tdo_req);
</I>&gt;<i> 	/* check and process the input queue */
</I>&gt;<i> -	if (bitq_interface-&gt;in_rdy()) bitq_in_proc();
</I>&gt;<i> +	if ( bitq_interface-&gt;in_rdy() )
</I>&gt;<i> +		bitq_in_proc();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void bitq_end_state(enum tap_state state)
</I>&gt;<i> {
</I>&gt;<i> -	if (state==-1) return;
</I>&gt;<i> -	if (tap_move_map[state]==-1) {
</I>&gt;<i> +	if (state==-1)
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	if (!tap_is_state_stable(state))
</I>&gt;<i> +	{
</I>&gt;<i> 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> 	}
</I>&gt;<i> -	end_state = state;
</I>&gt;<i> +	tap_set_end_state(state);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void bitq_state_move(enum tap_state new_state)
</I>&gt;<i> {
</I>&gt;<i> -	int i=0;
</I>&gt;<i> -	u8 tms_scan;
</I>&gt;<i> +	int i = 0;
</I>&gt;<i> +	u8  tms_scan;
</I>&gt;<i>
</I>&gt;<i> -	if (tap_move_map[cur_state]==-1 || tap_move_map[new_state]==-1) {
</I>&gt;<i> +	if (!tap_is_state_stable(tap_get_state()) || ! 
</I>&gt;<i> tap_is_state_stable(new_state))
</I>&gt;<i> +	{
</I>&gt;<i> 		LOG_ERROR(&quot;TAP move from or to unstable state&quot;);
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	tms_scan=TAP_MOVE(cur_state, new_state);
</I>&gt;<i> +	tms_scan = tap_get_tms_path(tap_get_state(), new_state);
</I>&gt;<i>
</I>&gt;<i> -	for (i=0; i&lt;7; i++) {
</I>&gt;<i> -		bitq_io(tms_scan&amp;1, 0, 0);
</I>&gt;<i> -		tms_scan&gt;&gt;=1;
</I>&gt;<i> +	for (i = 0; i&lt;7; i++)
</I>&gt;<i> +	{
</I>&gt;<i> +		bitq_io(tms_scan &amp; 1, 0, 0);
</I>&gt;<i> +		tms_scan &gt;&gt;= 1;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	cur_state = new_state;
</I>&gt;<i> +	tap_set_state(new_state);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void bitq_path_move(pathmove_command_t *cmd)
</I>&gt;<i> +
</I>&gt;<i> +void bitq_path_move(pathmove_command_t* cmd)
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> -	for (i=0; i&lt;=cmd-&gt;num_states; i++) {
</I>&gt;<i> -		if (tap_transitions[cur_state].low == cmd-&gt;path[i])
</I>&gt;<i> +	for (i = 0; i&lt;=cmd-&gt;num_states; i++)
</I>&gt;<i> +	{
</I>&gt;<i> +		if (tap_state_transition(tap_get_state(), FALSE) == cmd-&gt;path[i])
</I>&gt;<i> 			bitq_io(0, 0, 0);
</I>&gt;<i> -		else if (tap_transitions[cur_state].high == cmd-&gt;path[i])
</I>&gt;<i> +		else if (tap_state_transition(tap_get_state(), TRUE) == cmd- 
</I>&gt;<i> &gt;path[i])
</I>&gt;<i> 			bitq_io(1, 0, 0);
</I>&gt;<i> -		else {
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[i]));
</I>&gt;<i> +		else
</I>&gt;<i> +		{
</I>&gt;<i> +			LOG_ERROR( &quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(
</I>&gt;<i> +							 tap_get_state() ), tap_state_name(cmd-&gt;path[i]) );
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> -		cur_state = cmd-&gt;path[i];
</I>&gt;<i> +		tap_set_state(cmd-&gt;path[i]);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	end_state = cur_state;
</I>&gt;<i> +	tap_set_end_state( tap_get_state() );
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void bitq_runtest(int num_cycles)
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> 	/* only do a state_move when we're not already in IDLE */
</I>&gt;<i> -	if (cur_state != TAP_IDLE) bitq_state_move(TAP_IDLE);
</I>&gt;<i> +	if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> +		bitq_state_move(TAP_IDLE);
</I>&gt;<i>
</I>&gt;<i> 	/* execute num_cycles */
</I>&gt;<i> 	for (i = 0; i &lt; num_cycles; i++)
</I>&gt;<i> 		bitq_io(0, 0, 0);
</I>&gt;<i>
</I>&gt;<i> 	/* finish in end_state */
</I>&gt;<i> -	if (cur_state != end_state) bitq_state_move(end_state);
</I>&gt;<i> +	if ( tap_get_state() != tap_get_end_state() )
</I>&gt;<i> +		bitq_state_move( tap_get_end_state() );
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void bitq_scan_field(scan_field_t *field, int pause)
</I>&gt;<i> +
</I>&gt;<i> +void bitq_scan_field(scan_field_t* field, int pause)
</I>&gt;<i> {
</I>&gt;<i> 	int bit_cnt;
</I>&gt;<i> 	int tdo_req;
</I>&gt;<i>
</I>&gt;<i> -	u8 *out_ptr;
</I>&gt;<i> -	u8 out_mask;
</I>&gt;<i> +	u8* out_ptr;
</I>&gt;<i> +	u8  out_mask;
</I>&gt;<i>
</I>&gt;<i> -	if ( field-&gt;in_value || field-&gt;in_handler) tdo_req=1;
</I>&gt;<i> -	else tdo_req=0;
</I>&gt;<i> +	if (field-&gt;in_value || field-&gt;in_handler)
</I>&gt;<i> +		tdo_req = 1;
</I>&gt;<i> +	else
</I>&gt;<i> +		tdo_req = 0;
</I>&gt;<i>
</I>&gt;<i> -	if (field-&gt;out_value==NULL) {
</I>&gt;<i> +	if (field-&gt;out_value==NULL)
</I>&gt;<i> +	{
</I>&gt;<i> 		/* just send zeros and request data from TDO */
</I>&gt;<i> -		for (bit_cnt=field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
</I>&gt;<i> +		for (bit_cnt = field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
</I>&gt;<i> 			bitq_io(0, 0, tdo_req);
</I>&gt;<i> +
</I>&gt;<i> 		bitq_io(pause, 0, tdo_req);
</I>&gt;<i> 	}
</I>&gt;<i> -	else {
</I>&gt;<i> +	else
</I>&gt;<i> +	{
</I>&gt;<i> 		/* send data, and optionally request TDO */
</I>&gt;<i> -		out_mask=0x01;
</I>&gt;<i> -		out_ptr=field-&gt;out_value;
</I>&gt;<i> -		for (bit_cnt=field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--) {
</I>&gt;<i> -			bitq_io(0, ((*out_ptr)&amp;out_mask)!=0, tdo_req);
</I>&gt;<i> -			if (out_mask==0x80) {
</I>&gt;<i> -				out_mask=0x01;
</I>&gt;<i> +		out_mask = 0x01;
</I>&gt;<i> +		out_ptr  = field-&gt;out_value;
</I>&gt;<i> +		for (bit_cnt = field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
</I>&gt;<i> +		{
</I>&gt;<i> +			bitq_io(0, ( (*out_ptr) &amp; out_mask )!=0, tdo_req);
</I>&gt;<i> +			if (out_mask==0x80)
</I>&gt;<i> +			{
</I>&gt;<i> +				out_mask = 0x01;
</I>&gt;<i> 				out_ptr++;
</I>&gt;<i> 			}
</I>&gt;<i> -			else out_mask&lt;&lt;=1;
</I>&gt;<i> +			else
</I>&gt;<i> +				out_mask &lt;&lt;= 1;
</I>&gt;<i> 		}
</I>&gt;<i> -		bitq_io(pause, ((*out_ptr)&amp;out_mask)!=0, tdo_req);
</I>&gt;<i> +
</I>&gt;<i> +		bitq_io(pause, ( (*out_ptr) &amp; out_mask )!=0, tdo_req);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if (pause) {
</I>&gt;<i> -		bitq_io(0,0,0);
</I>&gt;<i> -		if (cur_state==TAP_IRSHIFT) cur_state=TAP_IRPAUSE;
</I>&gt;<i> -		else if (cur_state==TAP_DRSHIFT) cur_state=TAP_DRPAUSE;
</I>&gt;<i> +	if (pause)
</I>&gt;<i> +	{
</I>&gt;<i> +		bitq_io(0, 0, 0);
</I>&gt;<i> +		if (tap_get_state()==TAP_IRSHIFT)
</I>&gt;<i> +			tap_set_state(TAP_IRPAUSE);
</I>&gt;<i> +		else if (tap_get_state()==TAP_DRSHIFT)
</I>&gt;<i> +			tap_set_state(TAP_DRPAUSE);
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void bitq_scan(scan_command_t *cmd)
</I>&gt;<i> +
</I>&gt;<i> +void bitq_scan(scan_command_t* cmd)
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> -	if (cmd-&gt;ir_scan) bitq_state_move(TAP_IRSHIFT);
</I>&gt;<i> -	else bitq_state_move(TAP_DRSHIFT);
</I>&gt;<i> +	if (cmd-&gt;ir_scan)
</I>&gt;<i> +		bitq_state_move(TAP_IRSHIFT);
</I>&gt;<i> +	else
</I>&gt;<i> +		bitq_state_move(TAP_DRSHIFT);
</I>&gt;<i>
</I>&gt;<i> -	for (i=0; i &lt; cmd-&gt;num_fields-1; i++)
</I>&gt;<i> +	for (i = 0; i &lt; cmd-&gt;num_fields - 1; i++)
</I>&gt;<i> 		bitq_scan_field(&amp;cmd-&gt;fields[i], 0);
</I>&gt;<i> +
</I>&gt;<i> 	bitq_scan_field(&amp;cmd-&gt;fields[i], 1);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int bitq_execute_queue(void)
</I>&gt;<i> {
</I>&gt;<i> -	jtag_command_t *cmd = jtag_command_queue; /* currently processed  
</I>&gt;<i> command */
</I>&gt;<i> +	jtag_command_t* cmd = jtag_command_queue; /* currently processed  
</I>&gt;<i> command */
</I>&gt;<i>
</I>&gt;<i> 	bitq_in_state.cmd = jtag_command_queue;
</I>&gt;<i> 	bitq_in_state.field_idx = 0;
</I>&gt;<i> -	bitq_in_state.bit_pos = 0;
</I>&gt;<i> -	bitq_in_state.status = ERROR_OK;
</I>&gt;<i> +	bitq_in_state.bit_pos   = 0;
</I>&gt;<i> +	bitq_in_state.status    = ERROR_OK;
</I>&gt;<i>
</I>&gt;<i> -	while (cmd) {
</I>&gt;<i> -
</I>&gt;<i> -		switch (cmd-&gt;type) {
</I>&gt;<i> -
</I>&gt;<i> -			case JTAG_END_STATE:
</I>&gt;<i> +	while (cmd)
</I>&gt;<i> +	{
</I>&gt;<i> +		switch (cmd-&gt;type)
</I>&gt;<i> +		{
</I>&gt;<i> +		case JTAG_END_STATE:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;end_state: %i&quot;, cmd-&gt;cmd.end_state-&gt;end_state);
</I>&gt;<i> +			LOG_DEBUG(&quot;end_state: %i&quot;, cmd-&gt;cmd.end_state-&gt;end_state);
</I>&gt;<i> #endif
</I>&gt;<i> -				bitq_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
</I>&gt;<i> -				break;
</I>&gt;<i> +			bitq_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_RESET:
</I>&gt;<i> +		case JTAG_RESET:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd- 
</I>&gt;<i> &gt;cmd.reset-&gt;srst);
</I>&gt;<i> +			LOG_DEBUG(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd- 
</I>&gt;<i> &gt;cmd.reset-&gt;srst);
</I>&gt;<i> #endif
</I>&gt;<i> -				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp;  
</I>&gt;<i> (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
</I>&gt;<i> -				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> -				}
</I>&gt;<i> -				bitq_interface-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset- 
</I>&gt;<i> &gt;srst);
</I>&gt;<i> -				if (bitq_interface-&gt;in_rdy()) bitq_in_proc();
</I>&gt;<i> -				break;
</I>&gt;<i> +			if ( (cmd-&gt;cmd.reset-&gt;trst == 1) || ( cmd-&gt;cmd.reset-&gt;srst &amp;&amp;  
</I>&gt;<i> (jtag_reset_config &amp; RESET_SRST_PULLS_TRST) ) )
</I>&gt;<i> +			{
</I>&gt;<i> +				tap_set_state(TAP_RESET);
</I>&gt;<i> +			}
</I>&gt;<i> +			bitq_interface-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i> +			if ( bitq_interface-&gt;in_rdy() )
</I>&gt;<i> +				bitq_in_proc();
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_RUNTEST:
</I>&gt;<i> +		case JTAG_RUNTEST:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;runtest %i cycles, end in %i&quot;, cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;num_cycles, cmd-&gt;cmd.runtest-&gt;end_state);
</I>&gt;<i> +			LOG_DEBUG(&quot;runtest %i cycles, end in %i&quot;, cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;num_cycles, cmd-&gt;cmd.runtest-&gt;end_state);
</I>&gt;<i> #endif
</I>&gt;<i> -				bitq_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
</I>&gt;<i> -				bitq_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
</I>&gt;<i> -				break;
</I>&gt;<i> +			bitq_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
</I>&gt;<i> +			bitq_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_STATEMOVE:
</I>&gt;<i> +		case JTAG_STATEMOVE:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;statemove end in %i&quot;, cmd-&gt;cmd.statemove-&gt;end_state);
</I>&gt;<i> +			LOG_DEBUG(&quot;statemove end in %i&quot;, cmd-&gt;cmd.statemove-&gt;end_state);
</I>&gt;<i> #endif
</I>&gt;<i> -				bitq_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
</I>&gt;<i> -				bitq_state_move(end_state); /* uncoditional TAP move */
</I>&gt;<i> -				break;
</I>&gt;<i> +			bitq_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
</I>&gt;<i> +			bitq_state_move( tap_get_end_state() );   /* uncoditional TAP  
</I>&gt;<i> move */
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_PATHMOVE:
</I>&gt;<i> +		case JTAG_PATHMOVE:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;pathmove: %i states, end in %i&quot;, cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states, cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states -  
</I>&gt;<i> 1]);
</I>&gt;<i> +			LOG_DEBUG(&quot;pathmove: %i states, end in %i&quot;, cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states,
</I>&gt;<i> +					cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]);
</I>&gt;<i> #endif
</I>&gt;<i> -				bitq_path_move(cmd-&gt;cmd.pathmove);
</I>&gt;<i> -				break;
</I>&gt;<i> +			bitq_path_move(cmd-&gt;cmd.pathmove);
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_SCAN:
</I>&gt;<i> +		case JTAG_SCAN:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;scan end in %i&quot;, cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> -				if (cmd-&gt;cmd.scan-&gt;ir_scan) LOG_DEBUG(&quot;scan ir&quot;);
</I>&gt;<i> -				else LOG_DEBUG(&quot;scan dr&quot;);
</I>&gt;<i> +			LOG_DEBUG(&quot;scan end in %i&quot;, cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> +			if (cmd-&gt;cmd.scan-&gt;ir_scan)
</I>&gt;<i> +				LOG_DEBUG(&quot;scan ir&quot;);
</I>&gt;<i> +			else
</I>&gt;<i> +				LOG_DEBUG(&quot;scan dr&quot;);
</I>&gt;<i> #endif
</I>&gt;<i> -				bitq_end_state(cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> -				bitq_scan(cmd-&gt;cmd.scan);
</I>&gt;<i> -				if (cur_state != end_state) bitq_state_move(end_state);
</I>&gt;<i> -				break;
</I>&gt;<i> +			bitq_end_state(cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> +			bitq_scan(cmd-&gt;cmd.scan);
</I>&gt;<i> +			if ( tap_get_state() != tap_get_end_state() )
</I>&gt;<i> +				bitq_state_move( tap_get_end_state() );
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_SLEEP:
</I>&gt;<i> +		case JTAG_SLEEP:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
</I>&gt;<i> +			LOG_DEBUG(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
</I>&gt;<i> #endif
</I>&gt;<i> -				bitq_interface-&gt;sleep(cmd-&gt;cmd.sleep-&gt;us);
</I>&gt;<i> -				if (bitq_interface-&gt;in_rdy()) bitq_in_proc();
</I>&gt;<i> -				break;
</I>&gt;<i> +			bitq_interface-&gt;sleep(cmd-&gt;cmd.sleep-&gt;us);
</I>&gt;<i> +			if ( bitq_interface-&gt;in_rdy() )
</I>&gt;<i> +				bitq_in_proc();
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			default:
</I>&gt;<i> -				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
</I>&gt;<i> -				exit(-1);
</I>&gt;<i> +		default:
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
</I>&gt;<i> +			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		cmd = cmd-&gt;next;
</I>&gt;<i> @@ -335,11 +389,13 @@
</I>&gt;<i> 	bitq_interface-&gt;flush();
</I>&gt;<i> 	bitq_in_proc();
</I>&gt;<i>
</I>&gt;<i> -	if (bitq_in_state.cmd) {
</I>&gt;<i> +	if (bitq_in_state.cmd)
</I>&gt;<i> +	{
</I>&gt;<i> 		LOG_ERROR(&quot;missing data from bitq interface&quot;);
</I>&gt;<i> 		return ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i> -	if (bitq_interface-&gt;in()&gt;=0) {
</I>&gt;<i> +	if (bitq_interface-&gt;in()&gt;=0)
</I>&gt;<i> +	{
</I>&gt;<i> 		LOG_ERROR(&quot;extra data from bitq interface&quot;);
</I>&gt;<i> 		return ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i> @@ -347,11 +403,12 @@
</I>&gt;<i> 	return bitq_in_state.status;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void bitq_cleanup(void)
</I>&gt;<i> {
</I>&gt;<i> 	if (bitq_in_buffer!=NULL)
</I>&gt;<i> 	{
</I>&gt;<i> 		free(bitq_in_buffer);
</I>&gt;<i> -		bitq_in_buffer=NULL;
</I>&gt;<i> +		bitq_in_buffer = NULL;
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> Index: src/jtag/zy1000.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/zy1000.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/zy1000.c	(working copy)
</I>&gt;<i> @@ -321,7 +321,7 @@
</I>&gt;<i>
</I>&gt;<i> static int
</I>&gt;<i> zylinjtag_Jim_Command_powerstatus(Jim_Interp *interp,
</I>&gt;<i> -                                   int argc,
</I>&gt;<i> +								   int argc,
</I>&gt;<i> 		Jim_Obj * const *argv)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc != 1)
</I>&gt;<i> @@ -426,7 +426,7 @@
</I>&gt;<i> #if 0
</I>&gt;<i> static void shiftValueInnerFlip(const enum tap_state state, const  
</I>&gt;<i> enum tap_state endState, int repeat, cyg_uint32 value)
</I>&gt;<i> {
</I>&gt;<i> -	VERBOSE(LOG_INFO(&quot;shiftValueInner %s %s %d %08x (flipped)&quot;,  
</I>&gt;<i> jtag_state_name(state), jtag_state_name(endState), repeat, value));
</I>&gt;<i> +	VERBOSE(LOG_INFO(&quot;shiftValueInner %s %s %d %08x (flipped)&quot;,  
</I>&gt;<i> tap_state_name(state), tap_state_name(endState), repeat, value));
</I>&gt;<i> 	cyg_uint32 a,b;
</I>&gt;<i> 	a=state;
</I>&gt;<i> 	b=endState;
</I>&gt;<i> @@ -718,7 +718,7 @@
</I>&gt;<i> 	enum tap_state t=TAP_IDLE;
</I>&gt;<i> 	/* test manual drive code on any target */
</I>&gt;<i> 	int tms;
</I>&gt;<i> -	u8 tms_scan = TAP_MOVE(t, state);
</I>&gt;<i> +	u8 tms_scan = tap_get_tms_path(t, state);
</I>&gt;<i>
</I>&gt;<i> 	for (i = 0; i &lt; 7; i++)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -764,17 +764,17 @@
</I>&gt;<i>
</I>&gt;<i> 	while (num_states)
</I>&gt;<i> 	{
</I>&gt;<i> -		if (tap_transitions[cur_state].low == path[state_count])
</I>&gt;<i> +		if (tap_state_transition(cur_state, FALSE) == path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			tms = 0;
</I>&gt;<i> 		}
</I>&gt;<i> -		else if (tap_transitions[cur_state].high == path[state_count])
</I>&gt;<i> +		else if (tap_state_transition(cur_state, TRUE) ==  
</I>&gt;<i> path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			tms = 1;
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(path[state_count]));
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(cur_state), tap_state_name(path[state_count]));
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> Index: src/jtag/bitbang.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/bitbang.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/bitbang.c	(working copy)
</I>&gt;<i> @@ -74,13 +74,12 @@
</I>&gt;<i> int bitbang_execute_queue(void);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -
</I>&gt;<i> /* The bitbang driver leaves the TCK 0 when in idle */
</I>&gt;<i>
</I>&gt;<i> -void bitbang_end_state(enum tap_state state)
</I>&gt;<i> +void bitbang_end_state(tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> -	if (tap_move_map[state] != -1)
</I>&gt;<i> -		end_state = state;
</I>&gt;<i> +	if (tap_is_state_stable(state))
</I>&gt;<i> +		tap_set_end_state(state);
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
</I>&gt;<i> @@ -88,10 +87,10 @@
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void bitbang_state_move(void) {
</I>&gt;<i> -
</I>&gt;<i> +void bitbang_state_move(void)
</I>&gt;<i> +{
</I>&gt;<i> 	int i=0, tms=0;
</I>&gt;<i> -	u8 tms_scan = TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +	u8 tms_scan = tap_get_tms_path(tap_get_state(),  
</I>&gt;<i> tap_get_end_state());
</I>&gt;<i>
</I>&gt;<i> 	for (i = 0; i &lt; 7; i++)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -101,7 +100,7 @@
</I>&gt;<i> 	}
</I>&gt;<i> 	bitbang_interface-&gt;write(CLOCK_IDLE(), tms, 0);
</I>&gt;<i>
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(tap_get_end_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void bitbang_path_move(pathmove_command_t *cmd)
</I>&gt;<i> @@ -113,41 +112,41 @@
</I>&gt;<i> 	state_count = 0;
</I>&gt;<i> 	while (num_states)
</I>&gt;<i> 	{
</I>&gt;<i> -		if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
</I>&gt;<i> +		if (tap_state_transition(tap_get_state(), FALSE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			tms = 0;
</I>&gt;<i> 		}
</I>&gt;<i> -		else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
</I>&gt;<i> +		else if (tap_state_transition(tap_get_state(), TRUE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			tms = 1;
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(tap_get_state()), tap_state_name(cmd- 
</I>&gt;<i> &gt;path[state_count]));
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		bitbang_interface-&gt;write(0, tms, 0);
</I>&gt;<i> 		bitbang_interface-&gt;write(1, tms, 0);
</I>&gt;<i>
</I>&gt;<i> -		cur_state = cmd-&gt;path[state_count];
</I>&gt;<i> +		tap_set_state(cmd-&gt;path[state_count]);
</I>&gt;<i> 		state_count++;
</I>&gt;<i> 		num_states--;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	bitbang_interface-&gt;write(CLOCK_IDLE(), tms, 0);
</I>&gt;<i>
</I>&gt;<i> -	end_state = cur_state;
</I>&gt;<i> +	tap_set_end_state(tap_get_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void bitbang_runtest(int num_cycles)
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	tap_state_t saved_end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> 	/* only do a state_move when we're not already in IDLE */
</I>&gt;<i> -	if (cur_state != TAP_IDLE)
</I>&gt;<i> +	if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> 	{
</I>&gt;<i> 		bitbang_end_state(TAP_IDLE);
</I>&gt;<i> 		bitbang_state_move();
</I>&gt;<i> @@ -163,14 +162,14 @@
</I>&gt;<i>
</I>&gt;<i> 	/* finish in end_state */
</I>&gt;<i> 	bitbang_end_state(saved_end_state);
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 		bitbang_state_move();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> static void bitbang_stableclocks(int num_cycles)
</I>&gt;<i> {
</I>&gt;<i> -	int tms = (cur_state == TAP_RESET ? 1 : 0);
</I>&gt;<i> +	int tms = (tap_get_state() == TAP_RESET ? 1 : 0);
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> 	/* send num_cycles clocks onto the cable */
</I>&gt;<i> @@ -185,10 +184,10 @@
</I>&gt;<i>
</I>&gt;<i> void bitbang_scan(int ir_scan, enum scan_type type, u8 *buffer, int  
</I>&gt;<i> scan_size)
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	tap_state_t saved_end_state = tap_get_end_state();
</I>&gt;<i> 	int bit_cnt;
</I>&gt;<i>
</I>&gt;<i> -	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp;  
</I>&gt;<i> (cur_state == TAP_IRSHIFT))))
</I>&gt;<i> +	if (!((!ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT)) || (ir_scan  
</I>&gt;<i> &amp;&amp; (tap_get_state() == TAP_IRSHIFT))))
</I>&gt;<i> 	{
</I>&gt;<i> 		if (ir_scan)
</I>&gt;<i> 			bitbang_end_state(TAP_IRSHIFT);
</I>&gt;<i> @@ -241,11 +240,11 @@
</I>&gt;<i> 	bitbang_interface-&gt;write(CLOCK_IDLE(), 0, 0);
</I>&gt;<i>
</I>&gt;<i> 	if (ir_scan)
</I>&gt;<i> -		cur_state = TAP_IRPAUSE;
</I>&gt;<i> +		tap_set_state(TAP_IRPAUSE);
</I>&gt;<i> 	else
</I>&gt;<i> -		cur_state = TAP_DRPAUSE;
</I>&gt;<i> +		tap_set_state(TAP_DRPAUSE);
</I>&gt;<i>
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 		bitbang_state_move();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -277,7 +276,7 @@
</I>&gt;<i> 		{
</I>&gt;<i> 			case JTAG_END_STATE:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;end_state: %s&quot;, jtag_state_name(cmd-&gt;cmd.end_state- 
</I>&gt;<i> &gt;end_state) );
</I>&gt;<i> +				LOG_DEBUG(&quot;end_state: %s&quot;, tap_state_name(cmd-&gt;cmd.end_state- 
</I>&gt;<i> &gt;end_state) );
</I>&gt;<i> #endif
</I>&gt;<i> 				if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
</I>&gt;<i> 					bitbang_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
</I>&gt;<i> @@ -288,13 +287,13 @@
</I>&gt;<i> #endif
</I>&gt;<i> 				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp;  
</I>&gt;<i> (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
</I>&gt;<i> 				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> +					tap_set_state(TAP_RESET);
</I>&gt;<i> 				}
</I>&gt;<i> 				bitbang_interface-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset- 
</I>&gt;<i> &gt;srst);
</I>&gt;<i> 				break;
</I>&gt;<i> 			case JTAG_RUNTEST:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;num_cycles, jtag_state_name(cmd-&gt;cmd.runtest-&gt;end_state) );
</I>&gt;<i> +				LOG_DEBUG(&quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;num_cycles, tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state) );
</I>&gt;<i> #endif
</I>&gt;<i> 				if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
</I>&gt;<i> 					bitbang_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
</I>&gt;<i> @@ -310,7 +309,7 @@
</I>&gt;<i>
</I>&gt;<i> 			case JTAG_STATEMOVE:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;statemove end in %s&quot;, jtag_state_name(cmd- 
</I>&gt;<i> &gt;cmd.statemove-&gt;end_state));
</I>&gt;<i> +				LOG_DEBUG(&quot;statemove end in %s&quot;, tap_state_name(cmd- 
</I>&gt;<i> &gt;cmd.statemove-&gt;end_state));
</I>&gt;<i> #endif
</I>&gt;<i> 				if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
</I>&gt;<i> 					bitbang_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
</I>&gt;<i> @@ -319,13 +318,13 @@
</I>&gt;<i> 			case JTAG_PATHMOVE:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> 				LOG_DEBUG(&quot;pathmove: %i states, end in %s&quot;, cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states,
</I>&gt;<i> -					jtag_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states - 1]));
</I>&gt;<i> +					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states - 1]));
</I>&gt;<i> #endif
</I>&gt;<i> 				bitbang_path_move(cmd-&gt;cmd.pathmove);
</I>&gt;<i> 				break;
</I>&gt;<i> 			case JTAG_SCAN:
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;%s scan end in %s&quot;,  (cmd-&gt;cmd.scan-&gt;ir_scan) ?  
</I>&gt;<i> &quot;IR&quot; : &quot;DR&quot;, jtag_state_name(cmd-&gt;cmd.scan-&gt;end_state) );
</I>&gt;<i> +				LOG_DEBUG(&quot;%s scan end in %s&quot;,  (cmd-&gt;cmd.scan-&gt;ir_scan) ?  
</I>&gt;<i> &quot;IR&quot; : &quot;DR&quot;, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state) );
</I>&gt;<i> #endif
</I>&gt;<i> 				if (cmd-&gt;cmd.scan-&gt;end_state != -1)
</I>&gt;<i> 					bitbang_end_state(cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> Index: src/jtag/gw16012.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/gw16012.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/gw16012.c	(working copy)
</I>&gt;<i> @@ -196,8 +196,8 @@
</I>&gt;<i>
</I>&gt;<i> void gw16012_end_state(int state)
</I>&gt;<i> {
</I>&gt;<i> -	if (tap_move_map[state] != -1)
</I>&gt;<i> -		end_state = state;
</I>&gt;<i> +	if (tap_is_state_stable(state))
</I>&gt;<i> +		tap_set_end_state(state);
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
</I>&gt;<i> @@ -208,7 +208,7 @@
</I>&gt;<i> void gw16012_state_move(void)
</I>&gt;<i> {
</I>&gt;<i> 	int i=0, tms=0;
</I>&gt;<i> -	u8 tms_scan = TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +	u8 tms_scan = tap_get_tms_path(tap_get_state(),  
</I>&gt;<i> tap_get_end_state());
</I>&gt;<i>
</I>&gt;<i> 	gw16012_control(0x0); /* single-bit mode */
</I>&gt;<i>
</I>&gt;<i> @@ -218,7 +218,7 @@
</I>&gt;<i> 		gw16012_data(tms &lt;&lt; 1); /* output next TMS bit */
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(tap_get_end_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void gw16012_path_move(pathmove_command_t *cmd)
</I>&gt;<i> @@ -230,35 +230,35 @@
</I>&gt;<i> 	while (num_states)
</I>&gt;<i> 	{
</I>&gt;<i> 		gw16012_control(0x0); /* single-bit mode */
</I>&gt;<i> -		if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
</I>&gt;<i> +		if (tap_state_transition(tap_get_state(), FALSE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			gw16012_data(0x0); /* TCK cycle with TMS low */
</I>&gt;<i> 		}
</I>&gt;<i> -		else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
</I>&gt;<i> +		else if (tap_state_transition(tap_get_state(), TRUE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			gw16012_data(0x2); /* TCK cycle with TMS high */
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(tap_get_state()), tap_state_name(cmd- 
</I>&gt;<i> &gt;path[state_count]));
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> -		cur_state = cmd-&gt;path[state_count];
</I>&gt;<i> +		tap_set_state(cmd-&gt;path[state_count]);
</I>&gt;<i> 		state_count++;
</I>&gt;<i> 		num_states--;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	end_state = cur_state;
</I>&gt;<i> +	tap_set_end_state(tap_get_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void gw16012_runtest(int num_cycles)
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	enum tap_state saved_end_state = tap_get_end_state();
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> 	/* only do a state_move when we're not already in IDLE */
</I>&gt;<i> -	if (cur_state != TAP_IDLE)
</I>&gt;<i> +	if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> 	{
</I>&gt;<i> 		gw16012_end_state(TAP_IDLE);
</I>&gt;<i> 		gw16012_state_move();
</I>&gt;<i> @@ -271,7 +271,7 @@
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	gw16012_end_state(saved_end_state);
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 		gw16012_state_move();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -279,11 +279,11 @@
</I>&gt;<i> {
</I>&gt;<i> 	int bits_left = scan_size;
</I>&gt;<i> 	int bit_count = 0;
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	enum tap_state saved_end_state = tap_get_end_state();
</I>&gt;<i> 	u8 scan_out, scan_in;
</I>&gt;<i>
</I>&gt;<i> 	/* only if we're not already in the correct Shift state */
</I>&gt;<i> -	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp;  
</I>&gt;<i> (cur_state == TAP_IRSHIFT))))
</I>&gt;<i> +	if (!((!ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT)) || (ir_scan  
</I>&gt;<i> &amp;&amp; (tap_get_state() == TAP_IRSHIFT))))
</I>&gt;<i> 	{
</I>&gt;<i> 		if (ir_scan)
</I>&gt;<i> 			gw16012_end_state(TAP_IRSHIFT);
</I>&gt;<i> @@ -312,8 +312,8 @@
</I>&gt;<i>
</I>&gt;<i> 		if (bits_left == 0) /* last bit */
</I>&gt;<i> 		{
</I>&gt;<i> -			if ((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT))
</I>&gt;<i> -				|| (!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT)))
</I>&gt;<i> +			if ((ir_scan &amp;&amp; (tap_get_end_state() == TAP_IRSHIFT))
</I>&gt;<i> +				|| (!ir_scan &amp;&amp; (tap_get_end_state() == TAP_DRSHIFT)))
</I>&gt;<i> 			{
</I>&gt;<i> 				tms = 0;
</I>&gt;<i> 			}
</I>&gt;<i> @@ -334,16 +334,16 @@
</I>&gt;<i> 		bit_count++;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if (!((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT)) ||
</I>&gt;<i> -		(!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT))))
</I>&gt;<i> +	if (!((ir_scan &amp;&amp; (tap_get_end_state() == TAP_IRSHIFT)) ||
</I>&gt;<i> +		(!ir_scan &amp;&amp; (tap_get_end_state() == TAP_DRSHIFT))))
</I>&gt;<i> 	{
</I>&gt;<i> 		gw16012_data(0x0);
</I>&gt;<i> 		if (ir_scan)
</I>&gt;<i> -			cur_state = TAP_IRPAUSE;
</I>&gt;<i> +			tap_set_state(TAP_IRPAUSE);
</I>&gt;<i> 		else
</I>&gt;<i> -			cur_state = TAP_DRPAUSE;
</I>&gt;<i> +			tap_set_state(TAP_DRPAUSE);
</I>&gt;<i>
</I>&gt;<i> -		if (cur_state != end_state)
</I>&gt;<i> +		if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 			gw16012_state_move();
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> @@ -378,7 +378,7 @@
</I>&gt;<i> #endif
</I>&gt;<i> 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
</I>&gt;<i> 				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> +					tap_set_state(TAP_RESET);
</I>&gt;<i> 				}
</I>&gt;<i> 				gw16012_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i> 				break;
</I>&gt;<i> Index: src/jtag/jlink.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/jlink.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/jlink.c	(working copy)
</I>&gt;<i> @@ -214,7 +214,7 @@
</I>&gt;<i>
</I>&gt;<i> 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
</I>&gt;<i> 				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> +					tap_set_state(TAP_RESET);
</I>&gt;<i> 				}
</I>&gt;<i> 				jlink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i> 				break;
</I>&gt;<i> @@ -333,9 +333,9 @@
</I>&gt;<i>
</I>&gt;<i> void jlink_end_state(enum tap_state state)
</I>&gt;<i> {
</I>&gt;<i> -	if (tap_move_map[state] != -1)
</I>&gt;<i> +	if (tap_is_state_stable(state))
</I>&gt;<i> 	{
</I>&gt;<i> -		end_state = state;
</I>&gt;<i> +		tap_set_end_state(state);
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> @@ -349,7 +349,7 @@
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i> 	int tms = 0;
</I>&gt;<i> -	u8 tms_scan = TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +	u8 tms_scan = tap_get_tms_path(tap_get_state(),  
</I>&gt;<i> tap_get_end_state());
</I>&gt;<i>
</I>&gt;<i> 	for (i = 0; i &lt; 7; i++)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -357,7 +357,7 @@
</I>&gt;<i> 		jlink_tap_append_step(tms, 0);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(tap_get_end_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void jlink_path_move(int num_states, enum tap_state *path)
</I>&gt;<i> @@ -366,34 +366,34 @@
</I>&gt;<i>
</I>&gt;<i> 	for (i = 0; i &lt; num_states; i++)
</I>&gt;<i> 	{
</I>&gt;<i> -		if (path[i] == tap_transitions[cur_state].low)
</I>&gt;<i> +		if (path[i] == tap_state_transition(tap_get_state(), FALSE))
</I>&gt;<i> 		{
</I>&gt;<i> 			jlink_tap_append_step(0, 0);
</I>&gt;<i> 		}
</I>&gt;<i> -		else if (path[i] == tap_transitions[cur_state].high)
</I>&gt;<i> +		else if (path[i] == tap_state_transition(tap_get_state(), TRUE))
</I>&gt;<i> 		{
</I>&gt;<i> 			jlink_tap_append_step(1, 0);
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(path[i]));
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(tap_get_state()), tap_state_name(path[i]));
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> -		cur_state = path[i];
</I>&gt;<i> +		tap_set_state(path[i]);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	end_state = cur_state;
</I>&gt;<i> +	tap_set_end_state(tap_get_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void jlink_runtest(int num_cycles)
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	enum tap_state saved_end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> 	/* only do a state_move when we're not already in IDLE */
</I>&gt;<i> -	if (cur_state != TAP_IDLE)
</I>&gt;<i> +	if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> 	{
</I>&gt;<i> 		jlink_end_state(TAP_IDLE);
</I>&gt;<i> 		jlink_state_move();
</I>&gt;<i> @@ -407,7 +407,7 @@
</I>&gt;<i>
</I>&gt;<i> 	/* finish in end_state */
</I>&gt;<i> 	jlink_end_state(saved_end_state);
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 	{
</I>&gt;<i> 		jlink_state_move();
</I>&gt;<i> 	}
</I>&gt;<i> @@ -419,7 +419,7 @@
</I>&gt;<i>
</I>&gt;<i> 	jlink_tap_ensure_space(1, scan_size + 8);
</I>&gt;<i>
</I>&gt;<i> -	saved_end_state = end_state;
</I>&gt;<i> +	saved_end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> 	/* Move to appropriate scan state */
</I>&gt;<i> 	jlink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
</I>&gt;<i> @@ -433,9 +433,9 @@
</I>&gt;<i> 	/* We are in Exit1, go to Pause */
</I>&gt;<i> 	jlink_tap_append_step(0, 0);
</I>&gt;<i>
</I>&gt;<i> -	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
</I>&gt;<i> +	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
</I>&gt;<i>
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 	{
</I>&gt;<i> 		jlink_state_move();
</I>&gt;<i> 	}
</I>&gt;<i> Index: src/jtag/amt_jtagaccel.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/amt_jtagaccel.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/amt_jtagaccel.c	(working copy)
</I>&gt;<i> @@ -109,6 +109,7 @@
</I>&gt;<i> 	{{0x1f, 0x00}, {0x0c, 0x00}, {0x07, 0x00}, {0x97, 0x00}, {0x08,  
</I>&gt;<i> 0x00}, {0x00, 0x00}},	/* IRPAUSE  */
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> jtag_interface_t amt_jtagaccel_interface =
</I>&gt;<i> {
</I>&gt;<i> 	.name = &quot;amt_jtagaccel&quot;,
</I>&gt;<i> @@ -157,8 +158,8 @@
</I>&gt;<i>
</I>&gt;<i> void amt_jtagaccel_end_state(int state)
</I>&gt;<i> {
</I>&gt;<i> -	if (tap_move_map[state] != -1)
</I>&gt;<i> -		end_state = state;
</I>&gt;<i> +	if (tap_is_state_stable(state))
</I>&gt;<i> +		tap_set_end_state(state);
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
</I>&gt;<i> @@ -187,9 +188,12 @@
</I>&gt;<i> 	u8 aw_scan_tms_5;
</I>&gt;<i> 	u8 tms_scan[2];
</I>&gt;<i>
</I>&gt;<i> -	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]][0];
</I>&gt;<i> -	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]][1];
</I>&gt;<i> +	tap_state_t	cur_state = tap_get_state();
</I>&gt;<i> +	tap_state_t	end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> +	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_ndx(cur_state)] 
</I>&gt;<i> [tap_move_ndx(end_state)][0];
</I>&gt;<i> +	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_ndx(cur_state)] 
</I>&gt;<i> [tap_move_ndx(end_state)][1];
</I>&gt;<i> +
</I>&gt;<i> 	aw_scan_tms_5 = 0x40 | (tms_scan[0] &amp; 0x1f);
</I>&gt;<i> 	AMT_AW(aw_scan_tms_5);
</I>&gt;<i> 	if (jtag_speed &gt; 3 || rtck_enabled)
</I>&gt;<i> @@ -203,7 +207,7 @@
</I>&gt;<i> 			amt_wait_scan_busy();
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(end_state);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void amt_jtagaccel_runtest(int num_cycles)
</I>&gt;<i> @@ -212,10 +216,10 @@
</I>&gt;<i> 	u8 aw_scan_tms_5;
</I>&gt;<i> 	u8 aw_scan_tms_1to4;
</I>&gt;<i>
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	tap_state_t saved_end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> 	/* only do a state_move when we're not already in IDLE */
</I>&gt;<i> -	if (cur_state != TAP_IDLE)
</I>&gt;<i> +	if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> 	{
</I>&gt;<i> 		amt_jtagaccel_end_state(TAP_IDLE);
</I>&gt;<i> 		amt_jtagaccel_state_move();
</I>&gt;<i> @@ -235,7 +239,7 @@
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	amt_jtagaccel_end_state(saved_end_state);
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 		amt_jtagaccel_state_move();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -243,7 +247,7 @@
</I>&gt;<i> {
</I>&gt;<i> 	int bits_left = scan_size;
</I>&gt;<i> 	int bit_count = 0;
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	tap_state_t saved_end_state = tap_get_end_state();
</I>&gt;<i> 	u8 aw_tdi_option;
</I>&gt;<i> 	u8 dw_tdi_scan;
</I>&gt;<i> 	u8 dr_tdo;
</I>&gt;<i> @@ -297,8 +301,8 @@
</I>&gt;<i> 		bits_left -= 8;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]][0];
</I>&gt;<i> -	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]][1];
</I>&gt;<i> +	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_ndx(tap_get_state())] 
</I>&gt;<i> [tap_move_ndx(tap_get_end_state())][0];
</I>&gt;<i> +	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_ndx(tap_get_state())] 
</I>&gt;<i> [tap_move_ndx(tap_get_end_state())][1];
</I>&gt;<i> 	aw_tms_scan = 0x40 | (tms_scan[0] &amp; 0x1f) | (buf_get_u32(buffer,  
</I>&gt;<i> bit_count, 1) &lt;&lt; 5);
</I>&gt;<i> 	AMT_AW(aw_tms_scan);
</I>&gt;<i> 	if (jtag_speed &gt; 3 || rtck_enabled)
</I>&gt;<i> @@ -318,7 +322,7 @@
</I>&gt;<i> 		if (jtag_speed &gt; 3 || rtck_enabled)
</I>&gt;<i> 			amt_wait_scan_busy();
</I>&gt;<i> 	}
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(tap_get_end_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int amt_jtagaccel_execute_queue(void)
</I>&gt;<i> @@ -351,7 +355,7 @@
</I>&gt;<i> #endif
</I>&gt;<i> 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
</I>&gt;<i> 				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> +					tap_set_state(TAP_RESET);
</I>&gt;<i> 				}
</I>&gt;<i> 				amt_jtagaccel_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i> 				break;
</I>&gt;<i> @@ -404,26 +408,26 @@
</I>&gt;<i> #if PARPORT_USE_GIVEIO == 1
</I>&gt;<i> int amt_jtagaccel_get_giveio_access(void)
</I>&gt;<i> {
</I>&gt;<i> -    HANDLE h;
</I>&gt;<i> -    OSVERSIONINFO version;
</I>&gt;<i> +	HANDLE h;
</I>&gt;<i> +	OSVERSIONINFO version;
</I>&gt;<i>
</I>&gt;<i> -    version.dwOSVersionInfoSize = sizeof version;
</I>&gt;<i> -    if (!GetVersionEx( &amp;version )) {
</I>&gt;<i> +	version.dwOSVersionInfoSize = sizeof version;
</I>&gt;<i> +	if (!GetVersionEx( &amp;version )) {
</I>&gt;<i> 	errno = EINVAL;
</I>&gt;<i> 	return -1;
</I>&gt;<i> -    }
</I>&gt;<i> -    if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
</I>&gt;<i> +	}
</I>&gt;<i> +	if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
</I>&gt;<i> 	return 0;
</I>&gt;<i>
</I>&gt;<i> -    h = CreateFile( &quot;\\\\.\\giveio&quot;, GENERIC_READ, 0, NULL,  
</I>&gt;<i> OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
</I>&gt;<i> -    if (h == INVALID_HANDLE_VALUE) {
</I>&gt;<i> +	h = CreateFile( &quot;\\\\.\\giveio&quot;, GENERIC_READ, 0, NULL,  
</I>&gt;<i> OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
</I>&gt;<i> +	if (h == INVALID_HANDLE_VALUE) {
</I>&gt;<i> 	errno = ENODEV;
</I>&gt;<i> 	return -1;
</I>&gt;<i> -    }
</I>&gt;<i> +	}
</I>&gt;<i>
</I>&gt;<i> -    CloseHandle( h );
</I>&gt;<i> +	CloseHandle( h );
</I>&gt;<i>
</I>&gt;<i> -    return 0;
</I>&gt;<i> +	return 0;
</I>&gt;<i> }
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i> Index: src/jtag/usbprog.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/usbprog.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/usbprog.c	(working copy)
</I>&gt;<i> @@ -151,7 +151,7 @@
</I>&gt;<i> #endif
</I>&gt;<i> 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
</I>&gt;<i> 				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> +					tap_set_state(TAP_RESET);
</I>&gt;<i> 				}
</I>&gt;<i> 				usbprog_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i> 				break;
</I>&gt;<i> @@ -237,8 +237,8 @@
</I>&gt;<i> /*************** jtag execute commands **********************/
</I>&gt;<i> void usbprog_end_state(enum tap_state state)
</I>&gt;<i> {
</I>&gt;<i> -	if (tap_move_map[state] != -1)
</I>&gt;<i> -		end_state = state;
</I>&gt;<i> +	if (tap_is_state_stable(state))
</I>&gt;<i> +		tap_set_end_state(state);
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
</I>&gt;<i> @@ -249,7 +249,7 @@
</I>&gt;<i> void usbprog_state_move(void)
</I>&gt;<i> {
</I>&gt;<i> 	int i = 0, tms = 0;
</I>&gt;<i> -	u8 tms_scan = TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +	u8 tms_scan = tap_get_tms_path(tap_get_state(),  
</I>&gt;<i> tap_get_end_state());
</I>&gt;<i>
</I>&gt;<i> 	usbprog_jtag_write_tms(usbprog_jtag_handle, (char)tms_scan);
</I>&gt;<i> 	for (i = 0; i &lt; 7; i++)
</I>&gt;<i> @@ -257,7 +257,7 @@
</I>&gt;<i> 		tms = (tms_scan &gt;&gt; i) &amp; 1;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(tap_get_end_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void usbprog_path_move(pathmove_command_t *cmd)
</I>&gt;<i> @@ -268,13 +268,13 @@
</I>&gt;<i> 	state_count = 0;
</I>&gt;<i> 	while (num_states)
</I>&gt;<i> 	{
</I>&gt;<i> -		if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
</I>&gt;<i> +		if (tap_state_transition(tap_get_state(), FALSE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			/* LOG_INFO(&quot;1&quot;); */
</I>&gt;<i> 			usbprog_write(0, 0, 0);
</I>&gt;<i> 			usbprog_write(1, 0, 0);
</I>&gt;<i> 		}
</I>&gt;<i> -		else if (tap_transitions[cur_state].high == cmd-&gt;path[state_count])
</I>&gt;<i> +		else if (tap_state_transition(tap_get_state(), TRUE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 		{
</I>&gt;<i> 			/* LOG_INFO(&quot;2&quot;); */
</I>&gt;<i> 			usbprog_write(0, 1, 0);
</I>&gt;<i> @@ -282,16 +282,16 @@
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(tap_get_state()), tap_state_name(cmd- 
</I>&gt;<i> &gt;path[state_count]));
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> -		cur_state = cmd-&gt;path[state_count];
</I>&gt;<i> +		tap_set_state(cmd-&gt;path[state_count]);
</I>&gt;<i> 		state_count++;
</I>&gt;<i> 		num_states--;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	end_state = cur_state;
</I>&gt;<i> +	tap_set_end_state(tap_get_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void usbprog_runtest(int num_cycles)
</I>&gt;<i> @@ -299,7 +299,7 @@
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> 	/* only do a state_move when we're not already in IDLE */
</I>&gt;<i> -	if (cur_state != TAP_IDLE)
</I>&gt;<i> +	if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> 	{
</I>&gt;<i> 		usbprog_end_state(TAP_IDLE);
</I>&gt;<i> 		usbprog_state_move();
</I>&gt;<i> @@ -326,14 +326,14 @@
</I>&gt;<i> 	/* finish in end_state */
</I>&gt;<i> 	/*
</I>&gt;<i> 	usbprog_end_state(saved_end_state);
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 		usbprog_state_move();
</I>&gt;<i> 	*/
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void usbprog_scan(int ir_scan, enum scan_type type, u8 *buffer, int  
</I>&gt;<i> scan_size)
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	enum tap_state saved_end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> 	if (ir_scan)
</I>&gt;<i> 		usbprog_end_state(TAP_IRSHIFT);
</I>&gt;<i> @@ -361,11 +361,11 @@
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	if (ir_scan)
</I>&gt;<i> -		cur_state = TAP_IRPAUSE;
</I>&gt;<i> +		tap_set_state(TAP_IRPAUSE);
</I>&gt;<i> 	else
</I>&gt;<i> -		cur_state = TAP_DRPAUSE;
</I>&gt;<i> +		tap_set_state(TAP_DRPAUSE);
</I>&gt;<i>
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 		usbprog_state_move();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Index: src/jtag/ft2232.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/ft2232.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/ft2232.c	(working copy)
</I>&gt;<i> @@ -1,25 +1,34 @@
</I>&gt;<i> / 
</I>&gt;<i> ***************************************************************************
</I>&gt;<i> - *   Copyright (C) 2004, 2006 by Dominic  
</I>&gt;<i> Rath                              *
</I>&gt;<i> - *    
</I>&gt;<i> Dominic 
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">.Rath at gmx.de</A>                                                   *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   Copyright (C) 2008 by Spencer  
</I>&gt;<i> Oliver                                  *
</I>&gt;<i> - *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">spen at spen-</A> 
</I>&gt;<i> soft.co.uk                                                  *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   This program is free software; you can redistribute it and/or  
</I>&gt;<i> modify  *
</I>&gt;<i> - *   it under the terms of the GNU General Public License as  
</I>&gt;<i> published by  *
</I>&gt;<i> - *   the Free Software Foundation; either version 2 of the License,  
</I>&gt;<i> or     *
</I>&gt;<i> - *   (at your option) any later  
</I>&gt;<i> version.                                   *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   This program is distributed in the hope that it will be  
</I>&gt;<i> useful,       *
</I>&gt;<i> - *   but WITHOUT ANY WARRANTY; without even the implied warranty  
</I>&gt;<i> of        *
</I>&gt;<i> - *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See  
</I>&gt;<i> the         *
</I>&gt;<i> - *   GNU General Public License for more  
</I>&gt;<i> details.                          *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   You should have received a copy of the GNU General Public  
</I>&gt;<i> License     *
</I>&gt;<i> - *   along with this program; if not, write to  
</I>&gt;<i> the                         *
</I>&gt;<i> - *   Free Software Foundation,  
</I>&gt;<i> Inc.,                                       *
</I>&gt;<i> - *   59 Temple Place - Suite 330, Boston, MA  02111-1307,  
</I>&gt;<i> USA.             *
</I>&gt;<i> -  
</I>&gt;<i> ***************************************************************************/
</I>&gt;<i> +*   Copyright (C) 2004, 2006 by Dominic  
</I>&gt;<i> Rath                              *
</I>&gt;<i> +*    
</I>&gt;<i> Dominic 
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">.Rath at gmx.de</A>                                                   *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   Copyright (C) 2008 by Spencer  
</I>&gt;<i> Oliver                                  *
</I>&gt;<i> +*   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">spen at spen-</A> 
</I>&gt;<i> soft.co.uk                                                  *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   This program is free software; you can redistribute it and/or  
</I>&gt;<i> modify  *
</I>&gt;<i> +*   it under the terms of the GNU General Public License as  
</I>&gt;<i> published by  *
</I>&gt;<i> +*   the Free Software Foundation; either version 2 of the License,  
</I>&gt;<i> or     *
</I>&gt;<i> +*   (at your option) any later  
</I>&gt;<i> version.                                   *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   This program is distributed in the hope that it will be  
</I>&gt;<i> useful,       *
</I>&gt;<i> +*   but WITHOUT ANY WARRANTY; without even the implied warranty  
</I>&gt;<i> of        *
</I>&gt;<i> +*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See  
</I>&gt;<i> the         *
</I>&gt;<i> +*   GNU General Public License for more  
</I>&gt;<i> details.                          *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   You should have received a copy of the GNU General Public  
</I>&gt;<i> License     *
</I>&gt;<i> +*   along with this program; if not, write to  
</I>&gt;<i> the                         *
</I>&gt;<i> +*   Free Software Foundation,  
</I>&gt;<i> Inc.,                                       *
</I>&gt;<i> +*   59 Temple Place - Suite 330, Boston, MA  02111-1307,  
</I>&gt;<i> USA.             *
</I>&gt;<i> + 
</I>&gt;<i> ***************************************************************************/
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/* This code uses information contained in the MPSSE specification  
</I>&gt;<i> which was
</I>&gt;<i> + * found here:
</I>&gt;<i> + * <A HREF="http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf">http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf</A>
</I>&gt;<i> + * Hereafter this is called the &quot;MPSSE Spec&quot;.
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> #ifdef HAVE_CONFIG_H
</I>&gt;<i> #include &quot;config.h&quot;
</I>&gt;<i> #endif
</I>&gt;<i> @@ -64,17 +73,17 @@
</I>&gt;<i> int ft2232_execute_queue(void);
</I>&gt;<i>
</I>&gt;<i> int ft2232_speed(int speed);
</I>&gt;<i> -int ft2232_speed_div(int speed, int *khz);
</I>&gt;<i> -int ft2232_khz(int khz, int *jtag_speed);
</I>&gt;<i> -int ft2232_register_commands(struct command_context_s *cmd_ctx);
</I>&gt;<i> +int ft2232_speed_div(int speed, int* khz);
</I>&gt;<i> +int ft2232_khz(int khz, int* jtag_speed);
</I>&gt;<i> +int ft2232_register_commands(struct command_context_s* cmd_ctx);
</I>&gt;<i> int ft2232_init(void);
</I>&gt;<i> int ft2232_quit(void);
</I>&gt;<i>
</I>&gt;<i> -int ft2232_handle_device_desc_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc);
</I>&gt;<i> -int ft2232_handle_serial_command(struct command_context_s *cmd_ctx,  
</I>&gt;<i> char *cmd, char **args, int argc);
</I>&gt;<i> -int ft2232_handle_layout_command(struct command_context_s *cmd_ctx,  
</I>&gt;<i> char *cmd, char **args, int argc);
</I>&gt;<i> -int ft2232_handle_vid_pid_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc);
</I>&gt;<i> -int ft2232_handle_latency_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc);
</I>&gt;<i> +int ft2232_handle_device_desc_command(struct command_context_s*  
</I>&gt;<i> cmd_ctx, char* cmd, char** args, int argc);
</I>&gt;<i> +int ft2232_handle_serial_command(struct command_context_s* cmd_ctx,  
</I>&gt;<i> char* cmd, char** args, int argc);
</I>&gt;<i> +int ft2232_handle_layout_command(struct command_context_s* cmd_ctx,  
</I>&gt;<i> char* cmd, char** args, int argc);
</I>&gt;<i> +int ft2232_handle_vid_pid_command(struct command_context_s*  
</I>&gt;<i> cmd_ctx, char* cmd, char** args, int argc);
</I>&gt;<i> +int ft2232_handle_latency_command(struct command_context_s*  
</I>&gt;<i> cmd_ctx, char* cmd, char** args, int argc);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /**
</I>&gt;<i> @@ -85,36 +94,36 @@
</I>&gt;<i>  * @param num_cycles is the count of clocks cycles to send.
</I>&gt;<i>  * @return int - ERROR_OK or ERROR_JTAG_QUEUE_FAILED
</I>&gt;<i>  */
</I>&gt;<i> -static int ft2232_stableclocks(int num_cycles, jtag_command_t *cmd);
</I>&gt;<i> +static int ft2232_stableclocks(int num_cycles, jtag_command_t* cmd);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -char *ft2232_device_desc = NULL;
</I>&gt;<i> -char *ft2232_serial = NULL;
</I>&gt;<i> -char *ft2232_layout = NULL;
</I>&gt;<i> +char*         ft2232_device_desc = NULL;
</I>&gt;<i> +char*         ft2232_serial  = NULL;
</I>&gt;<i> +char*         ft2232_layout  = NULL;
</I>&gt;<i> unsigned char ft2232_latency = 2;
</I>&gt;<i>
</I>&gt;<i> -#define MAX_USB_IDS	8
</I>&gt;<i> +#define MAX_USB_IDS 8
</I>&gt;<i> /* vid = pid = 0 marks the end of the list */
</I>&gt;<i> -static u16 ft2232_vid[MAX_USB_IDS+1] = { 0x0403, 0 };
</I>&gt;<i> -static u16 ft2232_pid[MAX_USB_IDS+1] = { 0x6010, 0 };
</I>&gt;<i> +static u16 ft2232_vid[MAX_USB_IDS + 1] = { 0x0403, 0 };
</I>&gt;<i> +static u16 ft2232_pid[MAX_USB_IDS + 1] = { 0x6010, 0 };
</I>&gt;<i>
</I>&gt;<i> typedef struct ft2232_layout_s
</I>&gt;<i> {
</I>&gt;<i> 	char* name;
</I>&gt;<i> -	int(*init)(void);
</I>&gt;<i> -	void(*reset)(int trst, int srst);
</I>&gt;<i> -	void(*blink)(void);
</I>&gt;<i> +	int (*init)(void);
</I>&gt;<i> +	void (*reset)(int trst, int srst);
</I>&gt;<i> +	void (*blink)(void);
</I>&gt;<i> } ft2232_layout_t;
</I>&gt;<i>
</I>&gt;<i> /* init procedures for supported layouts */
</I>&gt;<i> -int usbjtag_init(void);
</I>&gt;<i> -int jtagkey_init(void);
</I>&gt;<i> -int olimex_jtag_init(void);
</I>&gt;<i> -int flyswatter_init(void);
</I>&gt;<i> -int turtle_init(void);
</I>&gt;<i> -int comstick_init(void);
</I>&gt;<i> -int stm32stick_init(void);
</I>&gt;<i> -int axm0432_jtag_init(void);
</I>&gt;<i> +int  usbjtag_init(void);
</I>&gt;<i> +int  jtagkey_init(void);
</I>&gt;<i> +int  olimex_jtag_init(void);
</I>&gt;<i> +int  flyswatter_init(void);
</I>&gt;<i> +int  turtle_init(void);
</I>&gt;<i> +int  comstick_init(void);
</I>&gt;<i> +int  stm32stick_init(void);
</I>&gt;<i> +int  axm0432_jtag_init(void);
</I>&gt;<i>
</I>&gt;<i> /* reset procedures for supported layouts */
</I>&gt;<i> void usbjtag_reset(int trst, int srst);
</I>&gt;<i> @@ -130,68 +139,68 @@
</I>&gt;<i> void olimex_jtag_blink(void);
</I>&gt;<i> void turtle_jtag_blink(void);
</I>&gt;<i>
</I>&gt;<i> -ft2232_layout_t ft2232_layouts[] =
</I>&gt;<i> +ft2232_layout_t            ft2232_layouts[] =
</I>&gt;<i> {
</I>&gt;<i> -	{&quot;usbjtag&quot;, usbjtag_init, usbjtag_reset, NULL},
</I>&gt;<i> -	{&quot;jtagkey&quot;, jtagkey_init, jtagkey_reset, NULL},
</I>&gt;<i> -	{&quot;jtagkey_prototype_v1&quot;, jtagkey_init, jtagkey_reset, NULL},
</I>&gt;<i> -	{&quot;oocdlink&quot;, jtagkey_init, jtagkey_reset, NULL},
</I>&gt;<i> -	{&quot;signalyzer&quot;, usbjtag_init, usbjtag_reset, NULL},
</I>&gt;<i> -	{&quot;evb_lm3s811&quot;, usbjtag_init, usbjtag_reset, NULL},
</I>&gt;<i> -	{&quot;olimex-jtag&quot;, olimex_jtag_init, olimex_jtag_reset,  
</I>&gt;<i> olimex_jtag_blink},
</I>&gt;<i> -	{&quot;flyswatter&quot;, flyswatter_init, flyswatter_reset, NULL},
</I>&gt;<i> -	{&quot;turtelizer2&quot;, turtle_init, turtle_reset, turtle_jtag_blink},
</I>&gt;<i> -	{&quot;comstick&quot;, comstick_init, comstick_reset, NULL},
</I>&gt;<i> -	{&quot;stm32stick&quot;, stm32stick_init, stm32stick_reset, NULL},
</I>&gt;<i> -	{&quot;axm0432_jtag&quot;, axm0432_jtag_init, axm0432_jtag_reset, NULL},
</I>&gt;<i> -	{NULL, NULL, NULL},
</I>&gt;<i> +	{ &quot;usbjtag&quot;,              usbjtag_init,               
</I>&gt;<i> usbjtag_reset,      NULL                    },
</I>&gt;<i> +	{ &quot;jtagkey&quot;,              jtagkey_init,               
</I>&gt;<i> jtagkey_reset,      NULL                    },
</I>&gt;<i> +	{ &quot;jtagkey_prototype_v1&quot;, jtagkey_init,               
</I>&gt;<i> jtagkey_reset,      NULL                    },
</I>&gt;<i> +	{ &quot;oocdlink&quot;,             jtagkey_init,               
</I>&gt;<i> jtagkey_reset,      NULL                    },
</I>&gt;<i> +	{ &quot;signalyzer&quot;,           usbjtag_init,               
</I>&gt;<i> usbjtag_reset,      NULL                    },
</I>&gt;<i> +	{ &quot;evb_lm3s811&quot;,          usbjtag_init,               
</I>&gt;<i> usbjtag_reset,      NULL                    },
</I>&gt;<i> +	{ &quot;olimex-jtag&quot;,          olimex_jtag_init,           
</I>&gt;<i> olimex_jtag_reset,  olimex_jtag_blink       },
</I>&gt;<i> +	{ &quot;flyswatter&quot;,           flyswatter_init,            
</I>&gt;<i> flyswatter_reset,   NULL                    },
</I>&gt;<i> +	{ &quot;turtelizer2&quot;,          turtle_init,                
</I>&gt;<i> turtle_reset,       turtle_jtag_blink       },
</I>&gt;<i> +	{ &quot;comstick&quot;,             comstick_init,              
</I>&gt;<i> comstick_reset,     NULL                    },
</I>&gt;<i> +	{ &quot;stm32stick&quot;,           stm32stick_init,            
</I>&gt;<i> stm32stick_reset,   NULL                    },
</I>&gt;<i> +	{ &quot;axm0432_jtag&quot;,         axm0432_jtag_init,          
</I>&gt;<i> axm0432_jtag_reset, NULL                    },
</I>&gt;<i> +	{ NULL,                   NULL,                      NULL },
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> -static u8 nTRST, nTRSTnOE, nSRST, nSRSTnOE;
</I>&gt;<i> +static u8                  nTRST, nTRSTnOE, nSRST, nSRSTnOE;
</I>&gt;<i>
</I>&gt;<i> -static ft2232_layout_t *layout;
</I>&gt;<i> -static u8 low_output = 0x0;
</I>&gt;<i> -static u8 low_direction = 0x0;
</I>&gt;<i> -static u8 high_output = 0x0;
</I>&gt;<i> -static u8 high_direction = 0x0;
</I>&gt;<i> +static ft2232_layout_t*    layout;
</I>&gt;<i> +static u8                  low_output     = 0x0;
</I>&gt;<i> +static u8                  low_direction  = 0x0;
</I>&gt;<i> +static u8                  high_output    = 0x0;
</I>&gt;<i> +static u8                  high_direction = 0x0;
</I>&gt;<i>
</I>&gt;<i> #if BUILD_FT2232_FTD2XX == 1
</I>&gt;<i> -static FT_HANDLE ftdih = NULL;
</I>&gt;<i> +static FT_HANDLE           ftdih = NULL;
</I>&gt;<i> #elif BUILD_FT2232_LIBFTDI == 1
</I>&gt;<i> static struct ftdi_context ftdic;
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -static jtag_command_t *first_unsent;		/* next command that has to  
</I>&gt;<i> be sent */
</I>&gt;<i> -static int require_send;
</I>&gt;<i> +static jtag_command_t* first_unsent;        /* next command that  
</I>&gt;<i> has to be sent */
</I>&gt;<i> +static int             require_send;
</I>&gt;<i>
</I>&gt;<i> -static u8 *ft2232_buffer = NULL;
</I>&gt;<i> -static int ft2232_buffer_size = 0;
</I>&gt;<i> -static int ft2232_read_pointer = 0;
</I>&gt;<i> -static int ft2232_expect_read = 0;
</I>&gt;<i> +static u8*             ft2232_buffer = NULL;
</I>&gt;<i> +static int             ft2232_buffer_size  = 0;
</I>&gt;<i> +static int             ft2232_read_pointer = 0;
</I>&gt;<i> +static int             ft2232_expect_read  = 0;
</I>&gt;<i>
</I>&gt;<i> -#define FT2232_BUFFER_SIZE	131072
</I>&gt;<i> -#define BUFFER_ADD ft2232_buffer[ft2232_buffer_size++]
</I>&gt;<i> -#define BUFFER_READ ft2232_buffer[ft2232_read_pointer++]
</I>&gt;<i> +#define FT2232_BUFFER_SIZE 131072
</I>&gt;<i> +#define BUFFER_ADD         ft2232_buffer[ft2232_buffer_size++]
</I>&gt;<i> +#define BUFFER_READ        ft2232_buffer[ft2232_read_pointer++]
</I>&gt;<i>
</I>&gt;<i> jtag_interface_t ft2232_interface =
</I>&gt;<i> {
</I>&gt;<i> -	.name = &quot;ft2232&quot;,
</I>&gt;<i> +	.name               = &quot;ft2232&quot;,
</I>&gt;<i> 	.execute_queue = ft2232_execute_queue,
</I>&gt;<i> -	.speed = ft2232_speed,
</I>&gt;<i> +	.speed     = ft2232_speed,
</I>&gt;<i> 	.speed_div = ft2232_speed_div,
</I>&gt;<i> -	.khz = ft2232_khz,
</I>&gt;<i> -	.register_commands = ft2232_register_commands,
</I>&gt;<i> +	.khz                = ft2232_khz,
</I>&gt;<i> +	.register_commands  = ft2232_register_commands,
</I>&gt;<i> 	.init = ft2232_init,
</I>&gt;<i> 	.quit = ft2232_quit,
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> -int ft2232_write(u8 *buf, int size, u32* bytes_written)
</I>&gt;<i> +int ft2232_write(u8* buf, int size, u32* bytes_written)
</I>&gt;<i> {
</I>&gt;<i> #if BUILD_FT2232_FTD2XX == 1
</I>&gt;<i> 	FT_STATUS status;
</I>&gt;<i> -	DWORD dw_bytes_written;
</I>&gt;<i> -	if ((status = FT_Write(ftdih, buf, size, &amp;dw_bytes_written)) !=  
</I>&gt;<i> FT_OK)
</I>&gt;<i> +	DWORD     dw_bytes_written;
</I>&gt;<i> +	if ( ( status = FT_Write(ftdih, buf, size, &amp;dw_bytes_written) ) !=  
</I>&gt;<i> FT_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		*bytes_written = dw_bytes_written;
</I>&gt;<i> 		LOG_ERROR(&quot;FT_Write returned: %lu&quot;, status);
</I>&gt;<i> @@ -204,10 +213,10 @@
</I>&gt;<i> 	}
</I>&gt;<i> #elif BUILD_FT2232_LIBFTDI == 1
</I>&gt;<i> 	int retval;
</I>&gt;<i> -	if ((retval = ftdi_write_data(&amp;ftdic, buf, size)) &lt; 0)
</I>&gt;<i> +	if ( ( retval = ftdi_write_data(&amp;ftdic, buf, size) ) &lt; 0 )
</I>&gt;<i> 	{
</I>&gt;<i> 		*bytes_written = 0;
</I>&gt;<i> -		LOG_ERROR(&quot;ftdi_write_data: %s&quot;, ftdi_get_error_string(&amp;ftdic));
</I>&gt;<i> +		LOG_ERROR( &quot;ftdi_write_data: %s&quot;, ftdi_get_error_string(&amp;ftdic) );
</I>&gt;<i> 		return ERROR_JTAG_DEVICE_ERROR;
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> @@ -218,18 +227,19 @@
</I>&gt;<i> #endif
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int ft2232_read(u8* buf, int size, u32* bytes_read)
</I>&gt;<i> {
</I>&gt;<i> #if BUILD_FT2232_FTD2XX == 1
</I>&gt;<i> -	DWORD dw_bytes_read;
</I>&gt;<i> +	DWORD     dw_bytes_read;
</I>&gt;<i> 	FT_STATUS status;
</I>&gt;<i> -	int timeout = 5;
</I>&gt;<i> +	int       timeout = 5;
</I>&gt;<i> 	*bytes_read = 0;
</I>&gt;<i>
</I>&gt;<i> -	while ((*bytes_read &lt; size) &amp;&amp; timeout--)
</I>&gt;<i> +	while ( (*bytes_read &lt; size) &amp;&amp; timeout-- )
</I>&gt;<i> 	{
</I>&gt;<i> -		if ((status = FT_Read(ftdih, buf + *bytes_read, size -
</I>&gt;<i> -			*bytes_read, &amp;dw_bytes_read)) != FT_OK)
</I>&gt;<i> +		if ( ( status = FT_Read(ftdih, buf + *bytes_read, size -
</I>&gt;<i> +					  *bytes_read, &amp;dw_bytes_read) ) != FT_OK )
</I>&gt;<i> 		{
</I>&gt;<i> 			*bytes_read = 0;
</I>&gt;<i> 			LOG_ERROR(&quot;FT_Read returned: %lu&quot;, status);
</I>&gt;<i> @@ -237,21 +247,23 @@
</I>&gt;<i> 		}
</I>&gt;<i> 		*bytes_read += dw_bytes_read;
</I>&gt;<i> 	}
</I>&gt;<i> +
</I>&gt;<i> #elif BUILD_FT2232_LIBFTDI == 1
</I>&gt;<i> 	int retval;
</I>&gt;<i> 	int timeout = 100;
</I>&gt;<i> 	*bytes_read = 0;
</I>&gt;<i>
</I>&gt;<i> -	while ((*bytes_read &lt; size) &amp;&amp; timeout--)
</I>&gt;<i> +	while ( (*bytes_read &lt; size) &amp;&amp; timeout-- )
</I>&gt;<i> 	{
</I>&gt;<i> -		if ((retval = ftdi_read_data(&amp;ftdic, buf + *bytes_read, size -  
</I>&gt;<i> *bytes_read)) &lt; 0)
</I>&gt;<i> +		if ( ( retval = ftdi_read_data(&amp;ftdic, buf + *bytes_read, size -  
</I>&gt;<i> *bytes_read) ) &lt; 0 )
</I>&gt;<i> 		{
</I>&gt;<i> 			*bytes_read = 0;
</I>&gt;<i> -			LOG_ERROR(&quot;ftdi_read_data: %s&quot;, ftdi_get_error_string(&amp;ftdic));
</I>&gt;<i> +			LOG_ERROR( &quot;ftdi_read_data: %s&quot;, ftdi_get_error_string(&amp;ftdic) );
</I>&gt;<i> 			return ERROR_JTAG_DEVICE_ERROR;
</I>&gt;<i> 		}
</I>&gt;<i> 		*bytes_read += retval;
</I>&gt;<i> 	}
</I>&gt;<i> +
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i> 	if (*bytes_read &lt; size)
</I>&gt;<i> @@ -263,18 +275,19 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int ft2232_speed(int speed)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	int retval;
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	buf[0] = 0x86; /* command &quot;set divisor&quot; */
</I>&gt;<i> -	buf[1] = speed &amp; 0xff; /* valueL (0=6MHz, 1=3MHz, 2=2.0MHz, ...*/
</I>&gt;<i> -	buf[2] = (speed &gt;&gt; 8) &amp; 0xff; /* valueH */
</I>&gt;<i> +	buf[0] = 0x86;                  /* command &quot;set divisor&quot; */
</I>&gt;<i> +	buf[1] = speed &amp; 0xff;          /* valueL (0=6MHz, 1=3MHz,  
</I>&gt;<i> 2=2.0MHz, ...*/
</I>&gt;<i> +	buf[2] = (speed &gt;&gt; 8) &amp; 0xff;   /* valueH */
</I>&gt;<i>
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i> -	if (((retval = ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK)  
</I>&gt;<i> || (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( retval = ft2232_write(buf, 3, &amp;bytes_written) ) !=  
</I>&gt;<i> ERROR_OK ) || (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't set FT2232 TCK speed&quot;);
</I>&gt;<i> 		return retval;
</I>&gt;<i> @@ -283,24 +296,27 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_speed_div(int speed, int *khz)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_speed_div(int speed, int* khz)
</I>&gt;<i> {
</I>&gt;<i> 	/* Take a look in the FT2232 manual,
</I>&gt;<i> 	 * AN2232C-01 Command Processor for
</I>&gt;<i> 	 * MPSSE and MCU Host Bus. Chapter 3.8 */
</I>&gt;<i>
</I>&gt;<i> -	*khz = 6000 / (1+speed);
</I>&gt;<i> +	*khz = 6000 / (1 + speed);
</I>&gt;<i>
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_khz(int khz, int *jtag_speed)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_khz(int khz, int* jtag_speed)
</I>&gt;<i> {
</I>&gt;<i> 	if (khz==0)
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;RCLK not supported&quot;);
</I>&gt;<i> 		return ERROR_FAIL;
</I>&gt;<i> 	}
</I>&gt;<i> +
</I>&gt;<i> 	/* Take a look in the FT2232 manual,
</I>&gt;<i> 	 * AN2232C-01 Command Processor for
</I>&gt;<i> 	 * MPSSE and MCU Host Bus. Chapter 3.8
</I>&gt;<i> @@ -333,25 +349,27 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_register_commands(struct command_context_s *cmd_ctx)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_register_commands(struct command_context_s* cmd_ctx)
</I>&gt;<i> {
</I>&gt;<i> 	register_command(cmd_ctx, NULL, &quot;ft2232_device_desc&quot;,  
</I>&gt;<i> ft2232_handle_device_desc_command,
</I>&gt;<i> -		COMMAND_CONFIG, &quot;the USB device description of the FTDI FT2232  
</I>&gt;<i> device&quot;);
</I>&gt;<i> +			COMMAND_CONFIG, &quot;the USB device description of the FTDI FT2232  
</I>&gt;<i> device&quot;);
</I>&gt;<i> 	register_command(cmd_ctx, NULL, &quot;ft2232_serial&quot;,  
</I>&gt;<i> ft2232_handle_serial_command,
</I>&gt;<i> -		COMMAND_CONFIG, &quot;the serial number of the FTDI FT2232 device&quot;);
</I>&gt;<i> +			COMMAND_CONFIG, &quot;the serial number of the FTDI FT2232 device&quot;);
</I>&gt;<i> 	register_command(cmd_ctx, NULL, &quot;ft2232_layout&quot;,  
</I>&gt;<i> ft2232_handle_layout_command,
</I>&gt;<i> -		COMMAND_CONFIG, &quot;the layout of the FT2232 GPIO signals used to  
</I>&gt;<i> control output-enables and reset signals&quot;);
</I>&gt;<i> +			COMMAND_CONFIG, &quot;the layout of the FT2232 GPIO signals used to  
</I>&gt;<i> control output-enables and reset signals&quot;);
</I>&gt;<i> 	register_command(cmd_ctx, NULL, &quot;ft2232_vid_pid&quot;,  
</I>&gt;<i> ft2232_handle_vid_pid_command,
</I>&gt;<i> -					 COMMAND_CONFIG, &quot;the vendor ID and product ID of the FTDI  
</I>&gt;<i> FT2232 device&quot;);
</I>&gt;<i> +			COMMAND_CONFIG, &quot;the vendor ID and product ID of the FTDI FT2232  
</I>&gt;<i> device&quot;);
</I>&gt;<i> 	register_command(cmd_ctx, NULL, &quot;ft2232_latency&quot;,  
</I>&gt;<i> ft2232_handle_latency_command,
</I>&gt;<i> -					 COMMAND_CONFIG, &quot;set the FT2232 latency timer to a new value&quot;);
</I>&gt;<i> +			COMMAND_CONFIG, &quot;set the FT2232 latency timer to a new value&quot;);
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void ft2232_end_state(enum tap_state state)
</I>&gt;<i> +
</I>&gt;<i> +void ft2232_end_state(tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> -	if (tap_move_map[state] != -1)
</I>&gt;<i> -		end_state = state;
</I>&gt;<i> +	if (tap_is_state_stable(state))
</I>&gt;<i> +		tap_set_end_state(state);
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
</I>&gt;<i> @@ -359,13 +377,14 @@
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void ft2232_read_scan(enum scan_type type, u8* buffer, int scan_size)
</I>&gt;<i> {
</I>&gt;<i> 	int num_bytes = (scan_size + 7) / 8;
</I>&gt;<i> 	int bits_left = scan_size;
</I>&gt;<i> -	int cur_byte = 0;
</I>&gt;<i> +	int cur_byte  = 0;
</I>&gt;<i>
</I>&gt;<i> -	while(num_bytes-- &gt; 1)
</I>&gt;<i> +	while (num_bytes-- &gt; 1)
</I>&gt;<i> 	{
</I>&gt;<i> 		buffer[cur_byte] = BUFFER_READ;
</I>&gt;<i> 		cur_byte++;
</I>&gt;<i> @@ -379,15 +398,15 @@
</I>&gt;<i> 		buffer[cur_byte] = BUFFER_READ &gt;&gt; 1;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	buffer[cur_byte] = (buffer[cur_byte] | ((BUFFER_READ &amp; 0x02) &lt;&lt;  
</I>&gt;<i> 6)) &gt;&gt; (8 - bits_left);
</I>&gt;<i> -
</I>&gt;<i> +	buffer[cur_byte] = ( buffer[cur_byte] | ( (BUFFER_READ &amp; 0x02) &lt;&lt;  
</I>&gt;<i> 6 ) ) &gt;&gt; (8 - bits_left);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void ft2232_debug_dump_buffer(void)
</I>&gt;<i> {
</I>&gt;<i> -	int i;
</I>&gt;<i> -	char line[256];
</I>&gt;<i> -	char *line_p = line;
</I>&gt;<i> +	int   i;
</I>&gt;<i> +	char  line[256];
</I>&gt;<i> +	char* line_p = line;
</I>&gt;<i>
</I>&gt;<i> 	for (i = 0; i &lt; ft2232_buffer_size; i++)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -403,19 +422,20 @@
</I>&gt;<i> 		LOG_DEBUG(&quot;%s&quot;, line);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_send_and_recv(jtag_command_t *first, jtag_command_t *last)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_send_and_recv(jtag_command_t* first, jtag_command_t* last)
</I>&gt;<i> {
</I>&gt;<i> -	jtag_command_t *cmd;
</I>&gt;<i> -	u8 *buffer;
</I>&gt;<i> -	int scan_size;
</I>&gt;<i> -	enum scan_type type;
</I>&gt;<i> -	int retval;
</I>&gt;<i> -	u32 bytes_written;
</I>&gt;<i> -	u32 bytes_read;
</I>&gt;<i> +	jtag_command_t* cmd;
</I>&gt;<i> +	u8*             buffer;
</I>&gt;<i> +	int             scan_size;
</I>&gt;<i> +	enum scan_type  type;
</I>&gt;<i> +	int             retval;
</I>&gt;<i> +	u32             bytes_written;
</I>&gt;<i> +	u32             bytes_read;
</I>&gt;<i>
</I>&gt;<i> #ifdef _DEBUG_USB_IO_
</I>&gt;<i> -	struct timeval start, inter, inter2, end;
</I>&gt;<i> -	struct timeval d_inter, d_inter2, d_end;
</I>&gt;<i> +	struct timeval  start, inter, inter2, end;
</I>&gt;<i> +	struct timeval  d_inter, d_inter2, d_end;
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i> #ifdef _DEBUG_USB_COMMS_
</I>&gt;<i> @@ -427,7 +447,7 @@
</I>&gt;<i> 	gettimeofday(&amp;start, NULL);
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i> -	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size,  
</I>&gt;<i> &amp;bytes_written)) != ERROR_OK)
</I>&gt;<i> +	if ( ( retval = ft2232_write(ft2232_buffer, ft2232_buffer_size,  
</I>&gt;<i> &amp;bytes_written) ) != ERROR_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
</I>&gt;<i> 		return retval;
</I>&gt;<i> @@ -446,7 +466,7 @@
</I>&gt;<i> 		gettimeofday(&amp;inter2, NULL);
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i> -		if ((retval = ft2232_read(ft2232_buffer, ft2232_expect_read,  
</I>&gt;<i> &amp;bytes_read)) != ERROR_OK)
</I>&gt;<i> +		if ( ( retval = ft2232_read(ft2232_buffer, ft2232_expect_read,  
</I>&gt;<i> &amp;bytes_read) ) != ERROR_OK )
</I>&gt;<i> 		{
</I>&gt;<i> 			LOG_ERROR(&quot;couldn't read from FT2232&quot;);
</I>&gt;<i> 			return retval;
</I>&gt;<i> @@ -459,15 +479,18 @@
</I>&gt;<i> 		timeval_subtract(&amp;d_inter2, &amp;inter2, &amp;start);
</I>&gt;<i> 		timeval_subtract(&amp;d_end, &amp;end, &amp;start);
</I>&gt;<i>
</I>&gt;<i> -		LOG_INFO(&quot;inter: %i.%06i, inter2: %i.%06i end: %i.%06i&quot;,  
</I>&gt;<i> d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec, d_inter2.tv_usec,  
</I>&gt;<i> d_end.tv_sec, d_end.tv_usec);
</I>&gt;<i> +		LOG_INFO(&quot;inter: %i.%06i, inter2: %i.%06i end: %i.%06i&quot;,  
</I>&gt;<i> d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec,
</I>&gt;<i> +				d_inter2.tv_usec, d_end.tv_sec,
</I>&gt;<i> +				d_end.tv_usec);
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i> -
</I>&gt;<i> 		ft2232_buffer_size = bytes_read;
</I>&gt;<i>
</I>&gt;<i> 		if (ft2232_expect_read != ft2232_buffer_size)
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;ft2232_expect_read (%i) != ft2232_buffer_size (%i)  
</I>&gt;<i> (%i retries)&quot;, ft2232_expect_read, ft2232_buffer_size, 100 - timeout);
</I>&gt;<i> +			LOG_ERROR(&quot;ft2232_expect_read (%i) != ft2232_buffer_size (%i)  
</I>&gt;<i> (%i retries)&quot;, ft2232_expect_read,
</I>&gt;<i> +					ft2232_buffer_size,
</I>&gt;<i> +					100 - timeout);
</I>&gt;<i> 			ft2232_debug_dump_buffer();
</I>&gt;<i>
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> @@ -479,7 +502,7 @@
</I>&gt;<i> #endif
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	ft2232_expect_read = 0;
</I>&gt;<i> +	ft2232_expect_read  = 0;
</I>&gt;<i> 	ft2232_read_pointer = 0;
</I>&gt;<i>
</I>&gt;<i> 	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
</I>&gt;<i> @@ -492,21 +515,23 @@
</I>&gt;<i> 	{
</I>&gt;<i> 		switch (cmd-&gt;type)
</I>&gt;<i> 		{
</I>&gt;<i> -			case JTAG_SCAN:
</I>&gt;<i> -				type = jtag_scan_type(cmd-&gt;cmd.scan);
</I>&gt;<i> -				if (type != SCAN_OUT)
</I>&gt;<i> -				{
</I>&gt;<i> -					scan_size = jtag_scan_size(cmd-&gt;cmd.scan);
</I>&gt;<i> -					buffer = calloc(CEIL(scan_size, 8), 1);
</I>&gt;<i> -					ft2232_read_scan(type, buffer, scan_size);
</I>&gt;<i> -					if (jtag_read_buffer(buffer, cmd-&gt;cmd.scan) != ERROR_OK)
</I>&gt;<i> -						retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> -					free(buffer);
</I>&gt;<i> -				}
</I>&gt;<i> -				break;
</I>&gt;<i> -			default:
</I>&gt;<i> -				break;
</I>&gt;<i> +		case JTAG_SCAN:
</I>&gt;<i> +			type = jtag_scan_type(cmd-&gt;cmd.scan);
</I>&gt;<i> +			if (type != SCAN_OUT)
</I>&gt;<i> +			{
</I>&gt;<i> +				scan_size = jtag_scan_size(cmd-&gt;cmd.scan);
</I>&gt;<i> +				buffer    = calloc(CEIL(scan_size, 8), 1);
</I>&gt;<i> +				ft2232_read_scan(type, buffer, scan_size);
</I>&gt;<i> +				if (jtag_read_buffer(buffer, cmd-&gt;cmd.scan) != ERROR_OK)
</I>&gt;<i> +					retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +				free(buffer);
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		default:
</I>&gt;<i> +			break;
</I>&gt;<i> 		}
</I>&gt;<i> +
</I>&gt;<i> 		cmd = cmd-&gt;next;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> @@ -515,71 +540,74 @@
</I>&gt;<i> 	return retval;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void ft2232_add_pathmove(pathmove_command_t *cmd)
</I>&gt;<i> +
</I>&gt;<i> +void ft2232_add_pathmove(pathmove_command_t* cmd)
</I>&gt;<i> {
</I>&gt;<i> 	int num_states = cmd-&gt;num_states;
</I>&gt;<i> -	u8 tms_byte;
</I>&gt;<i> -	int state_count;
</I>&gt;<i> +	int state_count = 0;
</I>&gt;<i>
</I>&gt;<i> -	state_count = 0;
</I>&gt;<i> 	while (num_states)
</I>&gt;<i> 	{
</I>&gt;<i> +		u8  tms_byte = 0;       /* zero this on each MPSSE batch */
</I>&gt;<i> +
</I>&gt;<i> 		int bit_count = 0;
</I>&gt;<i>
</I>&gt;<i> 		int num_states_batch = num_states &gt; 7 ? 7 : num_states;
</I>&gt;<i>
</I>&gt;<i> -		tms_byte = 0x0;
</I>&gt;<i> 		/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> 		BUFFER_ADD = 0x4b;
</I>&gt;<i> +
</I>&gt;<i> 		/* number of states remaining */
</I>&gt;<i> 		BUFFER_ADD = num_states_batch - 1;
</I>&gt;<i>
</I>&gt;<i> 		while (num_states_batch--)
</I>&gt;<i> 		{
</I>&gt;<i> -			if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
</I>&gt;<i> +			if (tap_state_transition(tap_get_state(), FALSE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 				buf_set_u32(&amp;tms_byte, bit_count++, 1, 0x0);
</I>&gt;<i> -			else if (tap_transitions[cur_state].high == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> +			else if (tap_state_transition(tap_get_state(), TRUE) == cmd- 
</I>&gt;<i> &gt;path[state_count])
</I>&gt;<i> 				buf_set_u32(&amp;tms_byte, bit_count++, 1, 0x1);
</I>&gt;<i> 			else
</I>&gt;<i> 			{
</I>&gt;<i> -				LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(cmd-&gt;path[state_count]));
</I>&gt;<i> +				LOG_ERROR( &quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(
</I>&gt;<i> +								 tap_get_state() ), tap_state_name(cmd-&gt;path[state_count]) );
</I>&gt;<i> 				exit(-1);
</I>&gt;<i> 			}
</I>&gt;<i>
</I>&gt;<i> -			cur_state = cmd-&gt;path[state_count];
</I>&gt;<i> +			tap_set_state(cmd-&gt;path[state_count]);
</I>&gt;<i> 			state_count++;
</I>&gt;<i> 			num_states--;
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		BUFFER_ADD = tms_byte;
</I>&gt;<i> 	}
</I>&gt;<i> -
</I>&gt;<i> -	end_state = cur_state;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void ft2232_add_scan(int ir_scan, enum scan_type type, u8 *buffer,  
</I>&gt;<i> int scan_size)
</I>&gt;<i> +
</I>&gt;<i> +void ft2232_add_scan(int ir_scan, enum scan_type type, u8* buffer,  
</I>&gt;<i> int scan_size)
</I>&gt;<i> {
</I>&gt;<i> 	int num_bytes = (scan_size + 7) / 8;
</I>&gt;<i> 	int bits_left = scan_size;
</I>&gt;<i> -	int cur_byte = 0;
</I>&gt;<i> +	int cur_byte  = 0;
</I>&gt;<i> 	int last_bit;
</I>&gt;<i>
</I>&gt;<i> -	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp;  
</I>&gt;<i> (cur_state == TAP_IRSHIFT))))
</I>&gt;<i> +	if ( !( ( !ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT) )
</I>&gt;<i> +	   || (    ir_scan &amp;&amp; (tap_get_state() == TAP_IRSHIFT) ) ) )
</I>&gt;<i> 	{
</I>&gt;<i> 		/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> 		BUFFER_ADD = 0x4b;
</I>&gt;<i> -		/* scan 7 bit */
</I>&gt;<i> -		BUFFER_ADD = 0x6;
</I>&gt;<i> +
</I>&gt;<i> +		BUFFER_ADD = 0x6;       /* scan 7 bits */
</I>&gt;<i> +
</I>&gt;<i> 		/* TMS data bits */
</I>&gt;<i> 		if (ir_scan)
</I>&gt;<i> 		{
</I>&gt;<i> -			BUFFER_ADD = TAP_MOVE(cur_state, TAP_IRSHIFT);
</I>&gt;<i> -			cur_state = TAP_IRSHIFT;
</I>&gt;<i> +			BUFFER_ADD = tap_get_tms_path(tap_get_state(), TAP_IRSHIFT);
</I>&gt;<i> +			tap_set_state(TAP_IRSHIFT);
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			BUFFER_ADD = TAP_MOVE(cur_state, TAP_DRSHIFT);
</I>&gt;<i> -			cur_state = TAP_DRSHIFT;
</I>&gt;<i> +			BUFFER_ADD = tap_get_tms_path(tap_get_state(), TAP_DRSHIFT);
</I>&gt;<i> +			tap_set_state(TAP_DRSHIFT);
</I>&gt;<i> 		}
</I>&gt;<i> 		/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
</I>&gt;<i> 	}
</I>&gt;<i> @@ -606,14 +634,16 @@
</I>&gt;<i> 			BUFFER_ADD = 0x28;
</I>&gt;<i> 			/* LOG_DEBUG(&quot;added TDI bytes (i %i)&quot;, num_bytes); */
</I>&gt;<i> 		}
</I>&gt;<i> +
</I>&gt;<i> 		thisrun_bytes = (num_bytes &gt; 65537) ? 65536 : (num_bytes - 1);
</I>&gt;<i> -		num_bytes -= thisrun_bytes;
</I>&gt;<i> -		BUFFER_ADD = (thisrun_bytes - 1) &amp; 0xff;
</I>&gt;<i> -		BUFFER_ADD = ((thisrun_bytes - 1) &gt;&gt; 8) &amp; 0xff;
</I>&gt;<i> +		num_bytes    -= thisrun_bytes;
</I>&gt;<i> +		BUFFER_ADD    = (thisrun_bytes - 1) &amp; 0xff;
</I>&gt;<i> +		BUFFER_ADD    = ( (thisrun_bytes - 1) &gt;&gt; 8 ) &amp; 0xff;
</I>&gt;<i> +
</I>&gt;<i> 		if (type != SCAN_IN)
</I>&gt;<i> 		{
</I>&gt;<i> 			/* add complete bytes */
</I>&gt;<i> -			while(thisrun_bytes-- &gt; 0)
</I>&gt;<i> +			while (thisrun_bytes-- &gt; 0)
</I>&gt;<i> 			{
</I>&gt;<i> 				BUFFER_ADD = buffer[cur_byte];
</I>&gt;<i> 				cur_byte++;
</I>&gt;<i> @@ -628,7 +658,7 @@
</I>&gt;<i>
</I>&gt;<i> 	/* the most signifcant bit is scanned during TAP movement */
</I>&gt;<i> 	if (type != SCAN_IN)
</I>&gt;<i> -		last_bit = (buffer[cur_byte] &gt;&gt; (bits_left - 1)) &amp; 0x1;
</I>&gt;<i> +		last_bit = ( buffer[cur_byte] &gt;&gt; (bits_left - 1) ) &amp; 0x1;
</I>&gt;<i> 	else
</I>&gt;<i> 		last_bit = 0;
</I>&gt;<i>
</I>&gt;<i> @@ -658,8 +688,8 @@
</I>&gt;<i> 			BUFFER_ADD = buffer[cur_byte];
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if ((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT)) ||
</I>&gt;<i> -		(!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT)))
</I>&gt;<i> +	if ( (  ir_scan &amp;&amp; (tap_get_end_state() == TAP_IRSHIFT) )
</I>&gt;<i> +	  || ( !ir_scan &amp;&amp; (tap_get_end_state() == TAP_DRSHIFT) ) )
</I>&gt;<i> 	{
</I>&gt;<i> 		if (type == SCAN_IO)
</I>&gt;<i> 		{
</I>&gt;<i> @@ -697,20 +727,22 @@
</I>&gt;<i> 			BUFFER_ADD = 0x4b;
</I>&gt;<i> 			/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
</I>&gt;<i> 		}
</I>&gt;<i> -		BUFFER_ADD = 0x6;
</I>&gt;<i> -		BUFFER_ADD = TAP_MOVE(cur_state, end_state) | (last_bit &lt;&lt; 7);
</I>&gt;<i> -		cur_state = end_state;
</I>&gt;<i> +		BUFFER_ADD = 0x6;   /* scan 7 bits */
</I>&gt;<i> +
</I>&gt;<i> +		BUFFER_ADD = tap_get_tms_path( tap_get_state(),  
</I>&gt;<i> tap_get_end_state() ) | (last_bit &lt;&lt; 7);
</I>&gt;<i> +		tap_set_state( tap_get_end_state() );
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_large_scan(scan_command_t *cmd, enum scan_type type, u8  
</I>&gt;<i> *buffer, int scan_size)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_large_scan(scan_command_t* cmd, enum scan_type type, u8*  
</I>&gt;<i> buffer, int scan_size)
</I>&gt;<i> {
</I>&gt;<i> 	int num_bytes = (scan_size + 7) / 8;
</I>&gt;<i> 	int bits_left = scan_size;
</I>&gt;<i> -	int cur_byte = 0;
</I>&gt;<i> +	int cur_byte  = 0;
</I>&gt;<i> 	int last_bit;
</I>&gt;<i> -	u8 *receive_buffer = malloc(CEIL(scan_size, 8));
</I>&gt;<i> -	u8 *receive_pointer = receive_buffer;
</I>&gt;<i> +	u8* receive_buffer  = malloc( CEIL(scan_size, 8) );
</I>&gt;<i> +	u8* receive_pointer = receive_buffer;
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i> 	u32 bytes_read;
</I>&gt;<i> 	int retval;
</I>&gt;<i> @@ -722,18 +754,19 @@
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if (cur_state != TAP_DRSHIFT)
</I>&gt;<i> +	if (tap_get_state() != TAP_DRSHIFT)
</I>&gt;<i> 	{
</I>&gt;<i> 		/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> 		BUFFER_ADD = 0x4b;
</I>&gt;<i> -		/* scan 7 bit */
</I>&gt;<i> -		BUFFER_ADD = 0x6;
</I>&gt;<i> +
</I>&gt;<i> +		BUFFER_ADD = 0x6;       /* scan 7 bits */
</I>&gt;<i> +
</I>&gt;<i> 		/* TMS data bits */
</I>&gt;<i> -		BUFFER_ADD = TAP_MOVE(cur_state, TAP_DRSHIFT);
</I>&gt;<i> -		cur_state = TAP_DRSHIFT;
</I>&gt;<i> +		BUFFER_ADD = tap_get_tms_path(tap_get_state(), TAP_DRSHIFT);
</I>&gt;<i> +		tap_set_state(TAP_DRSHIFT);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size,  
</I>&gt;<i> &amp;bytes_written)) != ERROR_OK)
</I>&gt;<i> +	if ( ( retval = ft2232_write(ft2232_buffer, ft2232_buffer_size,  
</I>&gt;<i> &amp;bytes_written) ) != ERROR_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> @@ -764,15 +797,17 @@
</I>&gt;<i> 			BUFFER_ADD = 0x28;
</I>&gt;<i> 			/* LOG_DEBUG(&quot;added TDI bytes (i %i)&quot;, num_bytes); */
</I>&gt;<i> 		}
</I>&gt;<i> +
</I>&gt;<i> 		thisrun_bytes = (num_bytes &gt; 65537) ? 65536 : (num_bytes - 1);
</I>&gt;<i> -		thisrun_read = thisrun_bytes;
</I>&gt;<i> -		num_bytes -= thisrun_bytes;
</I>&gt;<i> -		BUFFER_ADD = (thisrun_bytes - 1) &amp; 0xff;
</I>&gt;<i> -		BUFFER_ADD = ((thisrun_bytes - 1) &gt;&gt; 8) &amp; 0xff;
</I>&gt;<i> +		thisrun_read  = thisrun_bytes;
</I>&gt;<i> +		num_bytes    -= thisrun_bytes;
</I>&gt;<i> +		BUFFER_ADD    = (thisrun_bytes - 1) &amp; 0xff;
</I>&gt;<i> +		BUFFER_ADD    = ( (thisrun_bytes - 1) &gt;&gt; 8 ) &amp; 0xff;
</I>&gt;<i> +
</I>&gt;<i> 		if (type != SCAN_IN)
</I>&gt;<i> 		{
</I>&gt;<i> 			/* add complete bytes */
</I>&gt;<i> -			while(thisrun_bytes-- &gt; 0)
</I>&gt;<i> +			while (thisrun_bytes-- &gt; 0)
</I>&gt;<i> 			{
</I>&gt;<i> 				BUFFER_ADD = buffer[cur_byte];
</I>&gt;<i> 				cur_byte++;
</I>&gt;<i> @@ -784,7 +819,7 @@
</I>&gt;<i> 			bits_left -= 8 * (thisrun_bytes);
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> -		if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size,  
</I>&gt;<i> &amp;bytes_written)) != ERROR_OK)
</I>&gt;<i> +		if ( ( retval = ft2232_write(ft2232_buffer, ft2232_buffer_size,  
</I>&gt;<i> &amp;bytes_written) ) != ERROR_OK )
</I>&gt;<i> 		{
</I>&gt;<i> 			LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> @@ -794,7 +829,7 @@
</I>&gt;<i>
</I>&gt;<i> 		if (type != SCAN_OUT)
</I>&gt;<i> 		{
</I>&gt;<i> -			if ((retval = ft2232_read(receive_pointer, thisrun_read,  
</I>&gt;<i> &amp;bytes_read)) != ERROR_OK)
</I>&gt;<i> +			if ( ( retval = ft2232_read(receive_pointer, thisrun_read,  
</I>&gt;<i> &amp;bytes_read) ) != ERROR_OK )
</I>&gt;<i> 			{
</I>&gt;<i> 				LOG_ERROR(&quot;couldn't read from FT2232&quot;);
</I>&gt;<i> 				exit(-1);
</I>&gt;<i> @@ -808,7 +843,7 @@
</I>&gt;<i>
</I>&gt;<i> 	/* the most signifcant bit is scanned during TAP movement */
</I>&gt;<i> 	if (type != SCAN_IN)
</I>&gt;<i> -		last_bit = (buffer[cur_byte] &gt;&gt; (bits_left - 1)) &amp; 0x1;
</I>&gt;<i> +		last_bit = ( buffer[cur_byte] &gt;&gt; (bits_left - 1) ) &amp; 0x1;
</I>&gt;<i> 	else
</I>&gt;<i> 		last_bit = 0;
</I>&gt;<i>
</I>&gt;<i> @@ -841,7 +876,7 @@
</I>&gt;<i> 			thisrun_read += 2;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if (end_state == TAP_DRSHIFT)
</I>&gt;<i> +	if (tap_get_end_state() == TAP_DRSHIFT)
</I>&gt;<i> 	{
</I>&gt;<i> 		if (type == SCAN_IO)
</I>&gt;<i> 		{
</I>&gt;<i> @@ -880,14 +915,14 @@
</I>&gt;<i> 			/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
</I>&gt;<i> 		}
</I>&gt;<i> 		BUFFER_ADD = 0x6;
</I>&gt;<i> -		BUFFER_ADD = TAP_MOVE(cur_state, end_state) | (last_bit &lt;&lt; 7);
</I>&gt;<i> -		cur_state = end_state;
</I>&gt;<i> +		BUFFER_ADD = tap_get_tms_path( tap_get_state(),  
</I>&gt;<i> tap_get_end_state() ) | (last_bit &lt;&lt; 7);
</I>&gt;<i> +		tap_set_state( tap_get_end_state() );
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	if (type != SCAN_OUT)
</I>&gt;<i> 		thisrun_read += 1;
</I>&gt;<i>
</I>&gt;<i> -	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size,  
</I>&gt;<i> &amp;bytes_written)) != ERROR_OK)
</I>&gt;<i> +	if ( ( retval = ft2232_write(ft2232_buffer, ft2232_buffer_size,  
</I>&gt;<i> &amp;bytes_written) ) != ERROR_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> @@ -897,7 +932,7 @@
</I>&gt;<i>
</I>&gt;<i> 	if (type != SCAN_OUT)
</I>&gt;<i> 	{
</I>&gt;<i> -		if ((retval = ft2232_read(receive_pointer, thisrun_read,  
</I>&gt;<i> &amp;bytes_read)) != ERROR_OK)
</I>&gt;<i> +		if ( ( retval = ft2232_read(receive_pointer, thisrun_read,  
</I>&gt;<i> &amp;bytes_read) ) != ERROR_OK )
</I>&gt;<i> 		{
</I>&gt;<i> 			LOG_ERROR(&quot;couldn't read from FT2232&quot;);
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> @@ -909,32 +944,34 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int ft2232_predict_scan_out(int scan_size, enum scan_type type)
</I>&gt;<i> {
</I>&gt;<i> 	int predicted_size = 3;
</I>&gt;<i> 	int num_bytes = (scan_size - 1) / 8;
</I>&gt;<i>
</I>&gt;<i> -	if (cur_state != TAP_DRSHIFT)
</I>&gt;<i> +	if (tap_get_state() != TAP_DRSHIFT)
</I>&gt;<i> 		predicted_size += 3;
</I>&gt;<i>
</I>&gt;<i> -	if (type == SCAN_IN)	/* only from device to host */
</I>&gt;<i> +	if (type == SCAN_IN)    /* only from device to host */
</I>&gt;<i> 	{
</I>&gt;<i> 		/* complete bytes */
</I>&gt;<i> 		predicted_size += CEIL(num_bytes, 65536) * 3;
</I>&gt;<i> 		/* remaining bits - 1 (up to 7) */
</I>&gt;<i> -		predicted_size += ((scan_size - 1) % 8) ? 2 : 0;
</I>&gt;<i> +		predicted_size += ( (scan_size - 1) % 8 ) ? 2 : 0;
</I>&gt;<i> 	}
</I>&gt;<i> -	else					/* host to device, or bidirectional */
</I>&gt;<i> +	else                    /* host to device, or bidirectional */
</I>&gt;<i> 	{
</I>&gt;<i> 		/* complete bytes */
</I>&gt;<i> 		predicted_size += num_bytes + CEIL(num_bytes, 65536) * 3;
</I>&gt;<i> 		/* remaining bits -1 (up to 7) */
</I>&gt;<i> -		predicted_size += ((scan_size - 1) % 8) ? 3 : 0;
</I>&gt;<i> +		predicted_size += ( (scan_size - 1) % 8 ) ? 3 : 0;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	return predicted_size;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int ft2232_predict_scan_in(int scan_size, enum scan_type type)
</I>&gt;<i> {
</I>&gt;<i> 	int predicted_size = 0;
</I>&gt;<i> @@ -943,8 +980,10 @@
</I>&gt;<i> 	{
</I>&gt;<i> 		/* complete bytes */
</I>&gt;<i> 		predicted_size += (CEIL(scan_size, 8) &gt; 1) ? (CEIL(scan_size, 8) -  
</I>&gt;<i> 1) : 0;
</I>&gt;<i> +
</I>&gt;<i> 		/* remaining bits - 1 */
</I>&gt;<i> -		predicted_size += ((scan_size - 1) % 8) ? 1 : 0;
</I>&gt;<i> +		predicted_size += ( (scan_size - 1) % 8 ) ? 1 : 0;
</I>&gt;<i> +
</I>&gt;<i> 		/* last bit (from TMS scan) */
</I>&gt;<i> 		predicted_size += 1;
</I>&gt;<i> 	}
</I>&gt;<i> @@ -954,45 +993,46 @@
</I>&gt;<i> 	return predicted_size;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void usbjtag_reset(int trst, int srst)
</I>&gt;<i> {
</I>&gt;<i> 	if (trst == 1)
</I>&gt;<i> 	{
</I>&gt;<i> 		if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
</I>&gt;<i> -			low_direction |= nTRSTnOE;	/* switch to output pin (output is  
</I>&gt;<i> low) */
</I>&gt;<i> +			low_direction |= nTRSTnOE;  /* switch to output pin (output is  
</I>&gt;<i> low) */
</I>&gt;<i> 		else
</I>&gt;<i> -			low_output &amp;= ~nTRST;	/* switch output low */
</I>&gt;<i> +			low_output &amp;= ~nTRST;       /* switch output low */
</I>&gt;<i> 	}
</I>&gt;<i> 	else if (trst == 0)
</I>&gt;<i> 	{
</I>&gt;<i> 		if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
</I>&gt;<i> 			low_direction &amp;= ~nTRSTnOE; /* switch to input pin (high-Z +  
</I>&gt;<i> internal and external pullup) */
</I>&gt;<i> 		else
</I>&gt;<i> -			low_output |= nTRST; /* switch output high */
</I>&gt;<i> +			low_output |= nTRST;        /* switch output high */
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	if (srst == 1)
</I>&gt;<i> 	{
</I>&gt;<i> 		if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
</I>&gt;<i> -			low_output &amp;= ~nSRST;	/* switch output low */
</I>&gt;<i> +			low_output &amp;= ~nSRST;       /* switch output low */
</I>&gt;<i> 		else
</I>&gt;<i> -			low_direction |= nSRSTnOE;	/* switch to output pin (output is  
</I>&gt;<i> low) */
</I>&gt;<i> +			low_direction |= nSRSTnOE;  /* switch to output pin (output is  
</I>&gt;<i> low) */
</I>&gt;<i> 	}
</I>&gt;<i> 	else if (srst == 0)
</I>&gt;<i> 	{
</I>&gt;<i> 		if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
</I>&gt;<i> -			low_output |= nSRST;	/* switch output high */
</I>&gt;<i> +			low_output |= nSRST;        /* switch output high */
</I>&gt;<i> 		else
</I>&gt;<i> -			low_direction &amp;= ~nSRSTnOE;	/* switch to input pin (high-Z) */
</I>&gt;<i> +			low_direction &amp;= ~nSRSTnOE; /* switch to input pin (high-Z) */
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	/* command &quot;set data bits low byte&quot; */
</I>&gt;<i> 	BUFFER_ADD = 0x80;
</I>&gt;<i> 	BUFFER_ADD = low_output;
</I>&gt;<i> 	BUFFER_ADD = low_direction;
</I>&gt;<i> -
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void jtagkey_reset(int trst, int srst)
</I>&gt;<i> {
</I>&gt;<i> 	if (trst == 1)
</I>&gt;<i> @@ -1029,9 +1069,11 @@
</I>&gt;<i> 	BUFFER_ADD = 0x82;
</I>&gt;<i> 	BUFFER_ADD = high_output;
</I>&gt;<i> 	BUFFER_ADD = high_direction;
</I>&gt;<i> -	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
</I>&gt;<i> +	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output,
</I>&gt;<i> +			high_direction);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void olimex_jtag_reset(int trst, int srst)
</I>&gt;<i> {
</I>&gt;<i> 	if (trst == 1)
</I>&gt;<i> @@ -1062,14 +1104,16 @@
</I>&gt;<i> 	BUFFER_ADD = 0x82;
</I>&gt;<i> 	BUFFER_ADD = high_output;
</I>&gt;<i> 	BUFFER_ADD = high_direction;
</I>&gt;<i> -	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
</I>&gt;<i> +	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output,
</I>&gt;<i> +			high_direction);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void axm0432_jtag_reset(int trst, int srst)
</I>&gt;<i> {
</I>&gt;<i> 	if (trst == 1)
</I>&gt;<i> 	{
</I>&gt;<i> -		cur_state = TAP_RESET;
</I>&gt;<i> +		tap_set_state(TAP_RESET);
</I>&gt;<i> 		high_output &amp;= ~nTRST;
</I>&gt;<i> 	}
</I>&gt;<i> 	else if (trst == 0)
</I>&gt;<i> @@ -1090,9 +1134,11 @@
</I>&gt;<i> 	BUFFER_ADD = 0x82;
</I>&gt;<i> 	BUFFER_ADD = high_output;
</I>&gt;<i> 	BUFFER_ADD = high_direction;
</I>&gt;<i> -	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
</I>&gt;<i> +	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output,
</I>&gt;<i> +			high_direction);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void flyswatter_reset(int trst, int srst)
</I>&gt;<i> {
</I>&gt;<i> 	if (trst == 1)
</I>&gt;<i> @@ -1120,6 +1166,7 @@
</I>&gt;<i> 	LOG_DEBUG(&quot;trst: %i, srst: %i, low_output: 0x%2.2x, low_direction:  
</I>&gt;<i> 0x%2.2x&quot;, trst, srst, low_output, low_direction);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void turtle_reset(int trst, int srst)
</I>&gt;<i> {
</I>&gt;<i> 	trst = trst;
</I>&gt;<i> @@ -1140,6 +1187,7 @@
</I>&gt;<i> 	LOG_DEBUG(&quot;srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x&quot;,  
</I>&gt;<i> srst, low_output, low_direction);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void comstick_reset(int trst, int srst)
</I>&gt;<i> {
</I>&gt;<i> 	if (trst == 1)
</I>&gt;<i> @@ -1164,9 +1212,11 @@
</I>&gt;<i> 	BUFFER_ADD = 0x82;
</I>&gt;<i> 	BUFFER_ADD = high_output;
</I>&gt;<i> 	BUFFER_ADD = high_direction;
</I>&gt;<i> -	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
</I>&gt;<i> +	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output,
</I>&gt;<i> +			high_direction);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void stm32stick_reset(int trst, int srst)
</I>&gt;<i> {
</I>&gt;<i> 	if (trst == 1)
</I>&gt;<i> @@ -1196,20 +1246,22 @@
</I>&gt;<i> 	BUFFER_ADD = 0x82;
</I>&gt;<i> 	BUFFER_ADD = high_output;
</I>&gt;<i> 	BUFFER_ADD = high_direction;
</I>&gt;<i> -	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
</I>&gt;<i> +	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x,  
</I>&gt;<i> high_direction: 0x%2.2x&quot;, trst, srst, high_output,
</I>&gt;<i> +			high_direction);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int ft2232_execute_queue()
</I>&gt;<i> {
</I>&gt;<i> -	jtag_command_t *cmd = jtag_command_queue; /* currently processed  
</I>&gt;<i> command */
</I>&gt;<i> -	u8 *buffer;
</I>&gt;<i> -	int scan_size;	/* size of IR or DR scan */
</I>&gt;<i> -	enum scan_type type;
</I>&gt;<i> -	int i;
</I>&gt;<i> -	int predicted_size = 0;
</I>&gt;<i> -	int retval;
</I>&gt;<i> +	jtag_command_t* cmd = jtag_command_queue;   /* currently processed  
</I>&gt;<i> command */
</I>&gt;<i> +	u8*             buffer;
</I>&gt;<i> +	int             scan_size;                  /* size of IR or DR  
</I>&gt;<i> scan */
</I>&gt;<i> +	enum scan_type  type;
</I>&gt;<i> +	int             i;
</I>&gt;<i> +	int             predicted_size = 0;
</I>&gt;<i> +	int             retval;
</I>&gt;<i>
</I>&gt;<i> -	first_unsent = cmd;			/* next command that has to be sent */
</I>&gt;<i> +	first_unsent = cmd;         /* next command that has to be sent */
</I>&gt;<i> 	require_send = 0;
</I>&gt;<i>
</I>&gt;<i> 	/* return ERROR_OK, unless ft2232_send_and_recv reports a failed  
</I>&gt;<i> check
</I>&gt;<i> @@ -1226,209 +1278,219 @@
</I>&gt;<i>
</I>&gt;<i> 	while (cmd)
</I>&gt;<i> 	{
</I>&gt;<i> -		switch(cmd-&gt;type)
</I>&gt;<i> +		switch (cmd-&gt;type)
</I>&gt;<i> 		{
</I>&gt;<i> -			case JTAG_END_STATE:
</I>&gt;<i> -				if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
</I>&gt;<i> -					ft2232_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
</I>&gt;<i> -				break;
</I>&gt;<i> +		case JTAG_END_STATE:
</I>&gt;<i> +			if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
</I>&gt;<i> +				ft2232_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_RESET:
</I>&gt;<i> -				/* only send the maximum buffer size that FT2232C can handle */
</I>&gt;<i> -				predicted_size = 3;
</I>&gt;<i> -				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> -				{
</I>&gt;<i> -					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> -						retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> -					require_send = 0;
</I>&gt;<i> -					first_unsent = cmd;
</I>&gt;<i> -				}
</I>&gt;<i> +		case JTAG_RESET:
</I>&gt;<i> +			/* only send the maximum buffer size that FT2232C can handle */
</I>&gt;<i> +			predicted_size = 3;
</I>&gt;<i> +			if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> +			{
</I>&gt;<i> +				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> +					retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +				require_send = 0;
</I>&gt;<i> +				first_unsent = cmd;
</I>&gt;<i> +			}
</I>&gt;<i>
</I>&gt;<i> -				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp;  
</I>&gt;<i> (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
</I>&gt;<i> -				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> -				}
</I>&gt;<i> -				layout-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i> -				require_send = 1;
</I>&gt;<i> +			if ( (cmd-&gt;cmd.reset-&gt;trst == 1) || ( cmd-&gt;cmd.reset-&gt;srst &amp;&amp;  
</I>&gt;<i> (jtag_reset_config &amp; RESET_SRST_PULLS_TRST) ) )
</I>&gt;<i> +			{
</I>&gt;<i> +				tap_set_state(TAP_RESET);
</I>&gt;<i> +			}
</I>&gt;<i> +			layout-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i> +			require_send = 1;
</I>&gt;<i>
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd- 
</I>&gt;<i> &gt;cmd.reset-&gt;srst);
</I>&gt;<i> +			LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd- 
</I>&gt;<i> &gt;cmd.reset-&gt;srst);
</I>&gt;<i> #endif
</I>&gt;<i> -				break;
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_RUNTEST:
</I>&gt;<i> -				/* only send the maximum buffer size that FT2232C can handle */
</I>&gt;<i> -				predicted_size = 0;
</I>&gt;<i> -				if (cur_state != TAP_IDLE)
</I>&gt;<i> -					predicted_size += 3;
</I>&gt;<i> -				predicted_size += 3 * CEIL(cmd-&gt;cmd.runtest-&gt;num_cycles, 7);
</I>&gt;<i> -				if ((cmd-&gt;cmd.runtest-&gt;end_state != -1) &amp;&amp; (cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;end_state != TAP_IDLE))
</I>&gt;<i> -					predicted_size += 3;
</I>&gt;<i> -				if ((cmd-&gt;cmd.runtest-&gt;end_state == -1) &amp;&amp; (end_state !=  
</I>&gt;<i> TAP_IDLE))
</I>&gt;<i> -					predicted_size += 3;
</I>&gt;<i> -				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> -				{
</I>&gt;<i> -					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> -						retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> -					require_send = 0;
</I>&gt;<i> -					first_unsent = cmd;
</I>&gt;<i> -				}
</I>&gt;<i> -				if (cur_state != TAP_IDLE)
</I>&gt;<i> -				{
</I>&gt;<i> -					/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> -					BUFFER_ADD = 0x4b;
</I>&gt;<i> -					/* scan 7 bit */
</I>&gt;<i> -					BUFFER_ADD = 0x6;
</I>&gt;<i> -					/* TMS data bits */
</I>&gt;<i> -					BUFFER_ADD = TAP_MOVE(cur_state, TAP_IDLE);
</I>&gt;<i> -					cur_state = TAP_IDLE;
</I>&gt;<i> -					require_send = 1;
</I>&gt;<i> -				}
</I>&gt;<i> -				i = cmd-&gt;cmd.runtest-&gt;num_cycles;
</I>&gt;<i> -				while (i &gt; 0)
</I>&gt;<i> -				{
</I>&gt;<i> -					/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> -					BUFFER_ADD = 0x4b;
</I>&gt;<i> -					/* scan 7 bit */
</I>&gt;<i> -					BUFFER_ADD = (i &gt; 7) ? 6 : (i - 1);
</I>&gt;<i> -					/* TMS data bits */
</I>&gt;<i> -					BUFFER_ADD = 0x0;
</I>&gt;<i> -					cur_state = TAP_IDLE;
</I>&gt;<i> -					i -= (i &gt; 7) ? 7 : i;
</I>&gt;<i> -					/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
</I>&gt;<i> -				}
</I>&gt;<i> -				if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
</I>&gt;<i> -					ft2232_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
</I>&gt;<i> -				if (cur_state != end_state)
</I>&gt;<i> -				{
</I>&gt;<i> -					/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> -					BUFFER_ADD = 0x4b;
</I>&gt;<i> -					/* scan 7 bit */
</I>&gt;<i> -					BUFFER_ADD = 0x6;
</I>&gt;<i> -					/* TMS data bits */
</I>&gt;<i> -					BUFFER_ADD = TAP_MOVE(cur_state, end_state);
</I>&gt;<i> -					cur_state = end_state;
</I>&gt;<i> -					/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
</I>&gt;<i> -				}
</I>&gt;<i> +		case JTAG_RUNTEST:
</I>&gt;<i> +			/* only send the maximum buffer size that FT2232C can handle */
</I>&gt;<i> +			predicted_size = 0;
</I>&gt;<i> +			if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> +				predicted_size += 3;
</I>&gt;<i> +			predicted_size += 3 * CEIL(cmd-&gt;cmd.runtest-&gt;num_cycles, 7);
</I>&gt;<i> +			if ( (cmd-&gt;cmd.runtest-&gt;end_state != -1) &amp;&amp; (cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;end_state != TAP_IDLE) )
</I>&gt;<i> +				predicted_size += 3;
</I>&gt;<i> +			if ( (cmd-&gt;cmd.runtest-&gt;end_state == -1) &amp;&amp;  
</I>&gt;<i> (tap_get_end_state() != TAP_IDLE) )
</I>&gt;<i> +				predicted_size += 3;
</I>&gt;<i> +			if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> +			{
</I>&gt;<i> +				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> +					retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +				require_send = 0;
</I>&gt;<i> +				first_unsent = cmd;
</I>&gt;<i> +			}
</I>&gt;<i> +			if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> +			{
</I>&gt;<i> +				/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> +				BUFFER_ADD = 0x4b;
</I>&gt;<i> +				BUFFER_ADD = 0x6;    /* scan 7 bits */
</I>&gt;<i> +
</I>&gt;<i> +				/* TMS data bits */
</I>&gt;<i> +				BUFFER_ADD = tap_get_tms_path(tap_get_state(), TAP_IDLE);
</I>&gt;<i> +				tap_set_state(TAP_IDLE);
</I>&gt;<i> 				require_send = 1;
</I>&gt;<i> -#ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;runtest: %i, end in %s&quot;, cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;num_cycles, jtag_state_name(end_state));
</I>&gt;<i> -#endif
</I>&gt;<i> -				break;
</I>&gt;<i> +			}
</I>&gt;<i> +			i = cmd-&gt;cmd.runtest-&gt;num_cycles;
</I>&gt;<i> +			while (i &gt; 0)
</I>&gt;<i> +			{
</I>&gt;<i> +				/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> +				BUFFER_ADD = 0x4b;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_STATEMOVE:
</I>&gt;<i> -				/* only send the maximum buffer size that FT2232C can handle */
</I>&gt;<i> -				predicted_size = 3;
</I>&gt;<i> -				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> -				{
</I>&gt;<i> -					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> -						retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> -					require_send = 0;
</I>&gt;<i> -					first_unsent = cmd;
</I>&gt;<i> -				}
</I>&gt;<i> -				if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
</I>&gt;<i> -					ft2232_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
</I>&gt;<i> +				/* scan 7 bits */
</I>&gt;<i> +				BUFFER_ADD = (i &gt; 7) ? 6 : (i - 1);
</I>&gt;<i> +
</I>&gt;<i> +				/* TMS data bits */
</I>&gt;<i> +				BUFFER_ADD = 0x0;
</I>&gt;<i> +				tap_set_state(TAP_IDLE);
</I>&gt;<i> +				i -= (i &gt; 7) ? 7 : i;
</I>&gt;<i> +				/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
</I>&gt;<i> +				ft2232_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
</I>&gt;<i> +
</I>&gt;<i> +			if ( tap_get_state() != tap_get_end_state() )
</I>&gt;<i> +			{
</I>&gt;<i> 				/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> 				BUFFER_ADD = 0x4b;
</I>&gt;<i> 				/* scan 7 bit */
</I>&gt;<i> 				BUFFER_ADD = 0x6;
</I>&gt;<i> 				/* TMS data bits */
</I>&gt;<i> -				BUFFER_ADD = TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +				BUFFER_ADD = tap_get_tms_path( tap_get_state(),  
</I>&gt;<i> tap_get_end_state() );
</I>&gt;<i> +				tap_set_state( tap_get_end_state() );
</I>&gt;<i> 				/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
</I>&gt;<i> -				cur_state = end_state;
</I>&gt;<i> -				require_send = 1;
</I>&gt;<i> +			}
</I>&gt;<i> +			require_send = 1;
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;statemove: %s&quot;, jtag_state_name(end_state));
</I>&gt;<i> +			LOG_DEBUG( &quot;runtest: %i, end in %s&quot;, cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;num_cycles, tap_state_name( tap_get_end_state() ) );
</I>&gt;<i> #endif
</I>&gt;<i> -				break;
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_PATHMOVE:
</I>&gt;<i> -				/* only send the maximum buffer size that FT2232C can handle */
</I>&gt;<i> -				predicted_size = 3 * CEIL(cmd-&gt;cmd.pathmove-&gt;num_states, 7);
</I>&gt;<i> -				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> -				{
</I>&gt;<i> -					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> -						retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> -					require_send = 0;
</I>&gt;<i> -					first_unsent = cmd;
</I>&gt;<i> -				}
</I>&gt;<i> -				ft2232_add_pathmove(cmd-&gt;cmd.pathmove);
</I>&gt;<i> -				require_send = 1;
</I>&gt;<i> +		case JTAG_STATEMOVE:
</I>&gt;<i> +			/* only send the maximum buffer size that FT2232C can handle */
</I>&gt;<i> +			predicted_size = 3;
</I>&gt;<i> +			if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> +			{
</I>&gt;<i> +				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> +					retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +				require_send = 0;
</I>&gt;<i> +				first_unsent = cmd;
</I>&gt;<i> +			}
</I>&gt;<i> +			if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
</I>&gt;<i> +				ft2232_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
</I>&gt;<i> +
</I>&gt;<i> +			/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
</I>&gt;<i> +			BUFFER_ADD = 0x4b;
</I>&gt;<i> +
</I>&gt;<i> +			BUFFER_ADD = 0x6;       /* scan 7 bits */
</I>&gt;<i> +
</I>&gt;<i> +			/* TMS data bits */
</I>&gt;<i> +			BUFFER_ADD = tap_get_tms_path( tap_get_state(),  
</I>&gt;<i> tap_get_end_state() );
</I>&gt;<i> +			/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
</I>&gt;<i> +			tap_set_state( tap_get_end_state() );
</I>&gt;<i> +			require_send = 1;
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;pathmove: %i states, end in %s&quot;, cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states,
</I>&gt;<i> -					jtag_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states - 1]));
</I>&gt;<i> +			LOG_DEBUG( &quot;statemove: %s&quot;,  
</I>&gt;<i> tap_state_name( tap_get_end_state() ) );
</I>&gt;<i> #endif
</I>&gt;<i> -				break;
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_SCAN:
</I>&gt;<i> -				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
</I>&gt;<i> -				type = jtag_scan_type(cmd-&gt;cmd.scan);
</I>&gt;<i> -				predicted_size = ft2232_predict_scan_out(scan_size, type);
</I>&gt;<i> -				if ((predicted_size + 1) &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> -				{
</I>&gt;<i> -					LOG_DEBUG(&quot;oversized ft2232 scan (predicted_size &gt;  
</I>&gt;<i> FT2232_BUFFER_SIZE)&quot;);
</I>&gt;<i> -					/* unsent commands before this */
</I>&gt;<i> -					if (first_unsent != cmd)
</I>&gt;<i> -						if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> -							retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +		case JTAG_PATHMOVE:
</I>&gt;<i> +			/* only send the maximum buffer size that FT2232C can handle */
</I>&gt;<i> +			predicted_size = 3 * CEIL(cmd-&gt;cmd.pathmove-&gt;num_states, 7);
</I>&gt;<i> +			if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
</I>&gt;<i> +			{
</I>&gt;<i> +				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> +					retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +				require_send = 0;
</I>&gt;<i> +				first_unsent = cmd;
</I>&gt;<i> +			}
</I>&gt;<i> +			ft2232_add_pathmove(cmd-&gt;cmd.pathmove);
</I>&gt;<i> +			require_send = 1;
</I>&gt;<i> +#ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> +			LOG_DEBUG( &quot;pathmove: %i states, end in %s&quot;, cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states,
</I>&gt;<i> +					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states - 1]) );
</I>&gt;<i> +#endif
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -					/* current command */
</I>&gt;<i> -					if (cmd-&gt;cmd.scan-&gt;end_state != -1)
</I>&gt;<i> -						ft2232_end_state(cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> -					ft2232_large_scan(cmd-&gt;cmd.scan, type, buffer, scan_size);
</I>&gt;<i> -					require_send = 0;
</I>&gt;<i> -					first_unsent = cmd-&gt;next;
</I>&gt;<i> -					if (buffer)
</I>&gt;<i> -						free(buffer);
</I>&gt;<i> -					break;
</I>&gt;<i> -				}
</I>&gt;<i> -				else if (ft2232_buffer_size + predicted_size + 1 &gt;  
</I>&gt;<i> FT2232_BUFFER_SIZE)
</I>&gt;<i> -				{
</I>&gt;<i> -					LOG_DEBUG(&quot;ft2232 buffer size reached, sending queued commands  
</I>&gt;<i> (first_unsent: %p, cmd: %p)&quot;, first_unsent, cmd);
</I>&gt;<i> +		case JTAG_SCAN:
</I>&gt;<i> +			scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
</I>&gt;<i> +			type = jtag_scan_type(cmd-&gt;cmd.scan);
</I>&gt;<i> +			predicted_size = ft2232_predict_scan_out(scan_size, type);
</I>&gt;<i> +			if ( (predicted_size + 1) &gt; FT2232_BUFFER_SIZE )
</I>&gt;<i> +			{
</I>&gt;<i> +				LOG_DEBUG(&quot;oversized ft2232 scan (predicted_size &gt;  
</I>&gt;<i> FT2232_BUFFER_SIZE)&quot;);
</I>&gt;<i> +				/* unsent commands before this */
</I>&gt;<i> +				if (first_unsent != cmd)
</I>&gt;<i> 					if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> 						retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> -					require_send = 0;
</I>&gt;<i> -					first_unsent = cmd;
</I>&gt;<i> -				}
</I>&gt;<i> -				ft2232_expect_read += ft2232_predict_scan_in(scan_size, type);
</I>&gt;<i> -				/* LOG_DEBUG(&quot;new read size: %i&quot;, ft2232_expect_read); */
</I>&gt;<i> +
</I>&gt;<i> +				/* current command */
</I>&gt;<i> 				if (cmd-&gt;cmd.scan-&gt;end_state != -1)
</I>&gt;<i> 					ft2232_end_state(cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> -				ft2232_add_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size);
</I>&gt;<i> -				require_send = 1;
</I>&gt;<i> +				ft2232_large_scan(cmd-&gt;cmd.scan, type, buffer, scan_size);
</I>&gt;<i> +				require_send = 0;
</I>&gt;<i> +				first_unsent = cmd-&gt;next;
</I>&gt;<i> 				if (buffer)
</I>&gt;<i> 					free(buffer);
</I>&gt;<i> -#ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;%s scan, %i bits, end in %s&quot;, (cmd-&gt;cmd.scan- 
</I>&gt;<i> &gt;ir_scan) ? &quot;IR&quot; : &quot;DR&quot;, scan_size,
</I>&gt;<i> -					jtag_state_name(end_state));
</I>&gt;<i> -#endif
</I>&gt;<i> 				break;
</I>&gt;<i> -
</I>&gt;<i> -			case JTAG_SLEEP:
</I>&gt;<i> +			}
</I>&gt;<i> +			else if (ft2232_buffer_size + predicted_size + 1 &gt;  
</I>&gt;<i> FT2232_BUFFER_SIZE)
</I>&gt;<i> +			{
</I>&gt;<i> +				LOG_DEBUG(&quot;ft2232 buffer size reached, sending queued commands  
</I>&gt;<i> (first_unsent: %p, cmd: %p)&quot;,
</I>&gt;<i> +						first_unsent,
</I>&gt;<i> +						cmd);
</I>&gt;<i> 				if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> 					retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> -				first_unsent = cmd-&gt;next;
</I>&gt;<i> -				jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
</I>&gt;<i> +				require_send = 0;
</I>&gt;<i> +				first_unsent = cmd;
</I>&gt;<i> +			}
</I>&gt;<i> +			ft2232_expect_read += ft2232_predict_scan_in(scan_size, type);
</I>&gt;<i> +			/* LOG_DEBUG(&quot;new read size: %i&quot;, ft2232_expect_read); */
</I>&gt;<i> +			if (cmd-&gt;cmd.scan-&gt;end_state != -1)
</I>&gt;<i> +				ft2232_end_state(cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> +			ft2232_add_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size);
</I>&gt;<i> +			require_send = 1;
</I>&gt;<i> +			if (buffer)
</I>&gt;<i> +				free(buffer);
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;sleep %i usec while in %s&quot;, cmd-&gt;cmd.sleep-&gt;us,  
</I>&gt;<i> jtag_state_name(cur_state));
</I>&gt;<i> +			LOG_DEBUG( &quot;%s scan, %i bits, end in %s&quot;, (cmd-&gt;cmd.scan- 
</I>&gt;<i> &gt;ir_scan) ? &quot;IR&quot; : &quot;DR&quot;, scan_size,
</I>&gt;<i> +					tap_state_name( tap_get_end_state() ) );
</I>&gt;<i> #endif
</I>&gt;<i> -				break;
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			case JTAG_STABLECLOCKS:
</I>&gt;<i> -				/* this is only allowed while in a stable state.  A check for a  
</I>&gt;<i> stable
</I>&gt;<i> -				 * state was done in jtag_add_clocks()
</I>&gt;<i> -				 */
</I>&gt;<i> -				if (ft2232_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles,  
</I>&gt;<i> cmd) != ERROR_OK)
</I>&gt;<i> -					retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +		case JTAG_SLEEP:
</I>&gt;<i> +			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
</I>&gt;<i> +				retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +			first_unsent = cmd-&gt;next;
</I>&gt;<i> +			jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> -				LOG_DEBUG(&quot;clocks %i while in %s&quot;, cmd-&gt;cmd.stableclocks- 
</I>&gt;<i> &gt;num_cycles, jtag_state_name(cur_state));
</I>&gt;<i> +			LOG_DEBUG( &quot;sleep %i usec while in %s&quot;, cmd-&gt;cmd.sleep-&gt;us,  
</I>&gt;<i> tap_state_name( tap_get_state() ) );
</I>&gt;<i> #endif
</I>&gt;<i> -				break;
</I>&gt;<i> +			break;
</I>&gt;<i>
</I>&gt;<i> -			default:
</I>&gt;<i> -				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
</I>&gt;<i> -				exit(-1);
</I>&gt;<i> +		case JTAG_STABLECLOCKS:
</I>&gt;<i> +
</I>&gt;<i> +			/* this is only allowed while in a stable state.  A check for a  
</I>&gt;<i> stable
</I>&gt;<i> +			 * state was done in jtag_add_clocks()
</I>&gt;<i> +			 */
</I>&gt;<i> +			if (ft2232_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, cmd) ! 
</I>&gt;<i> = ERROR_OK)
</I>&gt;<i> +				retval = ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> +#ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> +			LOG_DEBUG( &quot;clocks %i while in %s&quot;, cmd-&gt;cmd.stableclocks- 
</I>&gt;<i> &gt;num_cycles, tap_state_name( tap_get_state() ) );
</I>&gt;<i> +#endif
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		default:
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
</I>&gt;<i> +			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i> +
</I>&gt;<i> 		cmd = cmd-&gt;next;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> @@ -1439,19 +1501,20 @@
</I>&gt;<i> 	return retval;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> #if BUILD_FT2232_FTD2XX == 1
</I>&gt;<i> -static int ft2232_init_ftd2xx(u16 vid, u16 pid, int more, int  
</I>&gt;<i> *try_more)
</I>&gt;<i> +static int ft2232_init_ftd2xx(u16 vid, u16 pid, int more, int*  
</I>&gt;<i> try_more)
</I>&gt;<i> {
</I>&gt;<i> 	FT_STATUS status;
</I>&gt;<i> -	DWORD openex_flags = 0;
</I>&gt;<i> -	char *openex_string = NULL;
</I>&gt;<i> -	u8 latency_timer;
</I>&gt;<i> +	DWORD     openex_flags  = 0;
</I>&gt;<i> +	char*     openex_string = NULL;
</I>&gt;<i> +	u8        latency_timer;
</I>&gt;<i>
</I>&gt;<i> -	LOG_DEBUG(&quot;'ft2232' interface using FTD2XX with '%s' layout (%4.4x: 
</I>&gt;<i> %4.4x)&quot;,ft2232_layout, vid, pid);
</I>&gt;<i> +	LOG_DEBUG(&quot;'ft2232' interface using FTD2XX with '%s' layout (%4.4x: 
</I>&gt;<i> %4.4x)&quot;, ft2232_layout, vid, pid);
</I>&gt;<i>
</I>&gt;<i> #if IS_WIN32 == 0
</I>&gt;<i> 	/* Add non-standard Vid/Pid to the linux driver */
</I>&gt;<i> -	if ((status = FT_SetVIDPID(vid, pid)) != FT_OK)
</I>&gt;<i> +	if ( ( status = FT_SetVIDPID(vid, pid) ) != FT_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_WARNING(&quot;couldn't add %4.4x:%4.4x&quot;, vid, pid);
</I>&gt;<i> 	}
</I>&gt;<i> @@ -1466,12 +1529,12 @@
</I>&gt;<i> 	if (ft2232_device_desc)
</I>&gt;<i> 	{
</I>&gt;<i> 		openex_string = ft2232_device_desc;
</I>&gt;<i> -		openex_flags = FT_OPEN_BY_DESCRIPTION;
</I>&gt;<i> +		openex_flags  = FT_OPEN_BY_DESCRIPTION;
</I>&gt;<i> 	}
</I>&gt;<i> 	else if (ft2232_serial)
</I>&gt;<i> 	{
</I>&gt;<i> 		openex_string = ft2232_serial;
</I>&gt;<i> -		openex_flags = FT_OPEN_BY_SERIAL_NUMBER;
</I>&gt;<i> +		openex_flags  = FT_OPEN_BY_SERIAL_NUMBER;
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> @@ -1481,11 +1544,12 @@
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if ((status = FT_OpenEx(openex_string, openex_flags, &amp;ftdih)) !=  
</I>&gt;<i> FT_OK)
</I>&gt;<i> +	if ( ( status = FT_OpenEx(openex_string, openex_flags, &amp;ftdih) ) ! 
</I>&gt;<i> = FT_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		DWORD num_devices;
</I>&gt;<i>
</I>&gt;<i> -		if (more) {
</I>&gt;<i> +		if (more)
</I>&gt;<i> +		{
</I>&gt;<i> 			LOG_WARNING(&quot;unable to open ftdi device (trying more): %lu&quot;,  
</I>&gt;<i> status);
</I>&gt;<i> 			*try_more = 1;
</I>&gt;<i> 			return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1494,11 +1558,12 @@
</I>&gt;<i> 		status = FT_ListDevices(&amp;num_devices, NULL, FT_LIST_NUMBER_ONLY);
</I>&gt;<i> 		if (status == FT_OK)
</I>&gt;<i> 		{
</I>&gt;<i> -			char **desc_array = malloc(sizeof(char*) * (num_devices + 1));
</I>&gt;<i> -			int i;
</I>&gt;<i> +			char** desc_array = malloc( sizeof(char*) * (num_devices + 1) );
</I>&gt;<i> +			int    i;
</I>&gt;<i>
</I>&gt;<i> 			for (i = 0; i &lt; num_devices; i++)
</I>&gt;<i> 				desc_array[i] = malloc(64);
</I>&gt;<i> +
</I>&gt;<i> 			desc_array[num_devices] = NULL;
</I>&gt;<i>
</I>&gt;<i> 			status = FT_ListDevices(desc_array, &amp;num_devices, FT_LIST_ALL |  
</I>&gt;<i> openex_flags);
</I>&gt;<i> @@ -1512,6 +1577,7 @@
</I>&gt;<i>
</I>&gt;<i> 			for (i = 0; i &lt; num_devices; i++)
</I>&gt;<i> 				free(desc_array[i]);
</I>&gt;<i> +
</I>&gt;<i> 			free(desc_array);
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> @@ -1521,13 +1587,13 @@
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if ((status = FT_SetLatencyTimer(ftdih, ft2232_latency)) != FT_OK)
</I>&gt;<i> +	if ( ( status = FT_SetLatencyTimer(ftdih, ft2232_latency) ) !=  
</I>&gt;<i> FT_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;unable to set latency timer: %lu&quot;, status);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if ((status = FT_GetLatencyTimer(ftdih, &amp;latency_timer)) != FT_OK)
</I>&gt;<i> +	if ( ( status = FT_GetLatencyTimer(ftdih, &amp;latency_timer) ) !=  
</I>&gt;<i> FT_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;unable to get latency timer: %lu&quot;, status);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1537,13 +1603,13 @@
</I>&gt;<i> 		LOG_DEBUG(&quot;current latency timer: %i&quot;, latency_timer);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if ((status = FT_SetTimeouts(ftdih, 5000, 5000)) != FT_OK)
</I>&gt;<i> +	if ( ( status = FT_SetTimeouts(ftdih, 5000, 5000) ) != FT_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;unable to set timeouts: %lu&quot;, status);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if ((status = FT_SetBitMode(ftdih, 0x0b, 2)) != FT_OK)
</I>&gt;<i> +	if ( ( status = FT_SetBitMode(ftdih, 0x0b, 2) ) != FT_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;unable to enable bit i/o mode: %lu&quot;, status);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1552,11 +1618,12 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> static int ft2232_purge_ftd2xx(void)
</I>&gt;<i> {
</I>&gt;<i> 	FT_STATUS status;
</I>&gt;<i>
</I>&gt;<i> -	if ((status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX)) != FT_OK)
</I>&gt;<i> +	if ( ( status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX) ) !=  
</I>&gt;<i> FT_OK )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;error purging ftd2xx device: %lu&quot;, status);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1564,25 +1631,28 @@
</I>&gt;<i>
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> #endif /* BUILD_FT2232_FTD2XX == 1 */
</I>&gt;<i>
</I>&gt;<i> #if BUILD_FT2232_LIBFTDI == 1
</I>&gt;<i> -static int ft2232_init_libftdi(u16 vid, u16 pid, int more, int  
</I>&gt;<i> *try_more)
</I>&gt;<i> +static int ft2232_init_libftdi(u16 vid, u16 pid, int more, int*  
</I>&gt;<i> try_more)
</I>&gt;<i> {
</I>&gt;<i> 	u8 latency_timer;
</I>&gt;<i>
</I>&gt;<i> 	LOG_DEBUG(&quot;'ft2232' interface using libftdi with '%s' layout (%4.4x: 
</I>&gt;<i> %4.4x)&quot;,
</I>&gt;<i> -		ft2232_layout, vid, pid);
</I>&gt;<i> +			ft2232_layout, vid, pid);
</I>&gt;<i>
</I>&gt;<i> 	if (ftdi_init(&amp;ftdic) &lt; 0)
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i>
</I>&gt;<i> 	/* context, vendor id, product id */
</I>&gt;<i> 	if (ftdi_usb_open_desc(&amp;ftdic, vid, pid, ft2232_device_desc,
</I>&gt;<i> -		ft2232_serial) &lt; 0) {
</I>&gt;<i> +				ft2232_serial) &lt; 0)
</I>&gt;<i> +	{
</I>&gt;<i> 		if (more)
</I>&gt;<i> 			LOG_WARNING(&quot;unable to open ftdi device (trying more): %s&quot;,
</I>&gt;<i> -				ftdic.error_str);
</I>&gt;<i> +					ftdic.error_str);
</I>&gt;<i> 		else
</I>&gt;<i> 			LOG_ERROR(&quot;unable to open ftdi device: %s&quot;, ftdic.error_str);
</I>&gt;<i> 		*try_more = 1;
</I>&gt;<i> @@ -1622,6 +1692,7 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> static int ft2232_purge_libftdi(void)
</I>&gt;<i> {
</I>&gt;<i> 	if (ftdi_usb_purge_buffers(&amp;ftdic) &lt; 0)
</I>&gt;<i> @@ -1632,17 +1703,19 @@
</I>&gt;<i>
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> #endif /* BUILD_FT2232_LIBFTDI == 1 */
</I>&gt;<i>
</I>&gt;<i> int ft2232_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[1];
</I>&gt;<i> +	u8  buf[1];
</I>&gt;<i> 	int retval;
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i> -	ft2232_layout_t *cur_layout = ft2232_layouts;
</I>&gt;<i> +	ft2232_layout_t* cur_layout = ft2232_layouts;
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> -	if ((ft2232_layout == NULL) || (ft2232_layout[0] == 0))
</I>&gt;<i> +	if ( (ft2232_layout == NULL) || (ft2232_layout[0] == 0) )
</I>&gt;<i> 	{
</I>&gt;<i> 		ft2232_layout = &quot;usbjtag&quot;;
</I>&gt;<i> 		LOG_WARNING(&quot;No ft2232 layout specified, using default 'usbjtag'&quot;);
</I>&gt;<i> @@ -1664,7 +1737,8 @@
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	for (i = 0; 1; i++) {
</I>&gt;<i> +	for (i = 0; 1; i++)
</I>&gt;<i> +	{
</I>&gt;<i> 		/*
</I>&gt;<i> 		 * &quot;more indicates that there are more IDs to try, so we should
</I>&gt;<i> 		 * not print an error for an ID mismatch (but for anything
</I>&gt;<i> @@ -1674,15 +1748,15 @@
</I>&gt;<i> 		 * ID mismatch (and nothing else) and that we should proceeed
</I>&gt;<i> 		 * with the next ID pair.
</I>&gt;<i> 		 */
</I>&gt;<i> -		int more = ft2232_vid[i+1] || ft2232_pid[i+1];
</I>&gt;<i> +		int more     = ft2232_vid[i + 1] || ft2232_pid[i + 1];
</I>&gt;<i> 		int try_more = 0;
</I>&gt;<i>
</I>&gt;<i> #if BUILD_FT2232_FTD2XX == 1
</I>&gt;<i> 		retval = ft2232_init_ftd2xx(ft2232_vid[i], ft2232_pid[i],
</I>&gt;<i> -			more, &amp;try_more);
</I>&gt;<i> +				more, &amp;try_more);
</I>&gt;<i> #elif BUILD_FT2232_LIBFTDI == 1
</I>&gt;<i> 		retval = ft2232_init_libftdi(ft2232_vid[i], ft2232_pid[i],
</I>&gt;<i> -			more, &amp;try_more);
</I>&gt;<i> +				more, &amp;try_more);
</I>&gt;<i> #endif
</I>&gt;<i> 		if (retval &gt;= 0)
</I>&gt;<i> 			break;
</I>&gt;<i> @@ -1699,7 +1773,7 @@
</I>&gt;<i> 	ft2232_speed(jtag_speed);
</I>&gt;<i>
</I>&gt;<i> 	buf[0] = 0x85; /* Disconnect TDI/DO to TDO/DI for Loopback */
</I>&gt;<i> -	if (((retval = ft2232_write(buf, 1, &amp;bytes_written)) != ERROR_OK)  
</I>&gt;<i> || (bytes_written != 1))
</I>&gt;<i> +	if ( ( ( retval = ft2232_write(buf, 1, &amp;bytes_written) ) !=  
</I>&gt;<i> ERROR_OK ) || (bytes_written != 1) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't write to FT2232 to disable loopback&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1714,26 +1788,27 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int usbjtag_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	low_output = 0x08;
</I>&gt;<i> +	low_output    = 0x08;
</I>&gt;<i> 	low_direction = 0x0b;
</I>&gt;<i>
</I>&gt;<i> 	if (strcmp(ft2232_layout, &quot;usbjtag&quot;) == 0)
</I>&gt;<i> 	{
</I>&gt;<i> -		nTRST = 0x10;
</I>&gt;<i> +		nTRST    = 0x10;
</I>&gt;<i> 		nTRSTnOE = 0x10;
</I>&gt;<i> -		nSRST = 0x40;
</I>&gt;<i> +		nSRST    = 0x40;
</I>&gt;<i> 		nSRSTnOE = 0x40;
</I>&gt;<i> 	}
</I>&gt;<i> 	else if (strcmp(ft2232_layout, &quot;signalyzer&quot;) == 0)
</I>&gt;<i> 	{
</I>&gt;<i> -		nTRST = 0x10;
</I>&gt;<i> +		nTRST    = 0x10;
</I>&gt;<i> 		nTRSTnOE = 0x10;
</I>&gt;<i> -		nSRST = 0x20;
</I>&gt;<i> +		nSRST    = 0x20;
</I>&gt;<i> 		nSRSTnOE = 0x20;
</I>&gt;<i> 	}
</I>&gt;<i> 	else if (strcmp(ft2232_layout, &quot;evb_lm3s811&quot;) == 0)
</I>&gt;<i> @@ -1742,7 +1817,7 @@
</I>&gt;<i> 		nTRSTnOE = 0x00;
</I>&gt;<i> 		nSRST = 0x20;
</I>&gt;<i> 		nSRSTnOE = 0x20;
</I>&gt;<i> -		low_output = 0x88;
</I>&gt;<i> +		low_output    = 0x88;
</I>&gt;<i> 		low_direction = 0x8b;
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> @@ -1754,32 +1829,32 @@
</I>&gt;<i> 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
</I>&gt;<i> 	{
</I>&gt;<i> 		low_direction &amp;= ~nTRSTnOE; /* nTRST input */
</I>&gt;<i> -		low_output &amp;= ~nTRST; /* nTRST = 0 */
</I>&gt;<i> +		low_output    &amp;= ~nTRST;    /* nTRST = 0 */
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> -		low_direction |= nTRSTnOE; /* nTRST output */
</I>&gt;<i> -		low_output |= nTRST; /* nTRST = 1 */
</I>&gt;<i> +		low_direction |= nTRSTnOE;  /* nTRST output */
</I>&gt;<i> +		low_output    |= nTRST;     /* nTRST = 1 */
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
</I>&gt;<i> 	{
</I>&gt;<i> -		low_direction |= nSRSTnOE; /* nSRST output */
</I>&gt;<i> -		low_output |= nSRST; /* nSRST = 1 */
</I>&gt;<i> +		low_direction |= nSRSTnOE;  /* nSRST output */
</I>&gt;<i> +		low_output    |= nSRST;     /* nSRST = 1 */
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> 		low_direction &amp;= ~nSRSTnOE; /* nSRST input */
</I>&gt;<i> -		low_output &amp;= ~nSRST; /* nSRST = 0 */
</I>&gt;<i> +		low_output    &amp;= ~nSRST;    /* nSRST = 0 */
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	/* initialize low byte for jtag */
</I>&gt;<i> -	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> -	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, xRST high) */
</I>&gt;<i> +	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> +	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, xRST high) */
</I>&gt;<i> 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'USBJTAG' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1788,21 +1863,22 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int axm0432_jtag_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	low_output = 0x08;
</I>&gt;<i> +	low_output    = 0x08;
</I>&gt;<i> 	low_direction = 0x2b;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize low byte for jtag */
</I>&gt;<i> -	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> -	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> +	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> +	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in,  
</I>&gt;<i> nOE=out */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1810,10 +1886,10 @@
</I>&gt;<i>
</I>&gt;<i> 	if (strcmp(layout-&gt;name, &quot;axm0432_jtag&quot;) == 0)
</I>&gt;<i> 	{
</I>&gt;<i> -		nTRST = 0x08;
</I>&gt;<i> -		nTRSTnOE = 0x0;  /* No output enable for TRST*/
</I>&gt;<i> -		nSRST = 0x04;
</I>&gt;<i> -		nSRSTnOE = 0x0;  /* No output enable for SRST*/
</I>&gt;<i> +		nTRST    = 0x08;
</I>&gt;<i> +		nTRSTnOE = 0x0;     /* No output enable for TRST*/
</I>&gt;<i> +		nSRST    = 0x04;
</I>&gt;<i> +		nSRSTnOE = 0x0;     /* No output enable for SRST*/
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> @@ -1821,7 +1897,7 @@
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	high_output = 0x0;
</I>&gt;<i> +	high_output    = 0x0;
</I>&gt;<i> 	high_direction = 0x0c;
</I>&gt;<i>
</I>&gt;<i> 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
</I>&gt;<i> @@ -1843,12 +1919,12 @@
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	/* initialize high port */
</I>&gt;<i> -	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
</I>&gt;<i> -	buf[1] = high_output; /* value */
</I>&gt;<i> -	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
</I>&gt;<i> +	buf[0] = 0x82;              /* command &quot;set data bits high byte&quot; */
</I>&gt;<i> +	buf[1] = high_output;       /* value */
</I>&gt;<i> +	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'Dicarlo' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1857,21 +1933,22 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int jtagkey_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	low_output = 0x08;
</I>&gt;<i> +	low_output    = 0x08;
</I>&gt;<i> 	low_direction = 0x1b;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize low byte for jtag */
</I>&gt;<i> -	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> -	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> +	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> +	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in,  
</I>&gt;<i> nOE=out */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1879,17 +1956,17 @@
</I>&gt;<i>
</I>&gt;<i> 	if (strcmp(layout-&gt;name, &quot;jtagkey&quot;) == 0)
</I>&gt;<i> 	{
</I>&gt;<i> -		nTRST = 0x01;
</I>&gt;<i> +		nTRST    = 0x01;
</I>&gt;<i> 		nTRSTnOE = 0x4;
</I>&gt;<i> -		nSRST = 0x02;
</I>&gt;<i> +		nSRST    = 0x02;
</I>&gt;<i> 		nSRSTnOE = 0x08;
</I>&gt;<i> 	}
</I>&gt;<i> -	else if ((strcmp(layout-&gt;name, &quot;jtagkey_prototype_v1&quot;) == 0) ||
</I>&gt;<i> -		(strcmp(layout-&gt;name, &quot;oocdlink&quot;) == 0))
</I>&gt;<i> +	else if ( (strcmp(layout-&gt;name, &quot;jtagkey_prototype_v1&quot;) == 0)
</I>&gt;<i> +			 || (strcmp(layout-&gt;name, &quot;oocdlink&quot;) == 0) )
</I>&gt;<i> 	{
</I>&gt;<i> -		nTRST = 0x02;
</I>&gt;<i> +		nTRST    = 0x02;
</I>&gt;<i> 		nTRSTnOE = 0x1;
</I>&gt;<i> -		nSRST = 0x08;
</I>&gt;<i> +		nSRST    = 0x08;
</I>&gt;<i> 		nSRSTnOE = 0x04;
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> @@ -1898,7 +1975,7 @@
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	high_output = 0x0;
</I>&gt;<i> +	high_output    = 0x0;
</I>&gt;<i> 	high_direction = 0x0f;
</I>&gt;<i>
</I>&gt;<i> 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
</I>&gt;<i> @@ -1924,12 +2001,12 @@
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	/* initialize high port */
</I>&gt;<i> -	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
</I>&gt;<i> -	buf[1] = high_output; /* value */
</I>&gt;<i> -	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
</I>&gt;<i> +	buf[0] = 0x82;              /* command &quot;set data bits high byte&quot; */
</I>&gt;<i> +	buf[1] = high_output;       /* value */
</I>&gt;<i> +	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -1938,32 +2015,33 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int olimex_jtag_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	low_output = 0x08;
</I>&gt;<i> +	low_output    = 0x08;
</I>&gt;<i> 	low_direction = 0x1b;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize low byte for jtag */
</I>&gt;<i> -	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> -	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> +	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> +	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in,  
</I>&gt;<i> nOE=out */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	nTRST = 0x01;
</I>&gt;<i> +	nTRST    = 0x01;
</I>&gt;<i> 	nTRSTnOE = 0x4;
</I>&gt;<i> -	nSRST = 0x02;
</I>&gt;<i> +	nSRST    = 0x02;
</I>&gt;<i> 	nSRSTnOE = 0x00; /* no output enable for nSRST */
</I>&gt;<i>
</I>&gt;<i> -	high_output = 0x0;
</I>&gt;<i> +	high_output    = 0x0;
</I>&gt;<i> 	high_direction = 0x0f;
</I>&gt;<i>
</I>&gt;<i> 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
</I>&gt;<i> @@ -1990,12 +2068,12 @@
</I>&gt;<i> 	high_output |= 0x08;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize high port */
</I>&gt;<i> -	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
</I>&gt;<i> -	buf[1] = high_output; /* value */
</I>&gt;<i> -	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
</I>&gt;<i> +	buf[0] = 0x82;              /* command &quot;set data bits high byte&quot; */
</I>&gt;<i> +	buf[1] = high_output;       /* value */
</I>&gt;<i> +	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -2004,44 +2082,45 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int flyswatter_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	low_output = 0x18;
</I>&gt;<i> +	low_output    = 0x18;
</I>&gt;<i> 	low_direction = 0xfb;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize low byte for jtag */
</I>&gt;<i> -	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> -	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> +	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> +	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in,  
</I>&gt;<i> nOE[12]=out, n[ST]srst=out */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'flyswatter' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	nTRST = 0x10;
</I>&gt;<i> -	nTRSTnOE = 0x0; /* not output enable for nTRST */
</I>&gt;<i> -	nSRST = 0x20;
</I>&gt;<i> -	nSRSTnOE = 0x00; /* no output enable for nSRST */
</I>&gt;<i> +	nTRST    = 0x10;
</I>&gt;<i> +	nTRSTnOE = 0x0;     /* not output enable for nTRST */
</I>&gt;<i> +	nSRST    = 0x20;
</I>&gt;<i> +	nSRSTnOE = 0x00;    /* no output enable for nSRST */
</I>&gt;<i>
</I>&gt;<i> -	high_output = 0x00;
</I>&gt;<i> +	high_output    = 0x00;
</I>&gt;<i> 	high_direction = 0x0c;
</I>&gt;<i>
</I>&gt;<i> 	/* turn red LED1 on, LED2 off */
</I>&gt;<i> 	high_output |= 0x08;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize high port */
</I>&gt;<i> -	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
</I>&gt;<i> -	buf[1] = high_output; /* value */
</I>&gt;<i> -	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
</I>&gt;<i> +	buf[0] = 0x82;              /* command &quot;set data bits high byte&quot; */
</I>&gt;<i> +	buf[1] = high_output;       /* value */
</I>&gt;<i> +	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'flyswatter' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -2050,21 +2129,22 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int turtle_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	low_output = 0x08;
</I>&gt;<i> +	low_output    = 0x08;
</I>&gt;<i> 	low_direction = 0x5b;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize low byte for jtag */
</I>&gt;<i> -	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> -	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> +	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> +	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in,  
</I>&gt;<i> nOE=out */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'turtelizer2' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -2072,7 +2152,7 @@
</I>&gt;<i>
</I>&gt;<i> 	nSRST = 0x40;
</I>&gt;<i>
</I>&gt;<i> -	high_output = 0x00;
</I>&gt;<i> +	high_output    = 0x00;
</I>&gt;<i> 	high_direction = 0x0C;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize high port */
</I>&gt;<i> @@ -2081,7 +2161,7 @@
</I>&gt;<i> 	buf[2] = high_direction;
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'turtelizer2' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -2090,32 +2170,33 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int comstick_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	low_output = 0x08;
</I>&gt;<i> +	low_output    = 0x08;
</I>&gt;<i> 	low_direction = 0x0b;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize low byte for jtag */
</I>&gt;<i> -	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> -	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> +	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> +	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in,  
</I>&gt;<i> nOE=out */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'comstick' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	nTRST = 0x01;
</I>&gt;<i> -	nTRSTnOE = 0x00; /* no output enable for nTRST */
</I>&gt;<i> -	nSRST = 0x02;
</I>&gt;<i> -	nSRSTnOE = 0x00; /* no output enable for nSRST */
</I>&gt;<i> +	nTRST    = 0x01;
</I>&gt;<i> +	nTRSTnOE = 0x00;    /* no output enable for nTRST */
</I>&gt;<i> +	nSRST    = 0x02;
</I>&gt;<i> +	nSRSTnOE = 0x00;    /* no output enable for nSRST */
</I>&gt;<i>
</I>&gt;<i> -	high_output = 0x03;
</I>&gt;<i> +	high_output    = 0x03;
</I>&gt;<i> 	high_direction = 0x03;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize high port */
</I>&gt;<i> @@ -2124,7 +2205,7 @@
</I>&gt;<i> 	buf[2] = high_direction;
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'comstick' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -2133,32 +2214,33 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int stm32stick_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 buf[3];
</I>&gt;<i> +	u8  buf[3];
</I>&gt;<i> 	u32 bytes_written;
</I>&gt;<i>
</I>&gt;<i> -	low_output = 0x88;
</I>&gt;<i> +	low_output    = 0x88;
</I>&gt;<i> 	low_direction = 0x8b;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize low byte for jtag */
</I>&gt;<i> -	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> -	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> +	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
</I>&gt;<i> +	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
</I>&gt;<i> 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in,  
</I>&gt;<i> nOE=out */
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'stm32stick' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	nTRST = 0x01;
</I>&gt;<i> -	nTRSTnOE = 0x00; /* no output enable for nTRST */
</I>&gt;<i> -	nSRST = 0x80;
</I>&gt;<i> -	nSRSTnOE = 0x00; /* no output enable for nSRST */
</I>&gt;<i> +	nTRST    = 0x01;
</I>&gt;<i> +	nTRSTnOE = 0x00;    /* no output enable for nTRST */
</I>&gt;<i> +	nSRST    = 0x80;
</I>&gt;<i> +	nSRSTnOE = 0x00;    /* no output enable for nSRST */
</I>&gt;<i>
</I>&gt;<i> -	high_output = 0x01;
</I>&gt;<i> +	high_output    = 0x01;
</I>&gt;<i> 	high_direction = 0x03;
</I>&gt;<i>
</I>&gt;<i> 	/* initialize high port */
</I>&gt;<i> @@ -2167,7 +2249,7 @@
</I>&gt;<i> 	buf[2] = high_direction;
</I>&gt;<i> 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
</I>&gt;<i>
</I>&gt;<i> -	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) ||  
</I>&gt;<i> (bytes_written != 3))
</I>&gt;<i> +	if ( ( ( ft2232_write(buf, 3, &amp;bytes_written) ) != ERROR_OK ) ||  
</I>&gt;<i> (bytes_written != 3) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'stm32stick' layout&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> @@ -2176,6 +2258,7 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void olimex_jtag_blink(void)
</I>&gt;<i> {
</I>&gt;<i> 	/* Olimex ARM-USB-OCD has a LED connected to ACBUS3
</I>&gt;<i> @@ -2197,10 +2280,11 @@
</I>&gt;<i> 	BUFFER_ADD = high_direction;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> void turtle_jtag_blink(void)
</I>&gt;<i> {
</I>&gt;<i> 	/*
</I>&gt;<i> -   * Turtelizer2 has two LEDs connected to ACBUS2 and ACBUS3
</I>&gt;<i> +	 * Turtelizer2 has two LEDs connected to ACBUS2 and ACBUS3
</I>&gt;<i> 	 */
</I>&gt;<i> 	if (high_output &amp; 0x08)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -2216,6 +2300,7 @@
</I>&gt;<i> 	BUFFER_ADD = high_direction;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> int ft2232_quit(void)
</I>&gt;<i> {
</I>&gt;<i> #if BUILD_FT2232_FTD2XX == 1
</I>&gt;<i> @@ -2236,7 +2321,8 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_handle_device_desc_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_handle_device_desc_command(struct command_context_s*  
</I>&gt;<i> cmd_ctx, char* cmd, char** args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc == 1)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -2250,7 +2336,8 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_handle_serial_command(struct command_context_s *cmd_ctx,  
</I>&gt;<i> char *cmd, char **args, int argc)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_handle_serial_command(struct command_context_s* cmd_ctx,  
</I>&gt;<i> char* cmd, char** args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc == 1)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -2264,7 +2351,8 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_handle_layout_command(struct command_context_s *cmd_ctx,  
</I>&gt;<i> char *cmd, char **args, int argc)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_handle_layout_command(struct command_context_s* cmd_ctx,  
</I>&gt;<i> char* cmd, char** args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc == 0)
</I>&gt;<i> 		return ERROR_OK;
</I>&gt;<i> @@ -2275,26 +2363,30 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_handle_vid_pid_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_handle_vid_pid_command(struct command_context_s*  
</I>&gt;<i> cmd_ctx, char* cmd, char** args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> -	if (argc &gt; MAX_USB_IDS*2) {
</I>&gt;<i> +	if (argc &gt; MAX_USB_IDS * 2)
</I>&gt;<i> +	{
</I>&gt;<i> 		LOG_WARNING(&quot;ignoring extra IDs in ft2232_vid_pid &quot;
</I>&gt;<i> -			&quot;(maximum is %d pairs)&quot;, MAX_USB_IDS);
</I>&gt;<i> -		argc = MAX_USB_IDS*2;
</I>&gt;<i> +					&quot;(maximum is %d pairs)&quot;, MAX_USB_IDS);
</I>&gt;<i> +		argc = MAX_USB_IDS * 2;
</I>&gt;<i> 	}
</I>&gt;<i> -	if (argc &lt; 2 || (argc &amp; 1))
</I>&gt;<i> +	if ( argc &lt; 2 || (argc &amp; 1) )
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_WARNING(&quot;incomplete ft2232_vid_pid configuration directive&quot;);
</I>&gt;<i> 		if (argc &lt; 2)
</I>&gt;<i> 			return ERROR_OK;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	for (i = 0; i+1 &lt; argc; i += 2) {
</I>&gt;<i> +	for (i = 0; i + 1 &lt; argc; i += 2)
</I>&gt;<i> +	{
</I>&gt;<i> 		ft2232_vid[i &gt;&gt; 1] = strtol(args[i], NULL, 0);
</I>&gt;<i> -		ft2232_pid[i &gt;&gt; 1] = strtol(args[i+1], NULL, 0);
</I>&gt;<i> +		ft2232_pid[i &gt;&gt; 1] = strtol(args[i + 1], NULL, 0);
</I>&gt;<i> 	}
</I>&gt;<i> +
</I>&gt;<i> 	/*
</I>&gt;<i> 	 * Explicitly terminate, in case there are multiples instances of
</I>&gt;<i> 	 * ft2232_vid_pid.
</I>&gt;<i> @@ -2304,7 +2396,8 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int ft2232_handle_latency_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc)
</I>&gt;<i> +
</I>&gt;<i> +int ft2232_handle_latency_command(struct command_context_s*  
</I>&gt;<i> cmd_ctx, char* cmd, char** args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc == 1)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -2319,19 +2412,18 @@
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -static int ft2232_stableclocks(int num_cycles, jtag_command_t *cmd)
</I>&gt;<i> +static int ft2232_stableclocks(int num_cycles, jtag_command_t* cmd)
</I>&gt;<i> {
</I>&gt;<i> 	int retval = 0;
</I>&gt;<i>
</I>&gt;<i> 	/* 7 bits of either ones or zeros. */
</I>&gt;<i> -	u8 tms = (cur_state == TAP_RESET ? 0x7F : 0x00);
</I>&gt;<i> +	u8  tms = (tap_get_state() == TAP_RESET ? 0x7F : 0x00);
</I>&gt;<i>
</I>&gt;<i> 	while (num_cycles &gt; 0)
</I>&gt;<i> 	{
</I>&gt;<i> 		/* the command 0x4b, &quot;Clock Data to TMS/CS Pin (no Read)&quot; handles
</I>&gt;<i> 		 * at most 7 bits per invocation.  Here we invoke it potentially
</I>&gt;<i> 		 * several times.
</I>&gt;<i> -		 * see: <A HREF="http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf">http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf</A>
</I>&gt;<i> 		 */
</I>&gt;<i> 		int bitcount_per_command = (num_cycles &gt; 7) ? 7 : num_cycles;
</I>&gt;<i>
</I>&gt;<i> @@ -2359,4 +2451,3 @@
</I>&gt;<i>
</I>&gt;<i> 	return retval;
</I>&gt;<i> }
</I>&gt;<i> -
</I>&gt;<i> Index: src/jtag/vsllink.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/vsllink.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/vsllink.c	(working copy)
</I>&gt;<i> @@ -92,7 +92,7 @@
</I>&gt;<i> #define JTAG_PINMSK_TDO				(1 &lt;&lt; 7)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -#define VSLLINK_TAP_MOVE(from, to)	 
</I>&gt;<i> VSLLINK_tap_move[tap_move_map[from]][tap_move_map[to]]
</I>&gt;<i> +#define VSLLINK_TAP_MOVE(from, to)	 
</I>&gt;<i> VSLLINK_tap_move[tap_move_ndx(from)][tap_move_ndx(to)]
</I>&gt;<i>
</I>&gt;<i> /* VSLLINK_tap_move[i][j]: tap movement command to go from state i  
</I>&gt;<i> to state j
</I>&gt;<i>  * 0: Test-Logic-Reset
</I>&gt;<i> @@ -101,7 +101,7 @@
</I>&gt;<i>  * 3: Pause-DR
</I>&gt;<i>  * 4: Shift-IR
</I>&gt;<i>  * 5: Pause-IR
</I>&gt;<i> - *
</I>&gt;<i> + *
</I>&gt;<i>  * SD-&gt;SD and SI-&gt;SI have to be caught in interface specific code
</I>&gt;<i>  */
</I>&gt;<i> u8 VSLLINK_tap_move[6][6] =
</I>&gt;<i> @@ -267,17 +267,17 @@
</I>&gt;<i> 		switch (cmd-&gt;type)
</I>&gt;<i> 		{
</I>&gt;<i> 			case JTAG_END_STATE:
</I>&gt;<i> -				DEBUG_JTAG_IO(&quot;end_state: %s&quot;, jtag_state_name(cmd- 
</I>&gt;<i> &gt;cmd.end_state-&gt;end_state));
</I>&gt;<i> -			
</I>&gt;<i> +				DEBUG_JTAG_IO(&quot;end_state: %s&quot;, tap_state_name(cmd- 
</I>&gt;<i> &gt;cmd.end_state-&gt;end_state));
</I>&gt;<i> +
</I>&gt;<i> 				if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
</I>&gt;<i> 				{
</I>&gt;<i> 					vsllink_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
</I>&gt;<i> 				}
</I>&gt;<i> 				break;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 			case JTAG_RUNTEST:
</I>&gt;<i> 				DEBUG_JTAG_IO( &quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest- 
</I>&gt;<i> &gt;num_cycles, \
</I>&gt;<i> -					jtag_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
</I>&gt;<i> +					tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
</I>&gt;<i>
</I>&gt;<i> 				if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
</I>&gt;<i> 				{
</I>&gt;<i> @@ -285,39 +285,39 @@
</I>&gt;<i> 				}
</I>&gt;<i> 				vsllink_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
</I>&gt;<i> 				break;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 			case JTAG_STATEMOVE:
</I>&gt;<i> -				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, jtag_state_name(cmd- 
</I>&gt;<i> &gt;cmd.statemove-&gt;end_state));
</I>&gt;<i> -			
</I>&gt;<i> +				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, tap_state_name(cmd- 
</I>&gt;<i> &gt;cmd.statemove-&gt;end_state));
</I>&gt;<i> +
</I>&gt;<i> 				if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
</I>&gt;<i> 				{
</I>&gt;<i> 					vsllink_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
</I>&gt;<i> 				}
</I>&gt;<i> 				vsllink_state_move();
</I>&gt;<i> 				break;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 			case JTAG_PATHMOVE:
</I>&gt;<i> 				DEBUG_JTAG_IO(&quot;pathmove: %i states, end in %s&quot;, \
</I>&gt;<i> 					cmd-&gt;cmd.pathmove-&gt;num_states, \
</I>&gt;<i> -					jtag_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states - 1]));
</I>&gt;<i> -			
</I>&gt;<i> +					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove- 
</I>&gt;<i> &gt;num_states - 1]));
</I>&gt;<i> +
</I>&gt;<i> 				vsllink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, cmd- 
</I>&gt;<i> &gt;cmd.pathmove-&gt;path);
</I>&gt;<i> 				break;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 			case JTAG_SCAN:
</I>&gt;<i> 				if (cmd-&gt;cmd.scan-&gt;end_state != -1)
</I>&gt;<i> 				{
</I>&gt;<i> 					vsllink_end_state(cmd-&gt;cmd.scan-&gt;end_state);
</I>&gt;<i> 				}
</I>&gt;<i> -			
</I>&gt;<i> +
</I>&gt;<i> 				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
</I>&gt;<i> 				if (cmd-&gt;cmd.scan-&gt;ir_scan)
</I>&gt;<i> 				{
</I>&gt;<i> -					DEBUG_JTAG_IO(&quot;JTAG Scan write IR(%d bits), end in %s:&quot;,  
</I>&gt;<i> scan_size, jtag_state_name(cmd-&gt;cmd.scan-&gt;end_state));
</I>&gt;<i> +					DEBUG_JTAG_IO(&quot;JTAG Scan write IR(%d bits), end in %s:&quot;,  
</I>&gt;<i> scan_size, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
</I>&gt;<i> 				}
</I>&gt;<i> 				else
</I>&gt;<i> 				{
</I>&gt;<i> -					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;,  
</I>&gt;<i> scan_size, jtag_state_name(cmd-&gt;cmd.scan-&gt;end_state));
</I>&gt;<i> +					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;,  
</I>&gt;<i> scan_size, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
</I>&gt;<i> 				}
</I>&gt;<i>
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> @@ -328,7 +328,7 @@
</I>&gt;<i>
</I>&gt;<i> 				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size,  
</I>&gt;<i> cmd-&gt;cmd.scan);
</I>&gt;<i> 				break;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 			case JTAG_RESET:
</I>&gt;<i> 				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst,  
</I>&gt;<i> cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i>
</I>&gt;<i> @@ -336,14 +336,14 @@
</I>&gt;<i>
</I>&gt;<i> 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
</I>&gt;<i> 				{
</I>&gt;<i> -					cur_state = TAP_RESET;
</I>&gt;<i> +					tap_set_state(TAP_RESET);
</I>&gt;<i> 				}
</I>&gt;<i> 				vsllink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
</I>&gt;<i>
</I>&gt;<i> 				vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
</I>&gt;<i> 				vsllink_usb_out_buffer_idx = 3;
</I>&gt;<i> 				break;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 			case JTAG_SLEEP:
</I>&gt;<i> 				DEBUG_JTAG_IO(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
</I>&gt;<i> 				vsllink_tap_execute();
</I>&gt;<i> @@ -352,7 +352,7 @@
</I>&gt;<i>
</I>&gt;<i> 			case JTAG_STABLECLOCKS:
</I>&gt;<i> 				DEBUG_JTAG_IO(&quot;add %d clocks&quot;, cmd-&gt;cmd.stableclocks-&gt;num_cycles);
</I>&gt;<i> -				switch(cur_state)
</I>&gt;<i> +				switch(tap_get_state())
</I>&gt;<i> 				{
</I>&gt;<i> 				case TAP_RESET:
</I>&gt;<i> 					// tms should be '1' to stay in TAP_RESET mode
</I>&gt;<i> @@ -368,7 +368,7 @@
</I>&gt;<i> 					break;			/* above stable states are OK */
</I>&gt;<i> 				default:
</I>&gt;<i> 					 LOG_ERROR( &quot;jtag_add_clocks() was called with TAP in non- 
</I>&gt;<i> stable state \&quot;%s\&quot;&quot;,
</I>&gt;<i> -							 jtag_state_name(cur_state) );
</I>&gt;<i> +							 tap_state_name(tap_get_state()) );
</I>&gt;<i> 					 exit(-1);
</I>&gt;<i> 				}
</I>&gt;<i> 				vsllink_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles,  
</I>&gt;<i> scan_size);
</I>&gt;<i> @@ -380,7 +380,7 @@
</I>&gt;<i> 		}
</I>&gt;<i> 		cmd = cmd-&gt;next;
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return vsllink_tap_execute();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -391,9 +391,9 @@
</I>&gt;<i> 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_SPEED;
</I>&gt;<i> 	vsllink_usb_out_buffer[1] = (speed &gt;&gt; 0) &amp; 0xff;
</I>&gt;<i> 	vsllink_usb_out_buffer[2] = (speed &gt;&gt; 8) &amp; 0xFF;
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 	result = vsllink_usb_write(vsllink_jtag_handle, 3);
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 	if (result == 3)
</I>&gt;<i> 	{
</I>&gt;<i> 		return ERROR_OK;
</I>&gt;<i> @@ -403,14 +403,14 @@
</I>&gt;<i> 		LOG_ERROR(&quot;VSLLink setting speed failed (%d)&quot;, result);
</I>&gt;<i> 		return ERROR_JTAG_DEVICE_ERROR;
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> int vsllink_khz(int khz, int *jtag_speed)
</I>&gt;<i> {
</I>&gt;<i> 	*jtag_speed = khz;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -423,13 +423,13 @@
</I>&gt;<i>
</I>&gt;<i> int vsllink_register_commands(struct command_context_s *cmd_ctx)
</I>&gt;<i> {
</I>&gt;<i> -	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;,  
</I>&gt;<i> vsllink_handle_usb_vid_command,
</I>&gt;<i> +	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;,  
</I>&gt;<i> vsllink_handle_usb_vid_command,
</I>&gt;<i> 					COMMAND_CONFIG, NULL);
</I>&gt;<i> -	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;,  
</I>&gt;<i> vsllink_handle_usb_pid_command,
</I>&gt;<i> +	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;,  
</I>&gt;<i> vsllink_handle_usb_pid_command,
</I>&gt;<i> 					COMMAND_CONFIG, NULL);
</I>&gt;<i> -	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;,  
</I>&gt;<i> vsllink_handle_usb_bulkin_command,
</I>&gt;<i> +	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;,  
</I>&gt;<i> vsllink_handle_usb_bulkin_command,
</I>&gt;<i> 					COMMAND_CONFIG, NULL);
</I>&gt;<i> -	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;,  
</I>&gt;<i> vsllink_handle_usb_bulkout_command,
</I>&gt;<i> +	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;,  
</I>&gt;<i> vsllink_handle_usb_bulkout_command,
</I>&gt;<i> 					COMMAND_CONFIG, NULL);
</I>&gt;<i>
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> @@ -437,7 +437,7 @@
</I>&gt;<i>
</I>&gt;<i> int vsllink_init(void)
</I>&gt;<i> {
</I>&gt;<i> -	int check_cnt;
</I>&gt;<i> +	int check_cnt;
</I>&gt;<i> 	int result;
</I>&gt;<i> 	char version_str[100];
</I>&gt;<i>
</I>&gt;<i> @@ -450,13 +450,13 @@
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> 	vsllink_jtag_handle = vsllink_usb_open();
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if (vsllink_jtag_handle == 0)
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;Can't find USB JTAG Interface! Please check connection  
</I>&gt;<i> and permissions.&quot;);
</I>&gt;<i> 		return ERROR_JTAG_INIT_FAILED;
</I>&gt;<i> 	}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 	check_cnt = 0;
</I>&gt;<i> 	while (check_cnt &lt; 3)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -517,7 +517,7 @@
</I>&gt;<i> 	LOG_INFO(&quot;VSLLink JTAG Interface ready&quot;);
</I>&gt;<i>
</I>&gt;<i> 	vsllink_tap_init();
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> @@ -555,10 +555,11 @@
</I>&gt;<i> // length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set, no need to set  
</I>&gt;<i> it here.
</I>&gt;<i> void vsllink_append_tms(void)
</I>&gt;<i> {
</I>&gt;<i> -	u8 tms_scan = VSLLINK_TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +	u8 tms_scan = VSLLINK_TAP_MOVE(tap_get_state(),  
</I>&gt;<i> tap_get_end_state());
</I>&gt;<i> 	u16 tms2;
</I>&gt;<i> +	tap_state_t	end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> -	if (((cur_state != TAP_RESET) &amp;&amp; (cur_state != TAP_IDLE) &amp;&amp;  
</I>&gt;<i> (cur_state != TAP_DRPAUSE) &amp;&amp; (cur_state != TAP_IRPAUSE)) || \
</I>&gt;<i> +	if (((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() !=  
</I>&gt;<i> TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE) &amp;&amp; (tap_get_state() !=  
</I>&gt;<i> TAP_IRPAUSE)) || \
</I>&gt;<i> 			(vsllink_tms_data_len &lt;= 0) || (vsllink_tms_data_len &gt;= 8) || \
</I>&gt;<i> 			(vsllink_tms_cmd_pos == NULL))
</I>&gt;<i> 	{
</I>&gt;<i> @@ -566,15 +567,15 @@
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	tms2 = (tms_scan &amp;  
</I>&gt;<i> VSLLINK_BIT_MSK 
</I>&gt;<i> [VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]].insert_position]) &lt;&lt; \
</I>&gt;<i> +	tms2 = (tms_scan &amp;  
</I>&gt;<i> VSLLINK_BIT_MSK 
</I>&gt;<i> [VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())] 
</I>&gt;<i> [tap_move_ndx(end_state)].insert_position]) &lt;&lt; \
</I>&gt;<i> 				vsllink_tms_data_len;
</I>&gt;<i> -	if (VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]].insert_value == 1)
</I>&gt;<i> +	if  
</I>&gt;<i> (VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())] 
</I>&gt;<i> [tap_move_ndx(end_state)].insert_value == 1)
</I>&gt;<i> 	{
</I>&gt;<i> 		tms2 |= VSLLINK_BIT_MSK[8 - vsllink_tms_data_len] &lt;&lt; \
</I>&gt;<i> -				(vsllink_tms_data_len +  
</I>&gt;<i> VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]].insert_position);
</I>&gt;<i> +				(vsllink_tms_data_len +  
</I>&gt;<i> VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())] 
</I>&gt;<i> [tap_move_ndx(end_state)].insert_position);
</I>&gt;<i> 	}
</I>&gt;<i> -	tms2 |= (tms_scan &gt;&gt;  
</I>&gt;<i> VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]].insert_position) &lt;&lt; \
</I>&gt;<i> -				(8 +  
</I>&gt;<i> VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_map[cur_state]] 
</I>&gt;<i> [tap_move_map[end_state]].insert_position);
</I>&gt;<i> +	tms2 |= (tms_scan &gt;&gt;  
</I>&gt;<i> VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())] 
</I>&gt;<i> [tap_move_ndx(end_state)].insert_position) &lt;&lt; \
</I>&gt;<i> +				(8 +  
</I>&gt;<i> VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())] 
</I>&gt;<i> [tap_move_ndx(end_state)].insert_position);
</I>&gt;<i>
</I>&gt;<i> 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (tms2 &gt;&gt; 0)  
</I>&gt;<i> &amp; 0xff;
</I>&gt;<i> 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms2 &gt;&gt; 8)  
</I>&gt;<i> &amp; 0xff;
</I>&gt;<i> @@ -588,9 +589,9 @@
</I>&gt;<i>
</I>&gt;<i> void vsllink_end_state(enum tap_state state)
</I>&gt;<i> {
</I>&gt;<i> -	if (tap_move_map[state] != -1)
</I>&gt;<i> +	if (tap_is_state_stable(state))
</I>&gt;<i> 	{
</I>&gt;<i> -		end_state = state;
</I>&gt;<i> +		tap_set_end_state(state);
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> @@ -611,10 +612,10 @@
</I>&gt;<i> 		vsllink_tap_ensure_space(0, 2);
</I>&gt;<i>
</I>&gt;<i> 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_CMDJTAGSEQ_TMSBYTE;
</I>&gt;<i> -		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(tap_get_end_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> // write tms from current  
</I>&gt;<i> vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx]
</I>&gt;<i> @@ -633,20 +634,20 @@
</I>&gt;<i> 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> -		if (path[i - start] == tap_transitions[cur_state].high)
</I>&gt;<i> +		if (path[i - start] == tap_state_transition(tap_get_state(), TRUE))
</I>&gt;<i> 		{
</I>&gt;<i> 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= 1 &lt;&lt; (i &amp; 7);
</I>&gt;<i> 		}
</I>&gt;<i> -		else if (path[i - start] == tap_transitions[cur_state].low)
</I>&gt;<i> +		else if (path[i - start] == tap_state_transition(tap_get_state(),  
</I>&gt;<i> FALSE))
</I>&gt;<i> 		{
</I>&gt;<i> 			// nothing to do
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(path[i]));
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(tap_get_state()), tap_state_name(path[i]));
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i> -		cur_state = path[i - start];
</I>&gt;<i> +		tap_set_state(path[i - start]);
</I>&gt;<i> 	}
</I>&gt;<i> 	if ((i &gt; 0) &amp;&amp; ((i &amp; 7) == 0))
</I>&gt;<i> 	{
</I>&gt;<i> @@ -654,7 +655,7 @@
</I>&gt;<i> 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	end_state = cur_state;
</I>&gt;<i> +	tap_set_end_state(tap_get_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void vsllink_path_move(int num_states, enum tap_state *path)
</I>&gt;<i> @@ -934,9 +935,9 @@
</I>&gt;<i>
</I>&gt;<i> void vsllink_runtest(int num_cycles)
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state saved_end_state = end_state;
</I>&gt;<i> +	enum tap_state saved_end_state = tap_get_end_state();
</I>&gt;<i>
</I>&gt;<i> -	if (cur_state != TAP_IDLE)
</I>&gt;<i> +	if (tap_get_state() != TAP_IDLE)
</I>&gt;<i> 	{
</I>&gt;<i> 		// enter into IDLE state
</I>&gt;<i> 		vsllink_end_state(TAP_IDLE);
</I>&gt;<i> @@ -948,8 +949,8 @@
</I>&gt;<i> 	// post-process
</I>&gt;<i> 	// set end_state
</I>&gt;<i> 	vsllink_end_state(saved_end_state);
</I>&gt;<i> -	cur_state = TAP_IDLE;
</I>&gt;<i> -	if (end_state != TAP_IDLE)
</I>&gt;<i> +	tap_set_state(TAP_IDLE);
</I>&gt;<i> +	if (tap_get_end_state() != TAP_IDLE)
</I>&gt;<i> 	{
</I>&gt;<i> 		vsllink_state_move();
</I>&gt;<i> 	}
</I>&gt;<i> @@ -972,15 +973,15 @@
</I>&gt;<i> 		LOG_ERROR(&quot;Your implementation of VSLLink has not enough buffer&quot;);
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> -	saved_end_state = end_state;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> +	saved_end_state = tap_get_end_state();
</I>&gt;<i> +
</I>&gt;<i> 	/* Move to appropriate scan state */
</I>&gt;<i> 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
</I>&gt;<i>
</I>&gt;<i> 	if (vsllink_tms_data_len &gt; 0)
</I>&gt;<i> 	{
</I>&gt;<i> -		if (cur_state == end_state)
</I>&gt;<i> +		if (tap_get_state() == tap_get_end_state())
</I>&gt;<i> 		{
</I>&gt;<i> 			// already in IRSHIFT or DRSHIFT state
</I>&gt;<i> 			// merge tms data in the last tms shift command into next scan  
</I>&gt;<i> command
</I>&gt;<i> @@ -1001,7 +1002,7 @@
</I>&gt;<i> 			}
</I>&gt;<i>
</I>&gt;<i> 			vsllink_tap_ensure_space(1, tdi_len + 7);
</I>&gt;<i> -			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is  
</I>&gt;<i> valid
</I>&gt;<i> +			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is  
</I>&gt;<i> valid
</I>&gt;<i> 			// which is merged from the last tms shift command
</I>&gt;<i> 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_CMDJTAGSEQ_SCAN | 1;
</I>&gt;<i> 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len  
</I>&gt;<i> + 1) &gt;&gt; 0) &amp; 0xff;
</I>&gt;<i> @@ -1041,7 +1042,7 @@
</I>&gt;<i> 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_CMDJTAGSEQ_SCAN | 1;
</I>&gt;<i> 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len +  
</I>&gt;<i> 1) &gt;&gt; 0) &amp; 0xff;
</I>&gt;<i> 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len +  
</I>&gt;<i> 1)&gt;&gt; 8) &amp; 0xff;
</I>&gt;<i> -		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
</I>&gt;<i> 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
</I>&gt;<i>
</I>&gt;<i> 		vsllink_tap_append_scan(scan_size, buffer, command, 8);
</I>&gt;<i> @@ -1049,7 +1050,7 @@
</I>&gt;<i> 	vsllink_end_state(saved_end_state);
</I>&gt;<i>
</I>&gt;<i> 	bits_left = scan_size &amp; 0x07;
</I>&gt;<i> -	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
</I>&gt;<i> +	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
</I>&gt;<i>
</I>&gt;<i> 	if (bits_left &gt; 0)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -1060,16 +1061,16 @@
</I>&gt;<i> 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; 7;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	if (cur_state != end_state)
</I>&gt;<i> +	if (tap_get_state() != tap_get_end_state())
</I>&gt;<i> 	{
</I>&gt;<i> -		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_TAP_MOVE(cur_state, end_state);
</I>&gt;<i> +		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] =  
</I>&gt;<i> VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
</I>&gt;<i> 	}
</I>&gt;<i> 	else
</I>&gt;<i> 	{
</I>&gt;<i> 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> -	cur_state = end_state;
</I>&gt;<i> +	tap_set_state(tap_get_end_state());
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void vsllink_reset(int trst, int srst)
</I>&gt;<i> @@ -1077,7 +1078,7 @@
</I>&gt;<i> 	int result;
</I>&gt;<i>
</I>&gt;<i> 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	/* Signals are active low */
</I>&gt;<i> 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORT;
</I>&gt;<i> 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
</I>&gt;<i> @@ -1101,12 +1102,12 @@
</I>&gt;<i> void vsllink_simple_command(u8 command)
</I>&gt;<i> {
</I>&gt;<i> 	int result;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	DEBUG_JTAG_IO(&quot;0x%02x&quot;, command);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	vsllink_usb_out_buffer[0] = command;
</I>&gt;<i> 	result = vsllink_usb_write(vsllink_jtag_handle, 1);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if (result != 1)
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;VSLLink command 0x%02x failed (%d)&quot;, command, result);
</I>&gt;<i> @@ -1116,7 +1117,7 @@
</I>&gt;<i> int vsllink_handle_usb_vid_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc != 1) {
</I>&gt;<i> -	    LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
</I>&gt;<i> +		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
</I>&gt;<i> 		return ERROR_OK;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> @@ -1128,7 +1129,7 @@
</I>&gt;<i> int vsllink_handle_usb_pid_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc != 1) {
</I>&gt;<i> -	    LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
</I>&gt;<i> +		LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
</I>&gt;<i> 		return ERROR_OK;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> @@ -1140,7 +1141,7 @@
</I>&gt;<i> int vsllink_handle_usb_bulkin_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc != 1) {
</I>&gt;<i> -	    LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN  
</I>&gt;<i> endpoint&quot;);
</I>&gt;<i> +		LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN  
</I>&gt;<i> endpoint&quot;);
</I>&gt;<i> 		return ERROR_OK;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> @@ -1152,7 +1153,7 @@
</I>&gt;<i> int vsllink_handle_usb_bulkout_command(struct command_context_s  
</I>&gt;<i> *cmd_ctx, char *cmd, char **args, int argc)
</I>&gt;<i> {
</I>&gt;<i> 	if (argc != 1) {
</I>&gt;<i> -	    LOG_ERROR(&quot;parameter error, should be one parameter for  
</I>&gt;<i> BULKOUT endpoint&quot;);
</I>&gt;<i> +		LOG_ERROR(&quot;parameter error, should be one parameter for BULKOUT  
</I>&gt;<i> endpoint&quot;);
</I>&gt;<i> 		return ERROR_OK;
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> @@ -1175,7 +1176,7 @@
</I>&gt;<i> {
</I>&gt;<i> 	int available_scans = MAX_PENDING_SCAN_RESULTS -  
</I>&gt;<i> pending_scan_results_length;
</I>&gt;<i> 	int available_bytes = VSLLINK_BufferSize -  
</I>&gt;<i> vsllink_usb_out_buffer_idx;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if (scans &gt; available_scans || bytes &gt; available_bytes)
</I>&gt;<i> 	{
</I>&gt;<i> 		vsllink_tap_execute();
</I>&gt;<i> @@ -1218,9 +1219,9 @@
</I>&gt;<i>
</I>&gt;<i> 	if (vsllink_tms_data_len &gt; 0)
</I>&gt;<i> 	{
</I>&gt;<i> -		if((cur_state != TAP_RESET) &amp;&amp; (cur_state != TAP_IDLE) &amp;&amp;  
</I>&gt;<i> (cur_state != TAP_IRPAUSE) &amp;&amp; (cur_state != TAP_DRPAUSE))
</I>&gt;<i> +		if((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() !=  
</I>&gt;<i> TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE) &amp;&amp; (tap_get_state() !=  
</I>&gt;<i> TAP_DRPAUSE))
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_WARNING(&quot;%s is not in RESET or IDLE or PAUSR state&quot;,  
</I>&gt;<i> jtag_state_name(cur_state));
</I>&gt;<i> +			LOG_WARNING(&quot;%s is not in RESET or IDLE or PAUSR state&quot;,  
</I>&gt;<i> tap_state_name(tap_get_state()));
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		if (vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] &amp; (1 &lt;&lt;  
</I>&gt;<i> (vsllink_tms_data_len - 1)))
</I>&gt;<i> @@ -1238,7 +1239,7 @@
</I>&gt;<i> 			vsllink_tms_data_len = 0;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if (vsllink_usb_out_buffer_idx &gt; 3)
</I>&gt;<i> 	{
</I>&gt;<i> 		if (vsllink_usb_out_buffer[0] == VSLLINK_CMD_HW_JTAGSEQCMD)
</I>&gt;<i> @@ -1248,7 +1249,7 @@
</I>&gt;<i> 		}
</I>&gt;<i>
</I>&gt;<i> 		result = vsllink_usb_message(vsllink_jtag_handle,  
</I>&gt;<i> vsllink_usb_out_buffer_idx, vsllink_usb_in_want_length);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 		if (result == vsllink_usb_in_want_length)
</I>&gt;<i> 		{
</I>&gt;<i> 			for (i = 0; i &lt; pending_scan_results_length; i++)
</I>&gt;<i> @@ -1264,7 +1265,7 @@
</I>&gt;<i> 					// IRSHIFT or DRSHIFT
</I>&gt;<i> 					buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer,  
</I>&gt;<i> 0, length);
</I>&gt;<i> 					first += (length + offset + 7) &gt;&gt; 3;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 					DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits):&quot;, length);
</I>&gt;<i> #ifdef _DEBUG_JTAG_IO_
</I>&gt;<i> 					vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
</I>&gt;<i> @@ -1290,7 +1291,7 @@
</I>&gt;<i> 			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;,  
</I>&gt;<i> result, vsllink_usb_in_want_length);
</I>&gt;<i> 			return ERROR_JTAG_QUEUE_FAILED;
</I>&gt;<i> 		}
</I>&gt;<i> -		
</I>&gt;<i> +
</I>&gt;<i> 		vsllink_tap_init();
</I>&gt;<i> 	}
</I>&gt;<i>
</I>&gt;<i> @@ -1308,19 +1309,19 @@
</I>&gt;<i> 	struct usb_bus *busses;
</I>&gt;<i> 	struct usb_bus *bus;
</I>&gt;<i> 	struct usb_device *dev;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	vsllink_jtag_t *result;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	result = (vsllink_jtag_t*) malloc(sizeof(vsllink_jtag_t));
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	usb_init();
</I>&gt;<i> 	usb_find_busses();
</I>&gt;<i> 	usb_find_devices();
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	busses = usb_get_busses();
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	/* find vsllink_jtag device in usb bus */
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	for (bus = busses; bus; bus = bus-&gt;next)
</I>&gt;<i> 	{
</I>&gt;<i> 		for (dev = bus-&gt;devices; dev; dev = dev-&gt;next)
</I>&gt;<i> @@ -1328,23 +1329,23 @@
</I>&gt;<i> 			if ((dev-&gt;descriptor.idVendor == vsllink_vid) &amp;&amp; (dev- 
</I>&gt;<i> &gt;descriptor.idProduct == vsllink_pid))
</I>&gt;<i> 			{
</I>&gt;<i> 				result-&gt;usb_handle = usb_open(dev);
</I>&gt;<i> -				
</I>&gt;<i> +
</I>&gt;<i> 				/* usb_set_configuration required under win32 */
</I>&gt;<i> 				usb_set_configuration(result-&gt;usb_handle, dev- 
</I>&gt;<i> &gt;config[0].bConfigurationValue);
</I>&gt;<i> 				usb_claim_interface(result-&gt;usb_handle, 0);
</I>&gt;<i> -				
</I>&gt;<i> +
</I>&gt;<i> #if 0
</I>&gt;<i> -				/*
</I>&gt;<i> +				/*
</I>&gt;<i> 				 * This makes problems under Mac OS X. And is not needed
</I>&gt;<i> 				 * under Windows. Hopefully this will not break a linux build
</I>&gt;<i> 				 */
</I>&gt;<i> 				usb_set_altinterface(result-&gt;usb_handle, 0);
</I>&gt;<i> -#endif				
</I>&gt;<i> +#endif
</I>&gt;<i> 				return result;
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	free(result);
</I>&gt;<i> 	return NULL;
</I>&gt;<i> }
</I>&gt;<i> @@ -1359,7 +1360,7 @@
</I>&gt;<i> int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int  
</I>&gt;<i> out_length, int in_length)
</I>&gt;<i> {
</I>&gt;<i> 	int result;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	result = vsllink_usb_write(vsllink_jtag, out_length);
</I>&gt;<i> 	if (result == out_length)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -1389,18 +1390,18 @@
</I>&gt;<i> int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length)
</I>&gt;<i> {
</I>&gt;<i> 	int result;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	if (out_length &gt; VSLLINK_BufferSize)
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;vsllink_jtag_write illegal out_length=%d (max=%d)&quot;,  
</I>&gt;<i> out_length, VSLLINK_BufferSize);
</I>&gt;<i> 		return -1;
</I>&gt;<i> 	}
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	result = usb_bulk_write(vsllink_jtag-&gt;usb_handle, vsllink_bulkout, \
</I>&gt;<i> 		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;,  
</I>&gt;<i> out_length, result);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> #ifdef _DEBUG_USB_COMMS_
</I>&gt;<i> 	LOG_DEBUG(&quot;USB out:&quot;);
</I>&gt;<i> 	vsllink_debug_buffer(vsllink_usb_out_buffer, out_length);
</I>&gt;<i> @@ -1420,7 +1421,7 @@
</I>&gt;<i> 		(char *)vsllink_usb_in_buffer, VSLLINK_BufferSize,  
</I>&gt;<i> VSLLINK_USB_TIMEOUT);
</I>&gt;<i>
</I>&gt;<i> 	DEBUG_JTAG_IO(&quot;vsllink_usb_read, result = %d&quot;, result);
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> #ifdef _DEBUG_USB_COMMS_
</I>&gt;<i> 	LOG_DEBUG(&quot;USB in:&quot;);
</I>&gt;<i> 	vsllink_debug_buffer(vsllink_usb_in_buffer, result);
</I>&gt;<i> @@ -1436,7 +1437,7 @@
</I>&gt;<i> 	char s[4];
</I>&gt;<i> 	int i;
</I>&gt;<i> 	int j;
</I>&gt;<i> -	
</I>&gt;<i> +
</I>&gt;<i> 	for (i = 0; i &lt; length; i += BYTES_PER_LINE)
</I>&gt;<i> 	{
</I>&gt;<i> 		snprintf(line, 5, &quot;%04x&quot;, i);
</I>&gt;<i> Index: src/jtag/jtag.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/jtag.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/jtag.c	(working copy)
</I>&gt;<i> @@ -4,6 +4,10 @@
</I>&gt;<i>   
</I>&gt;<i> *                                                                         *
</I>&gt;<i>  *   Copyright (C) 2007,2008 &#216;yvind  
</I>&gt;<i> Harboe                                 *
</I>&gt;<i>  *    
</I>&gt;<i> oyvind 
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">.harboe at zylin.com</A>                                               *
</I>&gt;<i> + *
</I>&gt;<i> + *   Copyright (C) 2009 SoftPLC Corporation
</I>&gt;<i> + * 	 <A HREF="http://softplc.com">http://softplc.com</A>
</I>&gt;<i> + *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">dick at softplc.com</A>
</I>&gt;<i>   
</I>&gt;<i> *                                                                         *
</I>&gt;<i>  *   This program is free software; you can redistribute it and/or  
</I>&gt;<i> modify  *
</I>&gt;<i>  *   it under the terms of the GNU General Public License as  
</I>&gt;<i> published by  *
</I>&gt;<i> @@ -51,52 +55,6 @@
</I>&gt;<i> #define CMD_QUEUE_PAGE_SIZE (1024 * 1024)
</I>&gt;<i> static cmd_queue_page_t *cmd_queue_pages = NULL;
</I>&gt;<i>
</I>&gt;<i> -/* tap_move[i][j]: tap movement command to go from state i to state j
</I>&gt;<i> - * 0: Test-Logic-Reset
</I>&gt;<i> - * 1: Run-Test/Idle
</I>&gt;<i> - * 2: Shift-DR
</I>&gt;<i> - * 3: Pause-DR
</I>&gt;<i> - * 4: Shift-IR
</I>&gt;<i> - * 5: Pause-IR
</I>&gt;<i> - *
</I>&gt;<i> - * DRSHIFT-&gt;DRSHIFT and IRSHIFT-&gt;IRSHIFT have to be caught in  
</I>&gt;<i> interface specific code
</I>&gt;<i> - */
</I>&gt;<i> -u8 tap_move[6][6] =
</I>&gt;<i> -{
</I>&gt;<i> -/*	  RESET  IDLE  DRSHIFT  DRPAUSE  IRSHIFT  IRPAUSE             */
</I>&gt;<i> -	{  0x7f, 0x00,    0x17,    0x0a,    0x1b,    0x16},	/* RESET */
</I>&gt;<i> -	{  0x7f, 0x00,    0x25,    0x05,    0x2b,    0x0b},	/* IDLE */
</I>&gt;<i> -	{  0x7f, 0x31,    0x00,    0x01,    0x0f,    0x2f},	/* DRSHIFT  */
</I>&gt;<i> -	{  0x7f, 0x30,    0x20,    0x17,    0x1e,    0x2f},	/* DRPAUSE  */
</I>&gt;<i> -	{  0x7f, 0x31,    0x07,    0x17,    0x00,    0x01},	/* IRSHIFT  */
</I>&gt;<i> -	{  0x7f, 0x30,    0x1c,    0x17,    0x20,    0x2f}	/* IRPAUSE  */
</I>&gt;<i> -};
</I>&gt;<i> -
</I>&gt;<i> -int tap_move_map[16] = {
</I>&gt;<i> -	0, -1, -1,  2, -1,  3, -1, -1,
</I>&gt;<i> -	1, -1, -1,  4, -1,  5, -1, -1
</I>&gt;<i> -};
</I>&gt;<i> -
</I>&gt;<i> -tap_transition_t tap_transitions[16] =
</I>&gt;<i> -{
</I>&gt;<i> -	{TAP_RESET, 		TAP_IDLE},			/* RESET */
</I>&gt;<i> -	{TAP_IRSELECT, 	TAP_DRCAPTURE},		/* DRSELECT */
</I>&gt;<i> -	{TAP_DREXIT1,	TAP_DRSHIFT},		/* DRCAPTURE  */
</I>&gt;<i> -	{TAP_DREXIT1, 	TAP_DRSHIFT},		/* DRSHIFT  */
</I>&gt;<i> -	{TAP_DRUPDATE,  TAP_DRPAUSE}, 		/* DREXIT1 */
</I>&gt;<i> -	{TAP_DREXIT2, 	TAP_DRPAUSE},		/* DRPAUSE  */
</I>&gt;<i> -	{TAP_DRUPDATE,  TAP_DRSHIFT},		/* DREXIT2 */
</I>&gt;<i> -	{TAP_DRSELECT, 	TAP_IDLE},			/* DRUPDATE  */
</I>&gt;<i> -	{TAP_DRSELECT, 	TAP_IDLE},			/* IDLE */
</I>&gt;<i> -	{TAP_RESET, 		TAP_IRCAPTURE},		/* IRSELECT */
</I>&gt;<i> -	{TAP_IREXIT1, 	TAP_IRSHIFT},		/* IRCAPTURE  */
</I>&gt;<i> -	{TAP_IREXIT1, 	TAP_IRSHIFT},		/* IRSHIFT  */
</I>&gt;<i> -	{TAP_IRUPDATE,  TAP_IRPAUSE}, 		/* IREXIT1 */
</I>&gt;<i> -	{TAP_IREXIT2, 	TAP_IRPAUSE},		/* IRPAUSE  */
</I>&gt;<i> -	{TAP_IRUPDATE,  TAP_IRSHIFT},		/* IREXIT2 */
</I>&gt;<i> -	{TAP_DRSELECT, 	TAP_IDLE}			/* IRUPDATE  */
</I>&gt;<i> -};
</I>&gt;<i> -
</I>&gt;<i> char* jtag_event_strings[] =
</I>&gt;<i> {
</I>&gt;<i> 	&quot;JTAG controller reset (RESET or TRST)&quot;
</I>&gt;<i> @@ -109,13 +67,6 @@
</I>&gt;<i> 	{ .name = NULL, .value = -1 }
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> -/* kludge!!!! these are just global variables that the
</I>&gt;<i> - * interface use internally. They really belong
</I>&gt;<i> - * inside the drivers, but we don't want to break
</I>&gt;<i> - * linking the drivers!!!!
</I>&gt;<i> - */
</I>&gt;<i> -enum tap_state end_state = TAP_RESET;
</I>&gt;<i> -enum tap_state cur_state = TAP_RESET;
</I>&gt;<i> int jtag_trst = 0;
</I>&gt;<i> int jtag_srst = 0;
</I>&gt;<i>
</I>&gt;<i> @@ -124,8 +75,8 @@
</I>&gt;<i> static jtag_tap_t *jtag_all_taps = NULL;
</I>&gt;<i>
</I>&gt;<i> enum reset_types jtag_reset_config = RESET_NONE;
</I>&gt;<i> -enum tap_state cmd_queue_end_state = TAP_RESET;
</I>&gt;<i> -enum tap_state cmd_queue_cur_state = TAP_RESET;
</I>&gt;<i> +tap_state_t cmd_queue_end_state = TAP_RESET;
</I>&gt;<i> +tap_state_t cmd_queue_cur_state = TAP_RESET;
</I>&gt;<i>
</I>&gt;<i> int jtag_verify_capture_ir = 1;
</I>&gt;<i>
</I>&gt;<i> @@ -257,9 +208,9 @@
</I>&gt;<i> int jtag_speed = 0;
</I>&gt;<i>
</I>&gt;<i> /* forward declarations */
</I>&gt;<i> -void jtag_add_pathmove(int num_states, enum tap_state *path);
</I>&gt;<i> -void jtag_add_runtest(int num_cycles, enum tap_state endstate);
</I>&gt;<i> -void jtag_add_end_state(enum tap_state endstate);
</I>&gt;<i> +void jtag_add_pathmove(int num_states, tap_state_t *path);
</I>&gt;<i> +void jtag_add_runtest(int num_cycles, tap_state_t endstate);
</I>&gt;<i> +void jtag_add_end_state(tap_state_t endstate);
</I>&gt;<i> void jtag_add_sleep(u32 us);
</I>&gt;<i> int jtag_execute_queue(void);
</I>&gt;<i>
</I>&gt;<i> @@ -550,7 +501,7 @@
</I>&gt;<i> 		jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -static void jtag_prelude(enum tap_state state)
</I>&gt;<i> +static void jtag_prelude(tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	jtag_prelude1();
</I>&gt;<i>
</I>&gt;<i> @@ -560,7 +511,7 @@
</I>&gt;<i> 	cmd_queue_cur_state = cmd_queue_end_state;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void jtag_add_ir_scan(int num_fields, scan_field_t *fields, enum  
</I>&gt;<i> tap_state state)
</I>&gt;<i> +void jtag_add_ir_scan(int num_fields, scan_field_t *fields,  
</I>&gt;<i> tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	int retval;
</I>&gt;<i>
</I>&gt;<i> @@ -571,7 +522,7 @@
</I>&gt;<i> 		jtag_error=retval;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int MINIDRIVER(interface_jtag_add_ir_scan)(int num_fields,  
</I>&gt;<i> scan_field_t *fields, enum tap_state state)
</I>&gt;<i> +int MINIDRIVER(interface_jtag_add_ir_scan)(int num_fields,  
</I>&gt;<i> scan_field_t *fields, tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	jtag_command_t **last_cmd;
</I>&gt;<i> 	jtag_tap_t *tap;
</I>&gt;<i> @@ -657,7 +608,7 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields,  
</I>&gt;<i> enum tap_state state)
</I>&gt;<i> +void jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields,  
</I>&gt;<i> tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	int retval;
</I>&gt;<i>
</I>&gt;<i> @@ -668,7 +619,7 @@
</I>&gt;<i> 		jtag_error=retval;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int MINIDRIVER(interface_jtag_add_plain_ir_scan)(int num_fields,  
</I>&gt;<i> scan_field_t *fields, enum tap_state state)
</I>&gt;<i> +int MINIDRIVER(interface_jtag_add_plain_ir_scan)(int num_fields,  
</I>&gt;<i> scan_field_t *fields, tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i> 	jtag_command_t **last_cmd;
</I>&gt;<i> @@ -704,7 +655,7 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void jtag_add_dr_scan(int num_fields, scan_field_t *fields, enum  
</I>&gt;<i> tap_state state)
</I>&gt;<i> +void jtag_add_dr_scan(int num_fields, scan_field_t *fields,  
</I>&gt;<i> tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	int retval;
</I>&gt;<i>
</I>&gt;<i> @@ -715,7 +666,7 @@
</I>&gt;<i> 		jtag_error=retval;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int MINIDRIVER(interface_jtag_add_dr_scan)(int num_fields,  
</I>&gt;<i> scan_field_t *fields, enum tap_state state)
</I>&gt;<i> +int MINIDRIVER(interface_jtag_add_dr_scan)(int num_fields,  
</I>&gt;<i> scan_field_t *fields, tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	int j;
</I>&gt;<i> 	int nth_tap;
</I>&gt;<i> @@ -818,7 +769,7 @@
</I>&gt;<i> 		int num_fields,
</I>&gt;<i> 		const int *num_bits,
</I>&gt;<i> 		const u32 *value,
</I>&gt;<i> -		enum tap_state end_state)
</I>&gt;<i> +		tap_state_t end_state)
</I>&gt;<i> {
</I>&gt;<i> 	int nth_tap;
</I>&gt;<i> 	int field_count = 0;
</I>&gt;<i> @@ -912,7 +863,7 @@
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields,  
</I>&gt;<i> enum tap_state state)
</I>&gt;<i> +void jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields,  
</I>&gt;<i> tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	int retval;
</I>&gt;<i>
</I>&gt;<i> @@ -923,7 +874,7 @@
</I>&gt;<i> 		jtag_error=retval;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int MINIDRIVER(interface_jtag_add_plain_dr_scan)(int num_fields,  
</I>&gt;<i> scan_field_t *fields, enum tap_state state)
</I>&gt;<i> +int MINIDRIVER(interface_jtag_add_plain_dr_scan)(int num_fields,  
</I>&gt;<i> scan_field_t *fields, tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	int i;
</I>&gt;<i> 	jtag_command_t **last_cmd = jtag_get_last_command_p();
</I>&gt;<i> @@ -971,7 +922,7 @@
</I>&gt;<i>
</I>&gt;<i> int MINIDRIVER(interface_jtag_add_tlr)(void)
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state state = TAP_RESET;
</I>&gt;<i> +	tap_state_t state = TAP_RESET;
</I>&gt;<i> 	jtag_command_t **last_cmd = jtag_get_last_command_p();
</I>&gt;<i>
</I>&gt;<i> 	/* allocate memory for a new list member */
</I>&gt;<i> @@ -986,14 +937,14 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void jtag_add_pathmove(int num_states, enum tap_state *path)
</I>&gt;<i> +void jtag_add_pathmove(int num_states, tap_state_t *path)
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state cur_state=cmd_queue_cur_state;
</I>&gt;<i> +	tap_state_t cur_state=cmd_queue_cur_state;
</I>&gt;<i> 	int i;
</I>&gt;<i> 	int retval;
</I>&gt;<i>
</I>&gt;<i> 	/* the last state has to be a stable state */
</I>&gt;<i> -	if (tap_move_map[path[num_states - 1]] == -1)
</I>&gt;<i> +	if (!tap_is_state_stable(path[num_states - 1]))
</I>&gt;<i> 	{
</I>&gt;<i> 		LOG_ERROR(&quot;BUG: TAP path doesn't finish in a stable state&quot;);
</I>&gt;<i> 		exit(-1);
</I>&gt;<i> @@ -1006,10 +957,10 @@
</I>&gt;<i> 			LOG_ERROR(&quot;BUG: TAP_RESET is not a valid state for pathmove  
</I>&gt;<i> sequences&quot;);
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i> -		if ((tap_transitions[cur_state].low != path[i])&amp;&amp;
</I>&gt;<i> -				(tap_transitions[cur_state].high != path[i]))
</I>&gt;<i> +		if ( tap_state_transition(cur_state, TRUE)  != path[i]
</I>&gt;<i> +		  &amp;&amp; tap_state_transition(cur_state, FALSE) != path[i])
</I>&gt;<i> 		{
</I>&gt;<i> -			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> jtag_state_name(cur_state), jtag_state_name(path[i]));
</I>&gt;<i> +			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;,  
</I>&gt;<i> tap_state_name(cur_state), tap_state_name(path[i]));
</I>&gt;<i> 			exit(-1);
</I>&gt;<i> 		}
</I>&gt;<i> 		cur_state = path[i];
</I>&gt;<i> @@ -1023,7 +974,7 @@
</I>&gt;<i> 		jtag_error=retval;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int MINIDRIVER(interface_jtag_add_pathmove)(int num_states, enum  
</I>&gt;<i> tap_state *path)
</I>&gt;<i> +int MINIDRIVER(interface_jtag_add_pathmove)(int num_states,  
</I>&gt;<i> tap_state_t *path)
</I>&gt;<i> {
</I>&gt;<i> 	jtag_command_t **last_cmd = jtag_get_last_command_p();
</I>&gt;<i> 	int i;
</I>&gt;<i> @@ -1036,7 +987,7 @@
</I>&gt;<i>
</I>&gt;<i> 	(*last_cmd)-&gt;cmd.pathmove =  
</I>&gt;<i> cmd_queue_alloc(sizeof(pathmove_command_t));
</I>&gt;<i> 	(*last_cmd)-&gt;cmd.pathmove-&gt;num_states = num_states;
</I>&gt;<i> -	(*last_cmd)-&gt;cmd.pathmove-&gt;path = cmd_queue_alloc(sizeof(enum  
</I>&gt;<i> tap_state) * num_states);
</I>&gt;<i> +	(*last_cmd)-&gt;cmd.pathmove-&gt;path =  
</I>&gt;<i> cmd_queue_alloc(sizeof(tap_state_t) * num_states);
</I>&gt;<i>
</I>&gt;<i> 	for (i = 0; i &lt; num_states; i++)
</I>&gt;<i> 		(*last_cmd)-&gt;cmd.pathmove-&gt;path[i] = path[i];
</I>&gt;<i> @@ -1044,7 +995,7 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -int MINIDRIVER(interface_jtag_add_runtest)(int num_cycles, enum  
</I>&gt;<i> tap_state state)
</I>&gt;<i> +int MINIDRIVER(interface_jtag_add_runtest)(int num_cycles,  
</I>&gt;<i> tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	jtag_command_t **last_cmd = jtag_get_last_command_p();
</I>&gt;<i>
</I>&gt;<i> @@ -1061,7 +1012,7 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void jtag_add_runtest(int num_cycles, enum tap_state state)
</I>&gt;<i> +void jtag_add_runtest(int num_cycles, tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	int retval;
</I>&gt;<i>
</I>&gt;<i> @@ -1093,19 +1044,10 @@
</I>&gt;<i> {
</I>&gt;<i> 	int retval;
</I>&gt;<i>
</I>&gt;<i> -	/* &quot;if (tap_move_map[cm_queue_cur_state] != -1)&quot; is of no help  
</I>&gt;<i> when cur_state==TAP_IDLE */
</I>&gt;<i> -	switch(cmd_queue_cur_state)
</I>&gt;<i> +	if( !tap_is_state_stable(cmd_queue_cur_state) )
</I>&gt;<i> 	{
</I>&gt;<i> -	case TAP_DRSHIFT:
</I>&gt;<i> -	case TAP_IDLE:
</I>&gt;<i> -	case TAP_RESET:
</I>&gt;<i> -	case TAP_DRPAUSE:
</I>&gt;<i> -	case TAP_IRSHIFT:
</I>&gt;<i> -	case TAP_IRPAUSE:
</I>&gt;<i> -		 break;			/* above stable states are OK */
</I>&gt;<i> -	default:
</I>&gt;<i> 		 LOG_ERROR( &quot;jtag_add_clocks() was called with TAP in non-stable  
</I>&gt;<i> state \&quot;%s\&quot;&quot;,
</I>&gt;<i> -				 jtag_state_name(cmd_queue_cur_state) );
</I>&gt;<i> +				 tap_state_name(cmd_queue_cur_state) );
</I>&gt;<i> 		 jtag_error = ERROR_JTAG_NOT_STABLE_STATE;
</I>&gt;<i> 		 return;
</I>&gt;<i> 	}
</I>&gt;<i> @@ -1114,8 +1056,8 @@
</I>&gt;<i> 	{
</I>&gt;<i> 		jtag_prelude1();
</I>&gt;<i>
</I>&gt;<i> -		retval=interface_jtag_add_clocks(num_cycles);
</I>&gt;<i> -		if (retval!=ERROR_OK)
</I>&gt;<i> +		retval = interface_jtag_add_clocks(num_cycles);
</I>&gt;<i> +		if (retval != ERROR_OK)
</I>&gt;<i> 			jtag_error=retval;
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> @@ -1240,7 +1182,7 @@
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -void jtag_add_end_state(enum tap_state state)
</I>&gt;<i> +void jtag_add_end_state(tap_state_t state)
</I>&gt;<i> {
</I>&gt;<i> 	cmd_queue_end_state = state;
</I>&gt;<i> 	if ((cmd_queue_end_state == TAP_DRSHIFT)||(cmd_queue_end_state ==  
</I>&gt;<i> TAP_IRSHIFT))
</I>&gt;<i> @@ -2708,7 +2650,7 @@
</I>&gt;<i>
</I>&gt;<i> int handle_endstate_command(struct command_context_s *cmd_ctx, char  
</I>&gt;<i> *cmd, char **args, int argc)
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state state;
</I>&gt;<i> +	tap_state_t state;
</I>&gt;<i>
</I>&gt;<i> 	if (argc &lt; 1)
</I>&gt;<i> 	{
</I>&gt;<i> @@ -2718,14 +2660,14 @@
</I>&gt;<i> 	{
</I>&gt;<i> 		for (state = 0; state &lt; 16; state++)
</I>&gt;<i> 		{
</I>&gt;<i> -			if (strcmp(args[0], jtag_state_name(state)) == 0)
</I>&gt;<i> +			if (strcmp(args[0], tap_state_name(state)) == 0)
</I>&gt;<i> 			{
</I>&gt;<i> 				jtag_add_end_state(state);
</I>&gt;<i> 				jtag_execute_queue();
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> -	command_print(cmd_ctx, &quot;current endstate: %s&quot;,  
</I>&gt;<i> jtag_state_name(cmd_queue_end_state));
</I>&gt;<i> +	command_print(cmd_ctx, &quot;current endstate: %s&quot;,  
</I>&gt;<i> tap_state_name(cmd_queue_end_state));
</I>&gt;<i>
</I>&gt;<i> 	return ERROR_OK;
</I>&gt;<i> }
</I>&gt;<i> @@ -2979,9 +2921,248 @@
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -/* map state number to SVF state string */
</I>&gt;<i> -const char* jtag_state_name(enum tap_state state)
</I>&gt;<i> +/*-----&lt;Cable Helper API&gt;---------------------------------------*/
</I>&gt;<i> +
</I>&gt;<i> +/*  these Cable Helper API functions are all documented in the  
</I>&gt;<i> jtag.h header file,
</I>&gt;<i> +	using a Doxygen format.  And since Doxygen's configuration file  
</I>&gt;<i> &quot;Doxyfile&quot;,
</I>&gt;<i> +	is setup to prefer its docs in the header file, no documentation  
</I>&gt;<i> is here, for
</I>&gt;<i> +	if it were, it would have to be doubly maintained.
</I>&gt;<i> +*/
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * @see tap_set_state() and tap_get_state() accessors.
</I>&gt;<i> + * Actual name is not important since accessors hide it.
</I>&gt;<i> + */
</I>&gt;<i> +static tap_state_t state_follower = TAP_RESET;
</I>&gt;<i> +
</I>&gt;<i> +void tap_set_state_impl( tap_state_t new_state )
</I>&gt;<i> {
</I>&gt;<i> +	/* this is the state we think the TAPs are in now, was cur_state */
</I>&gt;<i> +	state_follower = new_state;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +tap_state_t tap_get_state()
</I>&gt;<i> +{
</I>&gt;<i> +	return state_follower;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * @see tap_set_end_state() and tap_get_end_state() accessors.
</I>&gt;<i> + * Actual name is not important because accessors hide it.
</I>&gt;<i> + */
</I>&gt;<i> +static tap_state_t end_state_follower = TAP_RESET;
</I>&gt;<i> +
</I>&gt;<i> +void tap_set_end_state( tap_state_t new_end_state )
</I>&gt;<i> +{
</I>&gt;<i> +	/* this is the state we think the TAPs will be in at completion of  
</I>&gt;<i> the
</I>&gt;<i> +	   current TAP operation, was end_state
</I>&gt;<i> +	*/
</I>&gt;<i> +	end_state_follower = new_end_state;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +tap_state_t tap_get_end_state()
</I>&gt;<i> +{
</I>&gt;<i> +	return end_state_follower;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +int tap_move_ndx( tap_state_t astate )
</I>&gt;<i> +{
</I>&gt;<i> +	/* given a stable state, return the index into the tms_seqs[]  
</I>&gt;<i> array within tap_get_tms_path() */
</I>&gt;<i> +
</I>&gt;<i> +	/* old version
</I>&gt;<i> +	const static int move_map[16] =
</I>&gt;<i> +	{
</I>&gt;<i> +		0, -1, -1,  2, -1,  3, -1, -1,
</I>&gt;<i> +		1, -1, -1,  4, -1,  5, -1, -1
</I>&gt;<i> +	};
</I>&gt;<i> +	*/
</I>&gt;<i> +
</I>&gt;<i> +	int ndx;
</I>&gt;<i> +
</I>&gt;<i> +	switch( astate )
</I>&gt;<i> +	{
</I>&gt;<i> +	case TAP_RESET:		ndx = 0;			break;
</I>&gt;<i> +	case TAP_DRSHIFT:	ndx = 2;			break;
</I>&gt;<i> +	case TAP_DRPAUSE:	ndx = 3;			break;
</I>&gt;<i> +	case TAP_IDLE:		ndx = 1;			break;
</I>&gt;<i> +	case TAP_IRSHIFT:	ndx = 4;			break;
</I>&gt;<i> +	case TAP_IRPAUSE:	ndx = 5;			break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		LOG_ERROR( &quot;fatal: unstable state \&quot;%s\&quot; used in tap_move_ndx()&quot;,  
</I>&gt;<i> tap_state_name(astate) );
</I>&gt;<i> +		exit(1);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return ndx;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +int tap_get_tms_path( tap_state_t from, tap_state_t to )
</I>&gt;<i> +{
</I>&gt;<i> +	/* tap_move[i][j]: tap movement command to go from state i to  
</I>&gt;<i> state j
</I>&gt;<i> +	 * 0: Test-Logic-Reset
</I>&gt;<i> +	 * 1: Run-Test/Idle
</I>&gt;<i> +	 * 2: Shift-DR
</I>&gt;<i> +	 * 3: Pause-DR
</I>&gt;<i> +	 * 4: Shift-IR
</I>&gt;<i> +	 * 5: Pause-IR
</I>&gt;<i> +	 *
</I>&gt;<i> +	 * DRSHIFT-&gt;DRSHIFT and IRSHIFT-&gt;IRSHIFT have to be caught in  
</I>&gt;<i> interface specific code
</I>&gt;<i> +	 */
</I>&gt;<i> +	const static u8 tms_seqs[6][6] =
</I>&gt;<i> +	{
</I>&gt;<i> +		/* value clocked to TMS to move from one of six stable states to  
</I>&gt;<i> another */
</I>&gt;<i> +
</I>&gt;<i> +		/* RESET  IDLE  DRSHIFT  DRPAUSE  IRSHIFT  IRPAUSE */
</I>&gt;<i> +		{  0x7f, 0x00,    0x17,    0x0a,    0x1b,    0x16 },	/* RESET */
</I>&gt;<i> +		{  0x7f, 0x00,    0x25,    0x05,    0x2b,    0x0b },	/* IDLE */
</I>&gt;<i> +		{  0x7f, 0x31,    0x00,    0x01,    0x0f,    0x2f },	/* DRSHIFT  */
</I>&gt;<i> +		{  0x7f, 0x30,    0x20,    0x17,    0x1e,    0x2f },	/* DRPAUSE  */
</I>&gt;<i> +		{  0x7f, 0x31,    0x07,    0x17,    0x00,    0x01 },	/* IRSHIFT  */
</I>&gt;<i> +		{  0x7f, 0x30,    0x1c,    0x17,    0x20,    0x2f }	/* IRPAUSE  */
</I>&gt;<i> +	};
</I>&gt;<i> +
</I>&gt;<i> +	if( !tap_is_state_stable(from) )
</I>&gt;<i> +	{
</I>&gt;<i> +		LOG_ERROR( &quot;fatal: tap_state \&quot;from\&quot; (=%s) is not stable&quot;,  
</I>&gt;<i> tap_state_name(from) );
</I>&gt;<i> +		exit(1);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if( !tap_is_state_stable(to) )
</I>&gt;<i> +	{
</I>&gt;<i> +		LOG_ERROR( &quot;fatal: tap_state \&quot;to\&quot; (=%s) is not stable&quot;,  
</I>&gt;<i> tap_state_name(to) );
</I>&gt;<i> +		exit(1);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* @todo: support other than 7 clocks ? */
</I>&gt;<i> +	return tms_seqs[tap_move_ndx(from)][tap_move_ndx(to)];
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +BOOL tap_is_state_stable(tap_state_t astate)
</I>&gt;<i> +{
</I>&gt;<i> +	BOOL is_stable;
</I>&gt;<i> +
</I>&gt;<i> +	/* 	A switch() is used because it is symbol dependent
</I>&gt;<i> +		(not value dependent like an array), and can also check bounds.
</I>&gt;<i> +	*/
</I>&gt;<i> +	switch( astate )
</I>&gt;<i> +	{
</I>&gt;<i> +	case TAP_RESET:
</I>&gt;<i> +	case TAP_IDLE:
</I>&gt;<i> +	case TAP_DRSHIFT:
</I>&gt;<i> +	case TAP_DRPAUSE:
</I>&gt;<i> +	case TAP_IRSHIFT:
</I>&gt;<i> +	case TAP_IRPAUSE:
</I>&gt;<i> +		is_stable = TRUE;
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		is_stable = FALSE;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return is_stable;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +tap_state_t tap_state_transition(tap_state_t cur_state, BOOL tms)
</I>&gt;<i> +{
</I>&gt;<i> +	tap_state_t new_state;
</I>&gt;<i> +
</I>&gt;<i> +	/* 	A switch is used because it is symbol dependent and not value  
</I>&gt;<i> dependent
</I>&gt;<i> +		like an array.  Also it can check for out of range conditions.
</I>&gt;<i> +	*/
</I>&gt;<i> +
</I>&gt;<i> +	if (tms)
</I>&gt;<i> +	{
</I>&gt;<i> +		switch (cur_state)
</I>&gt;<i> +		{
</I>&gt;<i> +		case TAP_RESET:
</I>&gt;<i> +			new_state = cur_state;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_IDLE:
</I>&gt;<i> +		case TAP_DRUPDATE:
</I>&gt;<i> +		case TAP_IRUPDATE:
</I>&gt;<i> +			new_state = TAP_DRSELECT;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_DRSELECT:
</I>&gt;<i> +			new_state = TAP_IRSELECT;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_DRCAPTURE:
</I>&gt;<i> +		case TAP_DRSHIFT:
</I>&gt;<i> +			new_state = TAP_DREXIT1;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_DREXIT1:
</I>&gt;<i> +		case TAP_DREXIT2:
</I>&gt;<i> +			new_state = TAP_DRUPDATE;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_DRPAUSE:
</I>&gt;<i> +			new_state = TAP_DREXIT2;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_IRSELECT:
</I>&gt;<i> +			new_state = TAP_RESET;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_IRCAPTURE:
</I>&gt;<i> +		case TAP_IRSHIFT:
</I>&gt;<i> +			new_state = TAP_IREXIT1;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_IREXIT1:
</I>&gt;<i> +		case TAP_IREXIT2:
</I>&gt;<i> +			new_state = TAP_IRUPDATE;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_IRPAUSE:
</I>&gt;<i> +			new_state = TAP_IREXIT2;
</I>&gt;<i> +			break;
</I>&gt;<i> +		default:
</I>&gt;<i> +			LOG_ERROR( &quot;fatal: invalid argument cur_state=%d&quot;, cur_state );
</I>&gt;<i> +			exit(1);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +	else
</I>&gt;<i> +	{
</I>&gt;<i> +		switch (cur_state)
</I>&gt;<i> +		{
</I>&gt;<i> +		case TAP_RESET:
</I>&gt;<i> +		case TAP_IDLE:
</I>&gt;<i> +		case TAP_DRUPDATE:
</I>&gt;<i> +		case TAP_IRUPDATE:
</I>&gt;<i> +			new_state = TAP_IDLE;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_DRSELECT:
</I>&gt;<i> +			new_state = TAP_DRCAPTURE;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_DRCAPTURE:
</I>&gt;<i> +		case TAP_DRSHIFT:
</I>&gt;<i> +		case TAP_DREXIT2:
</I>&gt;<i> +			new_state = TAP_DRSHIFT;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_DREXIT1:
</I>&gt;<i> +		case TAP_DRPAUSE:
</I>&gt;<i> +			new_state = TAP_DRPAUSE;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_IRSELECT:
</I>&gt;<i> +			new_state = TAP_IRCAPTURE;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_IRCAPTURE:
</I>&gt;<i> +		case TAP_IRSHIFT:
</I>&gt;<i> +		case TAP_IREXIT2:
</I>&gt;<i> +			new_state = TAP_IRSHIFT;
</I>&gt;<i> +			break;
</I>&gt;<i> +		case TAP_IREXIT1:
</I>&gt;<i> +		case TAP_IRPAUSE:
</I>&gt;<i> +			new_state = TAP_IRPAUSE;
</I>&gt;<i> +			break;
</I>&gt;<i> +		default:
</I>&gt;<i> +			LOG_ERROR( &quot;fatal: invalid argument cur_state=%d&quot;, cur_state );
</I>&gt;<i> +			exit(1);
</I>&gt;<i> +			break;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return new_state;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +const char* tap_state_name(tap_state_t state)
</I>&gt;<i> +{
</I>&gt;<i> 	const char* ret;
</I>&gt;<i>
</I>&gt;<i> 	switch( state )
</I>&gt;<i> @@ -3008,3 +3189,4 @@
</I>&gt;<i> 	return ret;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> +/*-----&lt;/Cable Helper API&gt;--------------------------------------*/
</I>&gt;<i> Index: src/jtag/jtag.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/jtag.h	(revision 1363)
</I>&gt;<i> +++ src/jtag/jtag.h	(working copy)
</I>&gt;<i> @@ -1,25 +1,25 @@
</I>&gt;<i> / 
</I>&gt;<i> ***************************************************************************
</I>&gt;<i> - *   Copyright (C) 2005 by Dominic  
</I>&gt;<i> Rath                                    *
</I>&gt;<i> - *    
</I>&gt;<i> Dominic 
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">.Rath at gmx.de</A>                                                   *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   Copyright (C) 2007,2008 &#216;yvind  
</I>&gt;<i> Harboe                                 *
</I>&gt;<i> - *    
</I>&gt;<i> oyvind 
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">.harboe at zylin.com</A>                                               *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   This program is free software; you can redistribute it and/or  
</I>&gt;<i> modify  *
</I>&gt;<i> - *   it under the terms of the GNU General Public License as  
</I>&gt;<i> published by  *
</I>&gt;<i> - *   the Free Software Foundation; either version 2 of the License,  
</I>&gt;<i> or     *
</I>&gt;<i> - *   (at your option) any later  
</I>&gt;<i> version.                                   *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   This program is distributed in the hope that it will be  
</I>&gt;<i> useful,       *
</I>&gt;<i> - *   but WITHOUT ANY WARRANTY; without even the implied warranty  
</I>&gt;<i> of        *
</I>&gt;<i> - *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See  
</I>&gt;<i> the         *
</I>&gt;<i> - *   GNU General Public License for more  
</I>&gt;<i> details.                          *
</I>&gt;<i> -  
</I>&gt;<i> *                                                                         *
</I>&gt;<i> - *   You should have received a copy of the GNU General Public  
</I>&gt;<i> License     *
</I>&gt;<i> - *   along with this program; if not, write to  
</I>&gt;<i> the                         *
</I>&gt;<i> - *   Free Software Foundation,  
</I>&gt;<i> Inc.,                                       *
</I>&gt;<i> - *   59 Temple Place - Suite 330, Boston, MA  02111-1307,  
</I>&gt;<i> USA.             *
</I>&gt;<i> -  
</I>&gt;<i> ***************************************************************************/
</I>&gt;<i> +*   Copyright (C) 2005 by Dominic  
</I>&gt;<i> Rath                                    *
</I>&gt;<i> +*    
</I>&gt;<i> Dominic 
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">.Rath at gmx.de</A>                                                   *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   Copyright (C) 2007,2008 &#216;yvind  
</I>&gt;<i> Harboe                                 *
</I>&gt;<i> +*    
</I>&gt;<i> oyvind 
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">.harboe at zylin.com</A>                                               *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   This program is free software; you can redistribute it and/or  
</I>&gt;<i> modify  *
</I>&gt;<i> +*   it under the terms of the GNU General Public License as  
</I>&gt;<i> published by  *
</I>&gt;<i> +*   the Free Software Foundation; either version 2 of the License,  
</I>&gt;<i> or     *
</I>&gt;<i> +*   (at your option) any later  
</I>&gt;<i> version.                                   *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   This program is distributed in the hope that it will be  
</I>&gt;<i> useful,       *
</I>&gt;<i> +*   but WITHOUT ANY WARRANTY; without even the implied warranty  
</I>&gt;<i> of        *
</I>&gt;<i> +*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See  
</I>&gt;<i> the         *
</I>&gt;<i> +*   GNU General Public License for more  
</I>&gt;<i> details.                          *
</I>&gt;<i> + 
</I>&gt;<i> *                                                                         *
</I>&gt;<i> +*   You should have received a copy of the GNU General Public  
</I>&gt;<i> License     *
</I>&gt;<i> +*   along with this program; if not, write to  
</I>&gt;<i> the                         *
</I>&gt;<i> +*   Free Software Foundation,  
</I>&gt;<i> Inc.,                                       *
</I>&gt;<i> +*   59 Temple Place - Suite 330, Boston, MA  02111-1307,  
</I>&gt;<i> USA.             *
</I>&gt;<i> + 
</I>&gt;<i> ***************************************************************************/
</I>&gt;<i> #ifndef JTAG_H
</I>&gt;<i> #define JTAG_H
</I>&gt;<i>
</I>&gt;<i> @@ -35,141 +35,253 @@
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i> #ifndef DEBUG_JTAG_IOZ
</I>&gt;<i> -#define DEBUG_JTAG_IOZ		64
</I>&gt;<i> +#define DEBUG_JTAG_IOZ 64
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /* 16 Tap States, from page 21 of ASSET InterTech, Inc.'s svf.pdf
</I>&gt;<i>  */
</I>&gt;<i> -typedef enum tap_state
</I>&gt;<i> -{
</I>&gt;<i> -	TAP_RESET = 0x0, TAP_IDLE = 0x8,
</I>&gt;<i> -	TAP_DRSELECT = 0x1, TAP_DRCAPTURE = 0x2, TAP_DRSHIFT = 0x3,  
</I>&gt;<i> TAP_DREXIT1 = 0x4,
</I>&gt;<i> -	TAP_DRPAUSE = 0x5, TAP_DREXIT2 = 0x6, TAP_DRUPDATE = 0x7,
</I>&gt;<i> -	TAP_IRSELECT = 0x9, TAP_IRCAPTURE = 0xa, TAP_IRSHIFT = 0xb,  
</I>&gt;<i> TAP_IREXIT1 = 0xc,
</I>&gt;<i> -	TAP_IRPAUSE = 0xd, TAP_IREXIT2 = 0xe, TAP_IRUPDATE = 0xf
</I>&gt;<i> -} tap_state_t;
</I>&gt;<i> +enum tap_state {
</I>&gt;<i> +	TAP_RESET    = 0, TAP_IDLE = 8,
</I>&gt;<i> +	TAP_DRSELECT = 1, TAP_DRCAPTURE = 2, TAP_DRSHIFT = 3, TAP_DREXIT1  
</I>&gt;<i> = 4,
</I>&gt;<i> +	TAP_DRPAUSE  = 5, TAP_DREXIT2 = 6, TAP_DRUPDATE = 7,
</I>&gt;<i> +	TAP_IRSELECT = 9, TAP_IRCAPTURE = 10, TAP_IRSHIFT = 11,  
</I>&gt;<i> TAP_IREXIT1 = 12,
</I>&gt;<i> +	TAP_IRPAUSE  = 13, TAP_IREXIT2 = 14, TAP_IRUPDATE = 15
</I>&gt;<i> +};
</I>&gt;<i>
</I>&gt;<i> +typedef enum tap_state tap_state_t;
</I>&gt;<i> +
</I>&gt;<i> +typedef unsigned		BOOL;
</I>&gt;<i> +#define TRUE			1
</I>&gt;<i> +#define FALSE		0
</I>&gt;<i> +
</I>&gt;<i> typedef struct tap_transition_s
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state high;
</I>&gt;<i> -	enum tap_state low;
</I>&gt;<i> +	tap_state_t high;
</I>&gt;<i> +	tap_state_t low;
</I>&gt;<i> } tap_transition_t;
</I>&gt;<i>
</I>&gt;<i> -extern int tap_move_map[16];	/* map 16 TAP states to 6 stable  
</I>&gt;<i> states */
</I>&gt;<i> -extern u8 tap_move[6][6];		/* value scanned to TMS to move from one  
</I>&gt;<i> of six stable states to another */
</I>&gt;<i> -extern tap_transition_t tap_transitions[16];	/* describe the TAP  
</I>&gt;<i> state diagram */
</I>&gt;<i> +//extern tap_transition_t tap_transitions[16];    /* describe the  
</I>&gt;<i> TAP state diagram */
</I>&gt;<i>
</I>&gt;<i> -extern enum tap_state end_state;		/* finish DR scans in  
</I>&gt;<i> dr_end_state */
</I>&gt;<i> -extern enum tap_state cur_state;		/* current TAP state */
</I>&gt;<i>
</I>&gt;<i> -extern enum tap_state cmd_queue_end_state;		/* finish DR scans in  
</I>&gt;<i> dr_end_state */
</I>&gt;<i> -extern enum tap_state cmd_queue_cur_state;		/* current TAP state */
</I>&gt;<i> +/*-----&lt;Cable Helper API&gt;------------------------------------------- 
</I>&gt;<i> */
</I>&gt;<i>
</I>&gt;<i> -#define TAP_MOVE(from, to) tap_move[tap_move_map[from]] 
</I>&gt;<i> [tap_move_map[to]]
</I>&gt;<i> +/* The &quot;Cable Helper API&quot; is what the cable drivers can use to help  
</I>&gt;<i> implement
</I>&gt;<i> + * their &quot;Cable API&quot;.  So a Cable Helper API is a set of helper  
</I>&gt;<i> functions used by
</I>&gt;<i> + * cable drivers, and this is different from a Cable API.  A &quot;Cable  
</I>&gt;<i> API&quot; is what
</I>&gt;<i> + * higher level code used to talk to a cable.
</I>&gt;<i> + */
</I>&gt;<i>
</I>&gt;<i> -typedef void * error_handler_t; /* Later on we can delete  
</I>&gt;<i> error_handler_t, but keep it for now to make patches more readable */
</I>&gt;<i>
</I>&gt;<i> +/** implementation of wrapper function tap_set_state() */
</I>&gt;<i> +void tap_set_state_impl(tap_state_t new_state);
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_set_state
</I>&gt;<i> + * sets the state of a &quot;state follower&quot; which tracks the state of  
</I>&gt;<i> the TAPs connected to the
</I>&gt;<i> + * cable.  The state follower is hopefully always in the same state  
</I>&gt;<i> as the actual
</I>&gt;<i> + * TAPs in the jtag chain, and will be so if there are no bugs in  
</I>&gt;<i> the tracking logic within that
</I>&gt;<i> + * cable driver. All the cable drivers call this function to  
</I>&gt;<i> indicate the state they think
</I>&gt;<i> + * the TAPs attached to their cables are in.  Because this function  
</I>&gt;<i> can also log transitions,
</I>&gt;<i> + * it will be helpful to call this function with every transition  
</I>&gt;<i> that the TAPs being manipulated
</I>&gt;<i> + * are expected to traverse, not just end points of a multi-step  
</I>&gt;<i> state path.
</I>&gt;<i> + * @param new_state is the state we think the TAPs are currently in  
</I>&gt;<i> or are about to enter.
</I>&gt;<i> + */
</I>&gt;<i> +#if defined(_DEBUG_JTAG_IO_)
</I>&gt;<i> +#define tap_set_state(new_state) \
</I>&gt;<i> +	do { \
</I>&gt;<i> +		LOG_DEBUG( &quot;tap_set_state(%s)&quot;, tap_state_name(new_state) ); \
</I>&gt;<i> +		tap_set_state_impl(new_state); \
</I>&gt;<i> +	} while (0)
</I>&gt;<i> +#else
</I>&gt;<i> +static inline void tap_set_state(tap_state_t new_state)
</I>&gt;<i> +{
</I>&gt;<i> +	tap_set_state_impl(new_state);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_get_state
</I>&gt;<i> + * gets the state of the &quot;state follower&quot; which tracks the state of  
</I>&gt;<i> the TAPs connected to
</I>&gt;<i> + * the cable.
</I>&gt;<i> + * @see tap_set_state
</I>&gt;<i> + * @return tap_state_t - The state the TAPs are in now.
</I>&gt;<i> + */
</I>&gt;<i> +tap_state_t tap_get_state(void);
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_set_end_state
</I>&gt;<i> + * sets the state of an &quot;end state follower&quot; which tracks the state  
</I>&gt;<i> that any cable driver
</I>&gt;<i> + * thinks will be the end (resultant) state of the current TAP SIR  
</I>&gt;<i> or SDR operation.  At completion
</I>&gt;<i> + * of that TAP operation this value is copied into the state  
</I>&gt;<i> follower via tap_set_state().
</I>&gt;<i> + * @param new_end_state is that state the TAPs should enter at  
</I>&gt;<i> completion of a pending TAP operation.
</I>&gt;<i> + */
</I>&gt;<i> +void        tap_set_end_state(tap_state_t new_end_state);
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_get_end_state
</I>&gt;<i> + * @see tap_set_end_state
</I>&gt;<i> + * @return tap_state_t - The state the TAPs should be in at  
</I>&gt;<i> completion of the current TAP operation.
</I>&gt;<i> + */
</I>&gt;<i> +tap_state_t tap_get_end_state(void);
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_get_tms_path
</I>&gt;<i> + * returns a 7 bit long &quot;bit sequence&quot; indicating what has to be  
</I>&gt;<i> done with TMS
</I>&gt;<i> + * during a sequence of seven TAP clock cycles in order to get from
</I>&gt;<i> + * state \a &quot;from&quot; to state \a &quot;to&quot;.
</I>&gt;<i> + * @param from is the starting state
</I>&gt;<i> + * @param to is the resultant or final state
</I>&gt;<i> + * @return int - a 7 bit sequence, with the first bit in the  
</I>&gt;<i> sequence at bit 0.
</I>&gt;<i> + */
</I>&gt;<i> +int tap_get_tms_path(tap_state_t from, tap_state_t to);
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_move_ndx
</I>&gt;<i> + * when given a stable state, returns an index from 0-5.  The index  
</I>&gt;<i> corresponds to a
</I>&gt;<i> + * sequence of stable states which are given in this order: &lt;p&gt;
</I>&gt;<i> + * { TAP_RESET, TAP_IDLE, TAP_DRSHIFT, TAP_DRPAUSE, TAP_IRSHIFT,  
</I>&gt;<i> TAP_IRPAUSE }
</I>&gt;<i> + * &lt;p&gt;
</I>&gt;<i> + * This sequence corresponds to look up tables which are used in  
</I>&gt;<i> some of the
</I>&gt;<i> + * cable drivers.
</I>&gt;<i> + * @param astate is the stable state to find in the sequence.  If a  
</I>&gt;<i> non stable
</I>&gt;<i> + *  state is passed, this may cause the program to output an error  
</I>&gt;<i> message
</I>&gt;<i> + *  and terminate.
</I>&gt;<i> + * @return int - the array (or sequence) index as described above
</I>&gt;<i> + */
</I>&gt;<i> +int tap_move_ndx(tap_state_t astate);
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_is_state_stable
</I>&gt;<i> + * returns TRUE if the \a astate is stable.
</I>&gt;<i> + */
</I>&gt;<i> +BOOL tap_is_state_stable(tap_state_t astate);
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_state_transition
</I>&gt;<i> + * takes a current TAP state and returns the next state according  
</I>&gt;<i> to the tms value.
</I>&gt;<i> + * @param current_state is the state of a TAP currently.
</I>&gt;<i> + * @param tms is either zero or non-zero, just like a real TMS line  
</I>&gt;<i> in a jtag interface.
</I>&gt;<i> + * @return tap_state_t - the next state a TAP would enter.
</I>&gt;<i> + */
</I>&gt;<i> +tap_state_t tap_state_transition(tap_state_t current_state, BOOL  
</I>&gt;<i> tms);
</I>&gt;<i> +
</I>&gt;<i> +/**
</I>&gt;<i> + * Function tap_state_name
</I>&gt;<i> + * Returns a string suitable for display representing the JTAG  
</I>&gt;<i> tap_state
</I>&gt;<i> + */
</I>&gt;<i> +const char* tap_state_name(tap_state_t state);
</I>&gt;<i> +
</I>&gt;<i> +/*-----&lt;/Cable Helper API&gt;------------------------------------------ 
</I>&gt;<i> */
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +extern tap_state_t cmd_queue_end_state;         /* finish DR scans  
</I>&gt;<i> in dr_end_state */
</I>&gt;<i> +extern tap_state_t cmd_queue_cur_state;         /* current TAP  
</I>&gt;<i> state */
</I>&gt;<i> +
</I>&gt;<i> +typedef void* error_handler_t;  /* Later on we can delete  
</I>&gt;<i> error_handler_t, but keep it for now to make patches more readable */
</I>&gt;<i> +
</I>&gt;<i> struct scan_field_s;
</I>&gt;<i> -typedef int (*in_handler_t)(u8 *in_value, void *priv, struct  
</I>&gt;<i> scan_field_s *field);
</I>&gt;<i> +typedef int (*in_handler_t)(u8* in_value, void* priv, struct  
</I>&gt;<i> scan_field_s* field);
</I>&gt;<i>
</I>&gt;<i> typedef struct scan_field_s
</I>&gt;<i> {
</I>&gt;<i> -	jtag_tap_t *tap;	/* tap pointer this instruction refers to */
</I>&gt;<i> -	int num_bits;		/* number of bits this field specifies (up to 32) */
</I>&gt;<i> -	u8 *out_value;		/* value to be scanned into the device */
</I>&gt;<i> -	u8 *out_mask;		/* only masked bits care */
</I>&gt;<i> -	u8 *in_value;		/* pointer to a 32-bit memory location to take data  
</I>&gt;<i> scanned out */
</I>&gt;<i> +	jtag_tap_t* tap;                /* tap pointer this instruction  
</I>&gt;<i> refers to */
</I>&gt;<i> +	int         num_bits;           /* number of bits this field  
</I>&gt;<i> specifies (up to 32) */
</I>&gt;<i> +	u8*         out_value;          /* value to be scanned into the  
</I>&gt;<i> device */
</I>&gt;<i> +	u8*         out_mask;           /* only masked bits care */
</I>&gt;<i> +	u8*         in_value;           /* pointer to a 32-bit memory  
</I>&gt;<i> location to take data scanned out */
</I>&gt;<i> 	/* in_check_value/mask, in_handler_error_handler, in_handler_priv  
</I>&gt;<i> can be used by the in handler, otherwise they contain garbage  */
</I>&gt;<i> -	u8 *in_check_value;	/* used to validate scan results */
</I>&gt;<i> -	u8 *in_check_mask;	/* check specified bits against check_value */
</I>&gt;<i> -	in_handler_t in_handler;/* process received buffer using this  
</I>&gt;<i> handler */
</I>&gt;<i> -	void *in_handler_priv;	/* additional information for the  
</I>&gt;<i> in_handler */
</I>&gt;<i> +	u8*          in_check_value;    /* used to validate scan results */
</I>&gt;<i> +	u8*          in_check_mask;     /* check specified bits against  
</I>&gt;<i> check_value */
</I>&gt;<i> +	in_handler_t in_handler;        /* process received buffer using  
</I>&gt;<i> this handler */
</I>&gt;<i> +	void*        in_handler_priv;   /* additional information for the  
</I>&gt;<i> in_handler */
</I>&gt;<i> } scan_field_t;
</I>&gt;<i>
</I>&gt;<i> -enum scan_type
</I>&gt;<i> -{
</I>&gt;<i> +enum scan_type {
</I>&gt;<i> 	/* IN: from device to host, OUT: from host to device */
</I>&gt;<i> 	SCAN_IN = 1, SCAN_OUT = 2, SCAN_IO = 3
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> typedef struct scan_command_s
</I>&gt;<i> {
</I>&gt;<i> -	int ir_scan;	/* instruction/not data scan */
</I>&gt;<i> -	int num_fields;		/* number of fields in *fields array */
</I>&gt;<i> -	scan_field_t *fields;	/* pointer to an array of data scan fields */
</I>&gt;<i> -	enum tap_state end_state;	/* TAP state in which JTAG commands  
</I>&gt;<i> should finish */
</I>&gt;<i> +	int           ir_scan;      /* instruction/not data scan */
</I>&gt;<i> +	int           num_fields;   /* number of fields in *fields array */
</I>&gt;<i> +	scan_field_t* fields;       /* pointer to an array of data scan  
</I>&gt;<i> fields */
</I>&gt;<i> +	tap_state_t   end_state;    /* TAP state in which JTAG commands  
</I>&gt;<i> should finish */
</I>&gt;<i> } scan_command_t;
</I>&gt;<i>
</I>&gt;<i> typedef struct statemove_command_s
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state end_state;	/* TAP state in which JTAG commands  
</I>&gt;<i> should finish */
</I>&gt;<i> +	tap_state_t end_state;   /* TAP state in which JTAG commands  
</I>&gt;<i> should finish */
</I>&gt;<i> } statemove_command_t;
</I>&gt;<i>
</I>&gt;<i> typedef struct pathmove_command_s
</I>&gt;<i> {
</I>&gt;<i> -	int num_states;				/* number of states in *path */
</I>&gt;<i> -	enum tap_state *path;		/* states that have to be passed */
</I>&gt;<i> +	int          num_states;    /* number of states in *path */
</I>&gt;<i> +	tap_state_t* path;          /* states that have to be passed */
</I>&gt;<i> } pathmove_command_t;
</I>&gt;<i>
</I>&gt;<i> typedef struct runtest_command_s
</I>&gt;<i> {
</I>&gt;<i> -	int num_cycles;		/* number of cycles that should be spent in Run- 
</I>&gt;<i> Test/Idle */
</I>&gt;<i> -	enum tap_state end_state;	/* TAP state in which JTAG commands  
</I>&gt;<i> should finish */
</I>&gt;<i> +	int         num_cycles;     /* number of cycles that should be  
</I>&gt;<i> spent in Run-Test/Idle */
</I>&gt;<i> +	tap_state_t end_state;      /* TAP state in which JTAG commands  
</I>&gt;<i> should finish */
</I>&gt;<i> } runtest_command_t;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> typedef struct stableclocks_command_s
</I>&gt;<i> {
</I>&gt;<i> -	int num_cycles;				/* number of clock cycles that should be sent */
</I>&gt;<i> +	int num_cycles;             /* number of clock cycles that should  
</I>&gt;<i> be sent */
</I>&gt;<i> } stableclocks_command_t;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> typedef struct reset_command_s
</I>&gt;<i> {
</I>&gt;<i> -	int trst;			/* trst/srst 0: deassert, 1: assert, -1: don't change */
</I>&gt;<i> +	int trst;           /* trst/srst 0: deassert, 1: assert, -1: don't  
</I>&gt;<i> change */
</I>&gt;<i> 	int srst;
</I>&gt;<i> } reset_command_t;
</I>&gt;<i>
</I>&gt;<i> typedef struct end_state_command_s
</I>&gt;<i> {
</I>&gt;<i> -	enum tap_state end_state;	/* TAP state in which JTAG commands  
</I>&gt;<i> should finish */
</I>&gt;<i> +	tap_state_t end_state;   /* TAP state in which JTAG commands  
</I>&gt;<i> should finish */
</I>&gt;<i> } end_state_command_t;
</I>&gt;<i>
</I>&gt;<i> typedef struct sleep_command_s
</I>&gt;<i> {
</I>&gt;<i> -	u32 us;		/* number of microseconds to sleep */
</I>&gt;<i> +	u32 us;     /* number of microseconds to sleep */
</I>&gt;<i> } sleep_command_t;
</I>&gt;<i>
</I>&gt;<i> typedef union jtag_command_container_u
</I>&gt;<i> {
</I>&gt;<i> -	scan_command_t *scan;
</I>&gt;<i> -	statemove_command_t *statemove;
</I>&gt;<i> -	pathmove_command_t *pathmove;
</I>&gt;<i> -	runtest_command_t *runtest;
</I>&gt;<i> -	stableclocks_command_t *stableclocks;
</I>&gt;<i> -	reset_command_t *reset;
</I>&gt;<i> -	end_state_command_t *end_state;
</I>&gt;<i> -	sleep_command_t *sleep;
</I>&gt;<i> +	scan_command_t*         scan;
</I>&gt;<i> +	statemove_command_t*    statemove;
</I>&gt;<i> +	pathmove_command_t*     pathmove;
</I>&gt;<i> +	runtest_command_t*      runtest;
</I>&gt;<i> +	stableclocks_command_t* stableclocks;
</I>&gt;<i> +	reset_command_t*        reset;
</I>&gt;<i> +	end_state_command_t*    end_state;
</I>&gt;<i> +	sleep_command_t* sleep;
</I>&gt;<i> } jtag_command_container_t;
</I>&gt;<i>
</I>&gt;<i> -enum jtag_command_type
</I>&gt;<i> -{
</I>&gt;<i> -	JTAG_SCAN = 1,
</I>&gt;<i> -	JTAG_STATEMOVE = 2, JTAG_RUNTEST = 3,
</I>&gt;<i> -	JTAG_RESET = 4, JTAG_END_STATE = 5,
</I>&gt;<i> -	JTAG_PATHMOVE = 6, JTAG_SLEEP = 7,
</I>&gt;<i> +enum jtag_command_type {
</I>&gt;<i> +	JTAG_SCAN         = 1,
</I>&gt;<i> +	JTAG_STATEMOVE    = 2,
</I>&gt;<i> +	JTAG_RUNTEST      = 3,
</I>&gt;<i> +	JTAG_RESET        = 4,
</I>&gt;<i> +	JTAG_END_STATE    = 5,
</I>&gt;<i> +	JTAG_PATHMOVE     = 6,
</I>&gt;<i> +	JTAG_SLEEP        = 7,
</I>&gt;<i> 	JTAG_STABLECLOCKS = 8
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> typedef struct jtag_command_s
</I>&gt;<i> {
</I>&gt;<i> 	jtag_command_container_t cmd;
</I>&gt;<i> -	enum jtag_command_type type;
</I>&gt;<i> -	struct jtag_command_s *next;
</I>&gt;<i> +	enum jtag_command_type   type;
</I>&gt;<i> +	struct jtag_command_s*   next;
</I>&gt;<i> } jtag_command_t;
</I>&gt;<i>
</I>&gt;<i> -extern jtag_command_t *jtag_command_queue;
</I>&gt;<i> +extern jtag_command_t* jtag_command_queue;
</I>&gt;<i>
</I>&gt;<i> /* forward declaration */
</I>&gt;<i> typedef struct jtag_tap_event_action_s jtag_tap_event_action_t;
</I>&gt;<i> @@ -179,59 +291,66 @@
</I>&gt;<i> /* due to &quot;forward decloration reasons&quot; */
</I>&gt;<i> struct jtag_tap_s
</I>&gt;<i> {
</I>&gt;<i> -	const char *chip;
</I>&gt;<i> -	const char *tapname;
</I>&gt;<i> -	const char *dotted_name;
</I>&gt;<i> +	const char* chip;
</I>&gt;<i> +	const char* tapname;
</I>&gt;<i> +	const char* dotted_name;
</I>&gt;<i> 	int         abs_chain_position;
</I>&gt;<i> -	int enabled;
</I>&gt;<i> -	int ir_length;		/* size of instruction register */
</I>&gt;<i> -	u32 ir_capture_value;
</I>&gt;<i> -	u8 *expected;		/* Capture-IR expected value */
</I>&gt;<i> -	u32 ir_capture_mask;
</I>&gt;<i> -	u8 *expected_mask;	/* Capture-IR expected mask */
</I>&gt;<i> -	u32 idcode;			/* device identification code */
</I>&gt;<i> -	u32 *expected_ids;	/* Array of expected identification codes */
</I>&gt;<i> -	u8 expected_ids_cnt;/* Number of expected identification codes */
</I>&gt;<i> -	u8 *cur_instr;		/* current instruction */
</I>&gt;<i> -	int bypass;			/* bypass register selected */
</I>&gt;<i> +	int         enabled;
</I>&gt;<i> +	int         ir_length;          /* size of instruction register */
</I>&gt;<i> +	u32         ir_capture_value;
</I>&gt;<i> +	u8*         expected;           /* Capture-IR expected value */
</I>&gt;<i> +	u32         ir_capture_mask;
</I>&gt;<i> +	u8*         expected_mask;      /* Capture-IR expected mask */
</I>&gt;<i> +	u32         idcode;             /* device identification code */
</I>&gt;<i> +	u32*        expected_ids;       /* Array of expected  
</I>&gt;<i> identification codes */
</I>&gt;<i> +	u8          expected_ids_cnt;   /* Number of expected  
</I>&gt;<i> identification codes */
</I>&gt;<i> +	u8*         cur_instr;          /* current instruction */
</I>&gt;<i> +	int         bypass;             /* bypass register selected */
</I>&gt;<i>
</I>&gt;<i> -	jtag_tap_event_action_t *event_action;
</I>&gt;<i> +	jtag_tap_event_action_t* event_action;
</I>&gt;<i>
</I>&gt;<i> -	jtag_tap_t *next_tap;
</I>&gt;<i> +	jtag_tap_t* next_tap;
</I>&gt;<i> };
</I>&gt;<i> -extern jtag_tap_t *jtag_AllTaps(void);
</I>&gt;<i> -extern jtag_tap_t *jtag_TapByPosition(int n);
</I>&gt;<i> -extern jtag_tap_t *jtag_TapByPosition(int n);
</I>&gt;<i> -extern jtag_tap_t *jtag_TapByString(const char *dotted_name);
</I>&gt;<i> -extern jtag_tap_t *jtag_TapByJimObj(Jim_Interp *interp, Jim_Obj  
</I>&gt;<i> *obj);
</I>&gt;<i> -extern jtag_tap_t *jtag_TapByAbsPosition(int abs_position);
</I>&gt;<i> -extern int jtag_NumEnabledTaps(void);
</I>&gt;<i> -extern int jtag_NumTotalTaps(void);
</I>&gt;<i> +extern jtag_tap_t* jtag_AllTaps(void);
</I>&gt;<i> +extern jtag_tap_t* jtag_TapByPosition(int n);
</I>&gt;<i> +extern jtag_tap_t* jtag_TapByPosition(int n);
</I>&gt;<i> +extern jtag_tap_t* jtag_TapByString(const char* dotted_name);
</I>&gt;<i> +extern jtag_tap_t* jtag_TapByJimObj(Jim_Interp* interp, Jim_Obj*  
</I>&gt;<i> obj);
</I>&gt;<i> +extern jtag_tap_t* jtag_TapByAbsPosition(int abs_position);
</I>&gt;<i> +extern int         jtag_NumEnabledTaps(void);
</I>&gt;<i> +extern int         jtag_NumTotalTaps(void);
</I>&gt;<i>
</I>&gt;<i> -static __inline__ jtag_tap_t *
</I>&gt;<i> -jtag_NextEnabledTap( jtag_tap_t *p )
</I>&gt;<i> +static __inline__ jtag_tap_t* jtag_NextEnabledTap(jtag_tap_t* p)
</I>&gt;<i> {
</I>&gt;<i> -	if( p == NULL ){
</I>&gt;<i> +	if (p == NULL)
</I>&gt;<i> +	{
</I>&gt;<i> 		/* start at the head of list */
</I>&gt;<i> 		p = jtag_AllTaps();
</I>&gt;<i> -	} else {
</I>&gt;<i> +	}
</I>&gt;<i> +	else
</I>&gt;<i> +	{
</I>&gt;<i> 		/* start *after* this one */
</I>&gt;<i> 		p = p-&gt;next_tap;
</I>&gt;<i> 	}
</I>&gt;<i> -	while( p ){
</I>&gt;<i> -		if( p-&gt;enabled ){
</I>&gt;<i> +	while (p)
</I>&gt;<i> +	{
</I>&gt;<i> +		if (p-&gt;enabled)
</I>&gt;<i> +		{
</I>&gt;<i> 			break;
</I>&gt;<i> -		} else {
</I>&gt;<i> +		}
</I>&gt;<i> +		else
</I>&gt;<i> +		{
</I>&gt;<i> 			p = p-&gt;next_tap;
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> +
</I>&gt;<i> 	return p;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -enum reset_line_mode
</I>&gt;<i> -{
</I>&gt;<i> +
</I>&gt;<i> +enum reset_line_mode {
</I>&gt;<i> 	LINE_OPEN_DRAIN = 0x0,
</I>&gt;<i> -	LINE_PUSH_PULL = 0x1,
</I>&gt;<i> +	LINE_PUSH_PULL  = 0x1,
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> typedef struct jtag_interface_s
</I>&gt;<i> @@ -245,61 +364,62 @@
</I>&gt;<i> 	/* interface initalization
</I>&gt;<i> 	 */
</I>&gt;<i> 	int (*speed)(int speed);
</I>&gt;<i> -	int (*register_commands)(struct command_context_s *cmd_ctx);
</I>&gt;<i> +	int (*register_commands)(struct command_context_s* cmd_ctx);
</I>&gt;<i> 	int (*init)(void);
</I>&gt;<i> 	int (*quit)(void);
</I>&gt;<i> +
</I>&gt;<i> 	/* returns JTAG maxium speed for KHz. 0=RTCK. The function returns
</I>&gt;<i> -	a failure if it can't support the KHz/RTCK.
</I>&gt;<i> +	 *  a failure if it can't support the KHz/RTCK.
</I>&gt;<i> +	 *
</I>&gt;<i> +	 *  WARNING!!!! if RTCK is *slow* then think carefully about
</I>&gt;<i> +	 *  whether you actually want to support this in the driver.
</I>&gt;<i> +	 *  Many target scripts are written to handle the absence of RTCK
</I>&gt;<i> +	 *  and use a fallback kHz TCK.
</I>&gt;<i> +	 */
</I>&gt;<i> +	int (*khz)(int khz, int* jtag_speed);
</I>&gt;<i>
</I>&gt;<i> -	WARNING!!!! if RTCK is *slow* then think carefully about
</I>&gt;<i> -	whether you actually want to support this in the driver.
</I>&gt;<i> -	Many target scripts are written to handle the absence of RTCK
</I>&gt;<i> -	and use a fallback kHz TCK.
</I>&gt;<i> -	*/
</I>&gt;<i> -	int (*khz)(int khz, int *jtag_speed);
</I>&gt;<i> 	/* returns the KHz for the provided JTAG speed. 0=RTCK. The  
</I>&gt;<i> function returns
</I>&gt;<i> -	a failure if it can't support the KHz/RTCK. */
</I>&gt;<i> -	int (*speed_div)(int speed, int *khz);
</I>&gt;<i> +	 *  a failure if it can't support the KHz/RTCK. */
</I>&gt;<i> +	int (*speed_div)(int speed, int* khz);
</I>&gt;<i>
</I>&gt;<i> 	/* Read and clear the power dropout flag. Note that a power dropout
</I>&gt;<i> -	   can be transitionary, easily much less than a ms.
</I>&gt;<i> +	 *  can be transitionary, easily much less than a ms.
</I>&gt;<i> +	 *
</I>&gt;<i> +	 *  So to find out if the power is *currently* on, you must invoke
</I>&gt;<i> +	 *  this method twice. Once to clear the power dropout flag and a
</I>&gt;<i> +	 *  second time to read the current state.
</I>&gt;<i> +	 *
</I>&gt;<i> +	 *  Currently the default implementation is never to detect power  
</I>&gt;<i> dropout.
</I>&gt;<i> +	 */
</I>&gt;<i> +	int (*power_dropout)(int* power_dropout);
</I>&gt;<i>
</I>&gt;<i> -	   So to find out if the power is *currently* on, you must invoke
</I>&gt;<i> -	   this method twice. Once to clear the power dropout flag and a
</I>&gt;<i> -	   second time to read the current state.
</I>&gt;<i> -
</I>&gt;<i> -	   Currently the default implementation is never to detect power  
</I>&gt;<i> dropout.
</I>&gt;<i> -	*/
</I>&gt;<i> -	int (*power_dropout)(int *power_dropout);
</I>&gt;<i> 	/* Read and clear the srst asserted detection flag.
</I>&gt;<i> 	 *
</I>&gt;<i> 	 * NB!!!! like power_dropout this does *not* read the current
</I>&gt;<i> 	 * state. srst assertion is transitionary and *can* be much
</I>&gt;<i> 	 * less than 1ms.
</I>&gt;<i> 	 */
</I>&gt;<i> -	int (*srst_asserted)(int *srst_asserted);
</I>&gt;<i> -
</I>&gt;<i> +	int (*srst_asserted)(int* srst_asserted);
</I>&gt;<i> } jtag_interface_t;
</I>&gt;<i>
</I>&gt;<i> -enum jtag_event
</I>&gt;<i> -{
</I>&gt;<i> +enum jtag_event {
</I>&gt;<i> 	JTAG_TRST_ASSERTED
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> -extern char * jtag_event_strings[];
</I>&gt;<i> +extern char* jtag_event_strings[];
</I>&gt;<i>
</I>&gt;<i> -enum jtag_tap_event
</I>&gt;<i> -{
</I>&gt;<i> +enum jtag_tap_event {
</I>&gt;<i> 	JTAG_TAP_EVENT_ENABLE,
</I>&gt;<i> 	JTAG_TAP_EVENT_DISABLE
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> extern const Jim_Nvp nvp_jtag_tap_event[];
</I>&gt;<i>
</I>&gt;<i> -struct jtag_tap_event_action_s {
</I>&gt;<i> -	enum jtag_tap_event event;
</I>&gt;<i> -	Jim_Obj *body;
</I>&gt;<i> -	jtag_tap_event_action_t *next;
</I>&gt;<i> +struct jtag_tap_event_action_s
</I>&gt;<i> +{
</I>&gt;<i> +	enum jtag_tap_event      event;
</I>&gt;<i> +	Jim_Obj*                 body;
</I>&gt;<i> +	jtag_tap_event_action_t* next;
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> extern int jtag_trst;
</I>&gt;<i> @@ -307,30 +427,27 @@
</I>&gt;<i>
</I>&gt;<i> typedef struct jtag_event_callback_s
</I>&gt;<i> {
</I>&gt;<i> -	int (*callback)(enum jtag_event event, void *priv);
</I>&gt;<i> -	void *priv;
</I>&gt;<i> -	struct jtag_event_callback_s *next;
</I>&gt;<i> +	int (*callback)(enum jtag_event event, void* priv);
</I>&gt;<i> +	void*                         priv;
</I>&gt;<i> +	struct jtag_event_callback_s* next;
</I>&gt;<i> } jtag_event_callback_t;
</I>&gt;<i>
</I>&gt;<i> -extern jtag_event_callback_t *jtag_event_callbacks;
</I>&gt;<i> +extern jtag_event_callback_t* jtag_event_callbacks;
</I>&gt;<i>
</I>&gt;<i> -extern jtag_interface_t *jtag;	/* global pointer to configured JTAG  
</I>&gt;<i> interface */
</I>&gt;<i> -extern enum tap_state end_state;
</I>&gt;<i> -extern enum tap_state cur_state;
</I>&gt;<i> +extern jtag_interface_t*      jtag; /* global pointer to configured  
</I>&gt;<i> JTAG interface */
</I>&gt;<i>
</I>&gt;<i> extern int jtag_speed;
</I>&gt;<i> extern int jtag_speed_post_reset;
</I>&gt;<i>
</I>&gt;<i> -enum reset_types
</I>&gt;<i> -{
</I>&gt;<i> -	RESET_NONE = 0x0,
</I>&gt;<i> -	RESET_HAS_TRST = 0x1,
</I>&gt;<i> -	RESET_HAS_SRST = 0x2,
</I>&gt;<i> -	RESET_TRST_AND_SRST = 0x3,
</I>&gt;<i> +enum reset_types {
</I>&gt;<i> +	RESET_NONE            = 0x0,
</I>&gt;<i> +	RESET_HAS_TRST        = 0x1,
</I>&gt;<i> +	RESET_HAS_SRST        = 0x2,
</I>&gt;<i> +	RESET_TRST_AND_SRST   = 0x3,
</I>&gt;<i> 	RESET_SRST_PULLS_TRST = 0x4,
</I>&gt;<i> 	RESET_TRST_PULLS_SRST = 0x8,
</I>&gt;<i> 	RESET_TRST_OPEN_DRAIN = 0x10,
</I>&gt;<i> -	RESET_SRST_PUSH_PULL = 0x20,
</I>&gt;<i> +	RESET_SRST_PUSH_PULL  = 0x20,
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> extern enum reset_types jtag_reset_config;
</I>&gt;<i> @@ -338,14 +455,16 @@
</I>&gt;<i> /* initialize interface upon startup. A successful no-op
</I>&gt;<i>  * upon subsequent invocations
</I>&gt;<i>  */
</I>&gt;<i> -extern int jtag_interface_init(struct command_context_s *cmd_ctx);
</I>&gt;<i> +extern int  jtag_interface_init(struct command_context_s* cmd_ctx);
</I>&gt;<i> +
</I>&gt;<i> /* initialize JTAG chain using only a RESET reset. If init fails,
</I>&gt;<i>  * try reset + init.
</I>&gt;<i>  */
</I>&gt;<i> -extern int jtag_init(struct command_context_s *cmd_ctx);
</I>&gt;<i> +extern int  jtag_init(struct command_context_s* cmd_ctx);
</I>&gt;<i> +
</I>&gt;<i> /* reset, then initialize JTAG chain */
</I>&gt;<i> -extern int jtag_init_reset(struct command_context_s *cmd_ctx);
</I>&gt;<i> -extern int jtag_register_commands(struct command_context_s *cmd_ctx);
</I>&gt;<i> +extern int  jtag_init_reset(struct command_context_s* cmd_ctx);
</I>&gt;<i> +extern int  jtag_register_commands(struct command_context_s*  
</I>&gt;<i> cmd_ctx);
</I>&gt;<i>
</I>&gt;<i> /* JTAG interface, can be implemented with a software or hardware fifo
</I>&gt;<i>  *
</I>&gt;<i> @@ -359,19 +478,21 @@
</I>&gt;<i>  * be issued.
</I>&gt;<i>  *
</I>&gt;<i>  */
</I>&gt;<i> -extern void jtag_add_ir_scan(int num_fields, scan_field_t *fields,  
</I>&gt;<i> enum tap_state endstate);
</I>&gt;<i> -extern int interface_jtag_add_ir_scan(int num_fields, scan_field_t  
</I>&gt;<i> *fields, enum tap_state endstate);
</I>&gt;<i> -extern void jtag_add_dr_scan(int num_fields, scan_field_t *fields,  
</I>&gt;<i> enum tap_state endstate);
</I>&gt;<i> -extern int interface_jtag_add_dr_scan(int num_fields, scan_field_t  
</I>&gt;<i> *fields, enum tap_state endstate);
</I>&gt;<i> -extern void jtag_add_plain_ir_scan(int num_fields, scan_field_t  
</I>&gt;<i> *fields, enum tap_state endstate);
</I>&gt;<i> -extern int interface_jtag_add_plain_ir_scan(int num_fields,  
</I>&gt;<i> scan_field_t *fields, enum tap_state endstate);
</I>&gt;<i> -extern void jtag_add_plain_dr_scan(int num_fields, scan_field_t  
</I>&gt;<i> *fields, enum tap_state endstate);
</I>&gt;<i> -extern int interface_jtag_add_plain_dr_scan(int num_fields,  
</I>&gt;<i> scan_field_t *fields, enum tap_state endstate);
</I>&gt;<i> +extern void jtag_add_ir_scan(int num_fields, scan_field_t* fields,  
</I>&gt;<i> tap_state_t endstate);
</I>&gt;<i> +extern int  interface_jtag_add_ir_scan(int num_fields,  
</I>&gt;<i> scan_field_t* fields, tap_state_t endstate);
</I>&gt;<i> +extern void jtag_add_dr_scan(int num_fields, scan_field_t* fields,  
</I>&gt;<i> tap_state_t endstate);
</I>&gt;<i> +extern int  interface_jtag_add_dr_scan(int num_fields,  
</I>&gt;<i> scan_field_t* fields, tap_state_t endstate);
</I>&gt;<i> +extern void jtag_add_plain_ir_scan(int num_fields, scan_field_t*  
</I>&gt;<i> fields, tap_state_t endstate);
</I>&gt;<i> +extern int  interface_jtag_add_plain_ir_scan(int num_fields,  
</I>&gt;<i> scan_field_t* fields, tap_state_t endstate);
</I>&gt;<i> +extern void jtag_add_plain_dr_scan(int num_fields, scan_field_t*  
</I>&gt;<i> fields, tap_state_t endstate);
</I>&gt;<i> +extern int  interface_jtag_add_plain_dr_scan(int num_fields,  
</I>&gt;<i> scan_field_t* fields, tap_state_t endstate);
</I>&gt;<i> +
</I>&gt;<i> /* run a TAP_RESET reset. End state is TAP_RESET, regardless
</I>&gt;<i>  * of start state.
</I>&gt;<i>  */
</I>&gt;<i> extern void jtag_add_tlr(void);
</I>&gt;<i> -extern int interface_jtag_add_tlr(void);
</I>&gt;<i> +extern int  interface_jtag_add_tlr(void);
</I>&gt;<i> +
</I>&gt;<i> /* Do not use jtag_add_pathmove() unless you need to, but do use it
</I>&gt;<i>  * if you have to.
</I>&gt;<i>  *
</I>&gt;<i> @@ -402,8 +523,9 @@
</I>&gt;<i>  * a partial implementation of pathmove would have little practical
</I>&gt;<i>  * application.
</I>&gt;<i>  */
</I>&gt;<i> -extern void jtag_add_pathmove(int num_states, enum tap_state *path);
</I>&gt;<i> -extern int interface_jtag_add_pathmove(int num_states, enum  
</I>&gt;<i> tap_state *path);
</I>&gt;<i> +extern void jtag_add_pathmove(int num_states, tap_state_t* path);
</I>&gt;<i> +extern int  interface_jtag_add_pathmove(int num_states,  
</I>&gt;<i> tap_state_t* path);
</I>&gt;<i> +
</I>&gt;<i> /* go to TAP_IDLE, if we're not already there and cycle
</I>&gt;<i>  * precisely num_cycles in the TAP_IDLE after which move
</I>&gt;<i>  * to the end state, if it is != TAP_IDLE
</I>&gt;<i> @@ -411,8 +533,9 @@
</I>&gt;<i>  * nb! num_cycles can be 0, in which case the fn will navigate
</I>&gt;<i>  * to endstate via TAP_IDLE
</I>&gt;<i>  */
</I>&gt;<i> -extern void jtag_add_runtest(int num_cycles, enum tap_state  
</I>&gt;<i> endstate);
</I>&gt;<i> -extern int interface_jtag_add_runtest(int num_cycles, enum  
</I>&gt;<i> tap_state endstate);
</I>&gt;<i> +extern void jtag_add_runtest(int num_cycles, tap_state_t endstate);
</I>&gt;<i> +extern int  interface_jtag_add_runtest(int num_cycles, tap_state_t  
</I>&gt;<i> endstate);
</I>&gt;<i> +
</I>&gt;<i> /* A reset of the TAP state machine can be requested.
</I>&gt;<i>  *
</I>&gt;<i>  * Whether tms or trst reset is used depends on the capabilities of
</I>&gt;<i> @@ -436,6 +559,7 @@
</I>&gt;<i>  * then trst &amp; srst *must* be asserted together.
</I>&gt;<i>  */
</I>&gt;<i> extern void jtag_add_reset(int req_tlr_or_trst, int srst);
</I>&gt;<i> +
</I>&gt;<i> /* this drives the actual srst and trst pins. srst will always be 0
</I>&gt;<i>  * if jtag_reset_config &amp; RESET_SRST_PULLS_TRST != 0 and ditto for
</I>&gt;<i>  * trst.
</I>&gt;<i> @@ -443,11 +567,11 @@
</I>&gt;<i>  * the higher level jtag_add_reset will invoke jtag_add_tlr() if
</I>&gt;<i>  * approperiate
</I>&gt;<i>  */
</I>&gt;<i> -extern int interface_jtag_add_reset(int trst, int srst);
</I>&gt;<i> -extern void jtag_add_end_state(enum tap_state endstate);
</I>&gt;<i> -extern int interface_jtag_add_end_state(enum tap_state endstate);
</I>&gt;<i> +extern int  interface_jtag_add_reset(int trst, int srst);
</I>&gt;<i> +extern void jtag_add_end_state(tap_state_t endstate);
</I>&gt;<i> +extern int  interface_jtag_add_end_state(tap_state_t endstate);
</I>&gt;<i> extern void jtag_add_sleep(u32 us);
</I>&gt;<i> -extern int interface_jtag_add_sleep(u32 us);
</I>&gt;<i> +extern int  interface_jtag_add_sleep(u32 us);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /**
</I>&gt;<i> @@ -455,8 +579,8 @@
</I>&gt;<i>  * first checks that the state in which the clocks are to be issued is
</I>&gt;<i>  * stable, then queues up clock_count clocks for transmission.
</I>&gt;<i>  */
</I>&gt;<i> -void jtag_add_clocks( int num_cycles );
</I>&gt;<i> -int interface_jtag_add_clocks( int num_cycles );
</I>&gt;<i> +void jtag_add_clocks(int num_cycles);
</I>&gt;<i> +int  interface_jtag_add_clocks(int num_cycles);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i> @@ -479,37 +603,38 @@
</I>&gt;<i>  * jtag_add_xxx() commands can either be executed immediately or
</I>&gt;<i>  * at some time between the jtag_add_xxx() fn call and  
</I>&gt;<i> jtag_execute_queue().
</I>&gt;<i>  */
</I>&gt;<i> -extern int jtag_execute_queue(void);
</I>&gt;<i> +extern int            jtag_execute_queue(void);
</I>&gt;<i> +
</I>&gt;<i> /* can be implemented by hw+sw */
</I>&gt;<i> -extern int interface_jtag_execute_queue(void);
</I>&gt;<i> -extern int jtag_power_dropout(int *dropout);
</I>&gt;<i> -extern int jtag_srst_asserted(int *srst_asserted);
</I>&gt;<i> +extern int            interface_jtag_execute_queue(void);
</I>&gt;<i> +extern int            jtag_power_dropout(int* dropout);
</I>&gt;<i> +extern int            jtag_srst_asserted(int* srst_asserted);
</I>&gt;<i>
</I>&gt;<i> /* JTAG support functions */
</I>&gt;<i> -extern void jtag_set_check_value(scan_field_t *field, u8 *value,   
</I>&gt;<i> u8 *mask, error_handler_t *in_error_handler);
</I>&gt;<i> -extern enum scan_type jtag_scan_type(scan_command_t *cmd);
</I>&gt;<i> -extern int jtag_scan_size(scan_command_t *cmd);
</I>&gt;<i> -extern int jtag_read_buffer(u8 *buffer, scan_command_t *cmd);
</I>&gt;<i> -extern int jtag_build_buffer(scan_command_t *cmd, u8 **buffer);
</I>&gt;<i> +extern void           jtag_set_check_value(scan_field_t* field, u8*  
</I>&gt;<i> value, u8* mask, error_handler_t* in_error_handler);
</I>&gt;<i> +extern enum scan_type jtag_scan_type(scan_command_t* cmd);
</I>&gt;<i> +extern int            jtag_scan_size(scan_command_t* cmd);
</I>&gt;<i> +extern int            jtag_read_buffer(u8* buffer, scan_command_t*  
</I>&gt;<i> cmd);
</I>&gt;<i> +extern int            jtag_build_buffer(scan_command_t* cmd, u8**  
</I>&gt;<i> buffer);
</I>&gt;<i>
</I>&gt;<i> -extern void jtag_sleep(u32 us);
</I>&gt;<i> -extern int jtag_call_event_callbacks(enum jtag_event event);
</I>&gt;<i> -extern int jtag_register_event_callback(int (*callback)(enum  
</I>&gt;<i> jtag_event event, void *priv), void *priv);
</I>&gt;<i> +extern void           jtag_sleep(u32 us);
</I>&gt;<i> +extern int            jtag_call_event_callbacks(enum jtag_event  
</I>&gt;<i> event);
</I>&gt;<i> +extern int            jtag_register_event_callback(int (* callback) 
</I>&gt;<i> (enum jtag_event event, void* priv), void* priv);
</I>&gt;<i>
</I>&gt;<i> extern int jtag_verify_capture_ir;
</I>&gt;<i>
</I>&gt;<i> -void jtag_tap_handle_event( jtag_tap_t * tap, enum jtag_tap_event e);
</I>&gt;<i> +void jtag_tap_handle_event(jtag_tap_t* tap, enum jtag_tap_event e);
</I>&gt;<i>
</I>&gt;<i> /* error codes
</I>&gt;<i>  * JTAG subsystem uses codes between -100 and -199 */
</I>&gt;<i>
</I>&gt;<i> -#define ERROR_JTAG_INIT_FAILED			(-100)
</I>&gt;<i> -#define ERROR_JTAG_INVALID_INTERFACE		(-101)
</I>&gt;<i> -#define ERROR_JTAG_NOT_IMPLEMENTED		(-102)
</I>&gt;<i> -#define ERROR_JTAG_TRST_ASSERTED			(-103)
</I>&gt;<i> -#define ERROR_JTAG_QUEUE_FAILED			(-104)
</I>&gt;<i> -#define ERROR_JTAG_NOT_STABLE_STATE		(-105)
</I>&gt;<i> -#define ERROR_JTAG_DEVICE_ERROR			(-107)
</I>&gt;<i> +#define ERROR_JTAG_INIT_FAILED       (-100)
</I>&gt;<i> +#define ERROR_JTAG_INVALID_INTERFACE (-101)
</I>&gt;<i> +#define ERROR_JTAG_NOT_IMPLEMENTED   (-102)
</I>&gt;<i> +#define ERROR_JTAG_TRST_ASSERTED     (-103)
</I>&gt;<i> +#define ERROR_JTAG_QUEUE_FAILED      (-104)
</I>&gt;<i> +#define ERROR_JTAG_NOT_STABLE_STATE  (-105)
</I>&gt;<i> +#define ERROR_JTAG_DEVICE_ERROR      (-107)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /* this allows JTAG devices to implement the entire jtag_xxx() layer  
</I>&gt;<i> in hw/sw */
</I>&gt;<i> @@ -519,6 +644,7 @@
</I>&gt;<i> #define MINIDRIVER(a) notused ## a
</I>&gt;<i> #else
</I>&gt;<i> #define MINIDRIVER(a) a
</I>&gt;<i> +
</I>&gt;<i> /* jtag_add_dr_out() is a faster version of jtag_add_dr_scan()
</I>&gt;<i>  *
</I>&gt;<i>  * Current or end_state can not be TAP_RESET. end_state can be -1
</I>&gt;<i> @@ -536,30 +662,19 @@
</I>&gt;<i>  *
</I>&gt;<i>  * Note that this jtag_add_dr_out can be defined as an inline  
</I>&gt;<i> function.
</I>&gt;<i>  */
</I>&gt;<i> -extern void interface_jtag_add_dr_out(jtag_tap_t *tap,
</I>&gt;<i> -		int num_fields,
</I>&gt;<i> -		const int *num_bits,
</I>&gt;<i> -		const u32 *value,
</I>&gt;<i> -		enum tap_state end_state);
</I>&gt;<i> +extern void interface_jtag_add_dr_out(jtag_tap_t* tap, int  
</I>&gt;<i> num_fields, const int* num_bits, const u32* value,
</I>&gt;<i> +		tap_state_t end_state);
</I>&gt;<i> +
</I>&gt;<i> #endif
</I>&gt;<i>
</I>&gt;<i> -static __inline__ void jtag_add_dr_out(jtag_tap_t *tap,
</I>&gt;<i> -		int num_fields,
</I>&gt;<i> -		const int *num_bits,
</I>&gt;<i> -		const u32 *value,
</I>&gt;<i> -		enum tap_state end_state)
</I>&gt;<i> +static __inline__ void jtag_add_dr_out(jtag_tap_t* tap, int  
</I>&gt;<i> num_fields, const int* num_bits, const u32* value,
</I>&gt;<i> +		tap_state_t end_state)
</I>&gt;<i> {
</I>&gt;<i> 	if (end_state != -1)
</I>&gt;<i> -		cmd_queue_end_state=end_state;
</I>&gt;<i> -	cmd_queue_cur_state=cmd_queue_end_state;
</I>&gt;<i> +		cmd_queue_end_state = end_state;
</I>&gt;<i> +	cmd_queue_cur_state = cmd_queue_end_state;
</I>&gt;<i> 	interface_jtag_add_dr_out(tap, num_fields, num_bits, value,  
</I>&gt;<i> cmd_queue_end_state);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -/**
</I>&gt;<i> - * Function jtag_state_name
</I>&gt;<i> - * Returns a string suitable for display representing the JTAG  
</I>&gt;<i> tap_state
</I>&gt;<i> - */
</I>&gt;<i> -const char* jtag_state_name(enum tap_state state);
</I>&gt;<i>
</I>&gt;<i> -
</I>&gt;<i> #endif /* JTAG_H */
</I>&gt;<i> Index: src/jtag/dummy.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/jtag/dummy.c	(revision 1363)
</I>&gt;<i> +++ src/jtag/dummy.c	(working copy)
</I>&gt;<i> @@ -34,9 +34,6 @@
</I>&gt;<i>
</I>&gt;<i> static int clock_count;         /* count clocks in any stable state,  
</I>&gt;<i> only stable states */
</I>&gt;<i>
</I>&gt;<i> -
</I>&gt;<i> -static tap_state_t tap_state_transition(tap_state_t cur_state, int  
</I>&gt;<i> tms);
</I>&gt;<i> -
</I>&gt;<i> static u32 dummy_data;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -105,7 +102,7 @@
</I>&gt;<i> 					clock_count = 0;
</I>&gt;<i> 				}
</I>&gt;<i>
</I>&gt;<i> -				LOG_DEBUG(&quot;dummy_tap: %s&quot;, jtag_state_name(dummy_state) );
</I>&gt;<i> +				LOG_DEBUG(&quot;dummy_tap: %s&quot;, tap_state_name(dummy_state) );
</I>&gt;<i>
</I>&gt;<i> #if defined(DEBUG)
</I>&gt;<i> 				if(dummy_state == TAP_DRCAPTURE)
</I>&gt;<i> @@ -131,7 +128,7 @@
</I>&gt;<i> 	if (trst || (srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
</I>&gt;<i> 		dummy_state = TAP_RESET;
</I>&gt;<i>
</I>&gt;<i> -	LOG_DEBUG(&quot;reset to: %s&quot;, jtag_state_name(dummy_state) );
</I>&gt;<i> +	LOG_DEBUG(&quot;reset to: %s&quot;, tap_state_name(dummy_state) );
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> static int dummy_khz(int khz, int *jtag_speed)
</I>&gt;<i> @@ -187,106 +184,3 @@
</I>&gt;<i> {
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> -
</I>&gt;<i> -/**
</I>&gt;<i> - * Function tap_state_transition
</I>&gt;<i> - * takes a current TAP state and returns the next state according  
</I>&gt;<i> to the tms value.
</I>&gt;<i> - *
</I>&gt;<i> - * Even though there is code to duplicate this elsewhere, we do it  
</I>&gt;<i> here a little
</I>&gt;<i> - * differently just to get a second opinion, i.e. a verification,  
</I>&gt;<i> on state tracking
</I>&gt;<i> - * in that other logic. Plus array lookups without index checking  
</I>&gt;<i> are no favorite thing.
</I>&gt;<i> - * This is educational for developers new to TAP controllers.
</I>&gt;<i> - */
</I>&gt;<i> -static tap_state_t tap_state_transition(tap_state_t cur_state, int  
</I>&gt;<i> tms)
</I>&gt;<i> -{
</I>&gt;<i> -	tap_state_t new_state;
</I>&gt;<i> -
</I>&gt;<i> -	if (tms)
</I>&gt;<i> -	{
</I>&gt;<i> -		switch (cur_state)
</I>&gt;<i> -		{
</I>&gt;<i> -		case TAP_RESET:
</I>&gt;<i> -			new_state = cur_state;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_IDLE:
</I>&gt;<i> -		case TAP_DRUPDATE:
</I>&gt;<i> -		case TAP_IRUPDATE:
</I>&gt;<i> -			new_state = TAP_DRSELECT;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_DRSELECT:
</I>&gt;<i> -			new_state = TAP_IRSELECT;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_DRCAPTURE:
</I>&gt;<i> -		case TAP_DRSHIFT:
</I>&gt;<i> -			new_state = TAP_DREXIT1;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_DREXIT1:
</I>&gt;<i> -		case TAP_DREXIT2:
</I>&gt;<i> -			new_state = TAP_DRUPDATE;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_DRPAUSE:
</I>&gt;<i> -			new_state = TAP_DREXIT2;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_IRSELECT:
</I>&gt;<i> -			new_state = TAP_RESET;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_IRCAPTURE:
</I>&gt;<i> -		case TAP_IRSHIFT:
</I>&gt;<i> -			new_state = TAP_IREXIT1;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_IREXIT1:
</I>&gt;<i> -		case TAP_IREXIT2:
</I>&gt;<i> -			new_state = TAP_IRUPDATE;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_IRPAUSE:
</I>&gt;<i> -			new_state = TAP_IREXIT2;
</I>&gt;<i> -			break;
</I>&gt;<i> -		default:
</I>&gt;<i> -			LOG_ERROR( &quot;fatal: invalid argument cur_state=%d&quot;, cur_state );
</I>&gt;<i> -			exit(1);
</I>&gt;<i> -			break;
</I>&gt;<i> -		}
</I>&gt;<i> -	}
</I>&gt;<i> -	else
</I>&gt;<i> -	{
</I>&gt;<i> -		switch (cur_state)
</I>&gt;<i> -		{
</I>&gt;<i> -		case TAP_RESET:
</I>&gt;<i> -		case TAP_IDLE:
</I>&gt;<i> -		case TAP_DRUPDATE:
</I>&gt;<i> -		case TAP_IRUPDATE:
</I>&gt;<i> -			new_state = TAP_IDLE;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_DRSELECT:
</I>&gt;<i> -			new_state = TAP_DRCAPTURE;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_DRCAPTURE:
</I>&gt;<i> -		case TAP_DRSHIFT:
</I>&gt;<i> -		case TAP_DREXIT2:
</I>&gt;<i> -			new_state = TAP_DRSHIFT;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_DREXIT1:
</I>&gt;<i> -		case TAP_DRPAUSE:
</I>&gt;<i> -			new_state = TAP_DRPAUSE;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_IRSELECT:
</I>&gt;<i> -			new_state = TAP_IRCAPTURE;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_IRCAPTURE:
</I>&gt;<i> -		case TAP_IRSHIFT:
</I>&gt;<i> -		case TAP_IREXIT2:
</I>&gt;<i> -			new_state = TAP_IRSHIFT;
</I>&gt;<i> -			break;
</I>&gt;<i> -		case TAP_IREXIT1:
</I>&gt;<i> -		case TAP_IRPAUSE:
</I>&gt;<i> -			new_state = TAP_IRPAUSE;
</I>&gt;<i> -			break;
</I>&gt;<i> -		default:
</I>&gt;<i> -			LOG_ERROR( &quot;fatal: invalid argument cur_state=%d&quot;, cur_state );
</I>&gt;<i> -			exit(1);
</I>&gt;<i> -			break;
</I>&gt;<i> -		}
</I>&gt;<i> -	}
</I>&gt;<i> -
</I>&gt;<i> -	return new_state;
</I>&gt;<i> -}
</I>&gt;<i> Index: src/xsvf/xsvf.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/xsvf/xsvf.c	(revision 1363)
</I>&gt;<i> +++ src/xsvf/xsvf.c	(working copy)
</I>&gt;<i> @@ -185,7 +185,7 @@
</I>&gt;<i> 	tap_state_t curstate = cmd_queue_cur_state;
</I>&gt;<i> 	int i;
</I>&gt;<i>
</I>&gt;<i> -	u8 move = TAP_MOVE(cmd_queue_cur_state, state);
</I>&gt;<i> +	u8 move = tap_get_tms_path(cmd_queue_cur_state, state);
</I>&gt;<i>
</I>&gt;<i> 	if (state != TAP_RESET  &amp;&amp;  state==cmd_queue_cur_state)
</I>&gt;<i> 		return;
</I>&gt;<i> @@ -201,11 +201,11 @@
</I>&gt;<i> 		int j = (move &gt;&gt; i) &amp; 1;
</I>&gt;<i> 		if (j)
</I>&gt;<i> 		{
</I>&gt;<i> -			curstate = tap_transitions[curstate].high;
</I>&gt;<i> +			curstate = tap_state_transition(curstate, TRUE);
</I>&gt;<i> 		}
</I>&gt;<i> 		else
</I>&gt;<i> 		{
</I>&gt;<i> -			curstate = tap_transitions[curstate].low;
</I>&gt;<i> +			curstate = tap_state_transition(curstate, FALSE);
</I>&gt;<i> 		}
</I>&gt;<i> 		moves[i] = curstate;
</I>&gt;<i> 	}
</I>&gt;<i> @@ -257,7 +257,7 @@
</I>&gt;<i>
</I>&gt;<i> 		mystate = xsvf_to_tap(uc);
</I>&gt;<i>
</I>&gt;<i> -		LOG_DEBUG(&quot;XSTATE %02X %s&quot;, uc, jtag_state_name(mystate) );
</I>&gt;<i> +		LOG_DEBUG(&quot;XSTATE %02X %s&quot;, uc, tap_state_name(mystate) );
</I>&gt;<i>
</I>&gt;<i> 		path[(*path_len)++] = mystate;
</I>&gt;<i> 	}
</I>&gt;<i> @@ -581,7 +581,7 @@
</I>&gt;<i>
</I>&gt;<i> 					mystate = xsvf_to_tap(uc);
</I>&gt;<i>
</I>&gt;<i> -					LOG_DEBUG(&quot;XSTATE 0x%02X %s&quot;, uc, jtag_state_name(mystate) );
</I>&gt;<i> +					LOG_DEBUG(&quot;XSTATE 0x%02X %s&quot;, uc, tap_state_name(mystate) );
</I>&gt;<i>
</I>&gt;<i> 					path = calloc(XSTATE_MAX_PATH, 4);
</I>&gt;<i> 					path_len = 1;
</I>&gt;<i> @@ -631,14 +631,14 @@
</I>&gt;<i> 					/* see page 22 of XSVF spec */
</I>&gt;<i> 					mystate = uc == 1 ? TAP_IRPAUSE : TAP_IDLE;
</I>&gt;<i>
</I>&gt;<i> -					LOG_DEBUG(&quot;XENDIR 0x%02X %s&quot;, uc, jtag_state_name(mystate));
</I>&gt;<i> +					LOG_DEBUG(&quot;XENDIR 0x%02X %s&quot;, uc, tap_state_name(mystate));
</I>&gt;<i>
</I>&gt;<i> 					/* assuming that the XRUNTEST comes from SVF RUNTEST, then only  
</I>&gt;<i> these states
</I>&gt;<i> 					 * should come here because the SVF spec only allows these with  
</I>&gt;<i> a RUNTEST
</I>&gt;<i> 					 */
</I>&gt;<i> 					if (mystate != TAP_IRPAUSE &amp;&amp; mystate != TAP_DRPAUSE &amp;&amp;  
</I>&gt;<i> mystate != TAP_RESET &amp;&amp; mystate != TAP_IDLE )
</I>&gt;<i> 					{
</I>&gt;<i> -						LOG_ERROR(&quot;illegal XENDIR endstate: \&quot;%s\&quot;&quot;,  
</I>&gt;<i> jtag_state_name(mystate));
</I>&gt;<i> +						LOG_ERROR(&quot;illegal XENDIR endstate: \&quot;%s\&quot;&quot;,  
</I>&gt;<i> tap_state_name(mystate));
</I>&gt;<i> 						unsupported = 1;
</I>&gt;<i> 						break;
</I>&gt;<i> 					}
</I>&gt;<i> @@ -659,11 +659,11 @@
</I>&gt;<i> 					/* see page 22 of XSVF spec */
</I>&gt;<i> 					mystate = uc == 1 ? TAP_DRPAUSE : TAP_IDLE;
</I>&gt;<i>
</I>&gt;<i> -					LOG_DEBUG(&quot;XENDDR %02X %s&quot;, uc, jtag_state_name(mystate));
</I>&gt;<i> +					LOG_DEBUG(&quot;XENDDR %02X %s&quot;, uc, tap_state_name(mystate));
</I>&gt;<i>
</I>&gt;<i> 					if (mystate != TAP_IRPAUSE &amp;&amp; mystate != TAP_DRPAUSE &amp;&amp;  
</I>&gt;<i> mystate != TAP_RESET &amp;&amp; mystate != TAP_IDLE )
</I>&gt;<i> 					{
</I>&gt;<i> -						LOG_ERROR(&quot;illegal XENDDR endstate: \&quot;%s\&quot;&quot;,  
</I>&gt;<i> jtag_state_name( mystate ));
</I>&gt;<i> +						LOG_ERROR(&quot;illegal XENDDR endstate: \&quot;%s\&quot;&quot;,  
</I>&gt;<i> tap_state_name( mystate ));
</I>&gt;<i> 						unsupported = 1;
</I>&gt;<i> 						break;
</I>&gt;<i> 					}
</I>&gt;<i> @@ -798,7 +798,7 @@
</I>&gt;<i> 					end_state  = xsvf_to_tap(end);
</I>&gt;<i> 					delay      = be_to_h_u32(delay_buf);
</I>&gt;<i>
</I>&gt;<i> -					LOG_DEBUG(&quot;XWAIT %s %s usecs:%d&quot;, jtag_state_name(wait_state),  
</I>&gt;<i> jtag_state_name(end_state), delay);
</I>&gt;<i> +					LOG_DEBUG(&quot;XWAIT %s %s usecs:%d&quot;, tap_state_name(wait_state),  
</I>&gt;<i> tap_state_name(end_state), delay);
</I>&gt;<i>
</I>&gt;<i> 					if (runtest_requires_tck &amp;&amp; wait_state == TAP_IDLE )
</I>&gt;<i> 					{
</I>&gt;<i> @@ -844,8 +844,8 @@
</I>&gt;<i> 					usecs       = be_to_h_u32(usecs_buf);
</I>&gt;<i>
</I>&gt;<i> 					LOG_DEBUG(&quot;XWAITSTATE %s %s clocks:%i usecs:%i&quot;,
</I>&gt;<i> -						jtag_state_name(wait_state),
</I>&gt;<i> -						jtag_state_name(end_state),
</I>&gt;<i> +						tap_state_name(wait_state),
</I>&gt;<i> +						tap_state_name(end_state),
</I>&gt;<i> 						clock_count, usecs);
</I>&gt;<i>
</I>&gt;<i> 					/* the following states are 'stable', meaning that they have a  
</I>&gt;<i> transition
</I>&gt;<i> @@ -855,7 +855,7 @@
</I>&gt;<i> 					 */
</I>&gt;<i> 					if (wait_state != TAP_IRPAUSE &amp;&amp; wait_state != TAP_DRPAUSE &amp;&amp;  
</I>&gt;<i> wait_state != TAP_RESET &amp;&amp; wait_state != TAP_IDLE)
</I>&gt;<i> 					{
</I>&gt;<i> -						LOG_ERROR(&quot;illegal XWAITSTATE wait_state: \&quot;%s\&quot;&quot;,  
</I>&gt;<i> jtag_state_name( wait_state ));
</I>&gt;<i> +						LOG_ERROR(&quot;illegal XWAITSTATE wait_state: \&quot;%s\&quot;&quot;,  
</I>&gt;<i> tap_state_name( wait_state ));
</I>&gt;<i> 						unsupported = 1;
</I>&gt;<i> 					}
</I>&gt;<i>
</I>&gt;<i> @@ -908,7 +908,7 @@
</I>&gt;<i> 					loop_clocks = be_to_h_u32(clock_buf);
</I>&gt;<i> 					loop_usecs  = be_to_h_u32(usecs_buf);
</I>&gt;<i>
</I>&gt;<i> -					LOG_DEBUG(&quot;LDELAY %s clocks:%d usecs:%d&quot;,  
</I>&gt;<i> jtag_state_name(loop_state), loop_clocks, loop_usecs);
</I>&gt;<i> +					LOG_DEBUG(&quot;LDELAY %s clocks:%d usecs:%d&quot;,  
</I>&gt;<i> tap_state_name(loop_state), loop_clocks, loop_usecs);
</I>&gt;<i> 				}
</I>&gt;<i> 				break;
</I>&gt;<i>
</I>&gt;<i> Index: src/svf/svf.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- src/svf/svf.c	(revision 1363)
</I>&gt;<i> +++ src/svf/svf.c	(working copy)
</I>&gt;<i> @@ -69,7 +69,7 @@
</I>&gt;<i> 	TRST,
</I>&gt;<i> }svf_command_t;
</I>&gt;<i>
</I>&gt;<i> -const char *svf_command_name[14] =
</I>&gt;<i> +const char *svf_command_name[14] =
</I>&gt;<i> {
</I>&gt;<i> 	&quot;ENDDR&quot;,
</I>&gt;<i> 	&quot;ENDIR&quot;,
</I>&gt;<i> @@ -137,7 +137,7 @@
</I>&gt;<i> }svf_para_t;
</I>&gt;<i>
</I>&gt;<i> svf_para_t svf_para;
</I>&gt;<i> -const svf_para_t svf_para_init =
</I>&gt;<i> +const svf_para_t svf_para_init =
</I>&gt;<i> {
</I>&gt;<i> //	frequency,	ir_end_state,	dr_end_state,	runtest_run_state,	 
</I>&gt;<i> runtest_end_state,	trst_mode
</I>&gt;<i> 	0,			TAP_IDLE,		TAP_IDLE,		TAP_IDLE,			TAP_IDLE,			TRST_Z,
</I>&gt;<i> @@ -318,7 +318,7 @@
</I>&gt;<i> 	memcpy(&amp;svf_para, &amp;svf_para_init, sizeof(svf_para));
</I>&gt;<i> 	for (i = 0; i &lt; dimof(svf_tap_state_name); i++)
</I>&gt;<i> 	{
</I>&gt;<i> -		svf_tap_state_name[i] = (char *)jtag_state_name(i);
</I>&gt;<i> +		svf_tap_state_name[i] = (char *)tap_state_name(i);
</I>&gt;<i> 	}
</I>&gt;<i> 	// TAP_RESET
</I>&gt;<i> 	jtag_add_tlr();
</I>&gt;<i> @@ -653,10 +653,10 @@
</I>&gt;<i> 			{
</I>&gt;<i> 				if ((svf_tdi_buffer[index + j] &amp; svf_mask_buffer[index + j]) !=  
</I>&gt;<i> svf_tdo_buffer[index + j])
</I>&gt;<i> 				{
</I>&gt;<i> -					LOG_ERROR(&quot;tdo check error at line %d, read = 0x%X, want = 0x 
</I>&gt;<i> %X, mask = 0x%X&quot;,
</I>&gt;<i> -								svf_check_tdo_para[i].line_num,
</I>&gt;<i> -								(*(int*)(svf_tdi_buffer + index)) &amp; ((1 &lt;&lt;  
</I>&gt;<i> svf_check_tdo_para[i].bit_len) - 1),
</I>&gt;<i> -								(*(int*)(svf_tdo_buffer + index)) &amp; ((1 &lt;&lt;  
</I>&gt;<i> svf_check_tdo_para[i].bit_len) - 1),
</I>&gt;<i> +					LOG_ERROR(&quot;tdo check error at line %d, read = 0x%X, want = 0x 
</I>&gt;<i> %X, mask = 0x%X&quot;,
</I>&gt;<i> +								svf_check_tdo_para[i].line_num,
</I>&gt;<i> +								(*(int*)(svf_tdi_buffer + index)) &amp; ((1 &lt;&lt;  
</I>&gt;<i> svf_check_tdo_para[i].bit_len) - 1),
</I>&gt;<i> +								(*(int*)(svf_tdo_buffer + index)) &amp; ((1 &lt;&lt;  
</I>&gt;<i> svf_check_tdo_para[i].bit_len) - 1),
</I>&gt;<i> 								(*(int*)(svf_mask_buffer + index)) &amp; ((1 &lt;&lt;  
</I>&gt;<i> svf_check_tdo_para[i].bit_len) - 1));
</I>&gt;<i> 					return ERROR_FAIL;
</I>&gt;<i> 				}
</I>&gt;<i> @@ -872,7 +872,7 @@
</I>&gt;<i> 			}
</I>&gt;<i> 			LOG_DEBUG(&quot;\t%s = 0x%X&quot;, argus[i], (**(int**)pbuffer_tmp) &amp; ((1  
</I>&gt;<i> &lt;&lt; (xxr_para_tmp-&gt;len)) - 1));
</I>&gt;<i> 		}
</I>&gt;<i> -		// If a command changes the length of the last scan of the same  
</I>&gt;<i> type and the MASK parameter is absent,
</I>&gt;<i> +		// If a command changes the length of the last scan of the same  
</I>&gt;<i> type and the MASK parameter is absent,
</I>&gt;<i> 		// the mask pattern used is all cares
</I>&gt;<i> 		if (!(xxr_para_tmp-&gt;data_mask &amp; XXR_MASK) &amp;&amp; (i_tmp !=  
</I>&gt;<i> xxr_para_tmp-&gt;len))
</I>&gt;<i> 		{
</I>&gt;<i>
</I>&gt;<i> Property changes on: tools/xsvf_tools/xsvfdump.py
</I>&gt;<i> ___________________________________________________________________
</I>&gt;<i> Added: svn:executable
</I>&gt;<i>   + *
</I>&gt;<i>
</I>&gt;<i> Index: tools/xsvf_tools/svf2xsvf.py
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- tools/xsvf_tools/svf2xsvf.py	(revision 1363)
</I>&gt;<i> +++ tools/xsvf_tools/svf2xsvf.py	(working copy)
</I>&gt;<i> @@ -704,6 +704,8 @@
</I>&gt;<i>             nextTok()
</I>&gt;<i>             if tokVal != ';':
</I>&gt;<i>                 raise ParseError( tokLn, tokVal, &quot;Expecting ';'  
</I>&gt;<i> after TRST trst_mode&quot;)
</I>&gt;<i> +            if doCOMMENTs:
</I>&gt;<i> +                writeComment( output, tokLn, 'TRST %s' % trst_mode )
</I>&gt;<i>             obuf = bytearray( 2 )
</I>&gt;<i>             obuf[0] = XTRST
</I>&gt;<i>             obuf[1] = trst_mode_allowed.index( trst_mode )  # use  
</I>&gt;<i> the index as the binary argument to XTRST opcode
</I>&gt;<i>
</I>&gt;<i> Property changes on: tools/xsvf_tools/svf2xsvf.py
</I>&gt;<i> ___________________________________________________________________
</I>&gt;<i> Added: svn:executable
</I>&gt;<i>   + *
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Openocd-development mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">Openocd-development at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">https://lists.berlios.de/mailman/listinfo/openocd-development</A>
</I>
--
Rick Altherr
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">kc8apf at kc8apf.net</A>

&quot;He said he hadn't had a byte in three days. I had a short, so I split  
it with him.&quot;
  -- Unsigned



-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 2446 bytes
Desc: not available
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/openocd-development/attachments/20090201/eac04a8a/attachment.bin">https://lists.berlios.de/pipermail/openocd-development/attachments/20090201/eac04a8a/attachment.bin</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004773.html">[Openocd-development] tap_move in src/jtag/jtag.c
</A></li>
	<LI>Next message: <A HREF="004632.html">[Openocd-development] [PATCH] Cable Driver Helper API
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4630">[ date ]</a>
              <a href="thread.html#4630">[ thread ]</a>
              <a href="subject.html#4630">[ subject ]</a>
              <a href="author.html#4630">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-development">More information about the Openocd-development
mailing list</a><br>
</body></html>
