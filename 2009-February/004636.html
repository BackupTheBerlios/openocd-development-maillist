<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-development] [PATCH] uncrustify support
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-development/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20%5BPATCH%5D%20uncrustify%20support&In-Reply-To=%3C6100683A-C3C7-4539-BB4D-539285B3CD21%40kc8apf.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004635.html">
   <LINK REL="Next"  HREF="004637.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-development] [PATCH] uncrustify support</H1>
    <B>Rick Altherr</B> 
    <A HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20%5BPATCH%5D%20uncrustify%20support&In-Reply-To=%3C6100683A-C3C7-4539-BB4D-539285B3CD21%40kc8apf.net%3E"
       TITLE="[Openocd-development] [PATCH] uncrustify support">kc8apf at kc8apf.net
       </A><BR>
    <I>Tue Feb  3 05:28:45 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="004635.html">[Openocd-development] [PATCH] Doxygen
</A></li>
        <LI>Next message: <A HREF="004637.html">[Openocd-development] [PATCH] Doxygen
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4636">[ date ]</a>
              <a href="thread.html#4636">[ thread ]</a>
              <a href="subject.html#4636">[ subject ]</a>
              <a href="author.html#4636">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Committed in r1364.

Rick

On Jan 31, 2009, at 7:45 AM, Dick Hollenbeck wrote:

&gt;<i> Sorry, I found a couple of items I did not like.
</I>&gt;<i> This patch is better.  Please use it instead.
</I>&gt;<i>
</I>&gt;<i> Also:   svn-eol style on both and &quot;executable&quot; settings on *.sh are  
</I>&gt;<i> requested on these files.
</I>&gt;<i>
</I>&gt;<i> Thanks,
</I>&gt;<i>
</I>&gt;<i> Dick
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Index: uncrustify.cfg
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- uncrustify.cfg	(revision 0)
</I>&gt;<i> +++ uncrustify.cfg	(revision 0)
</I>&gt;<i> @@ -0,0 +1,1161 @@
</I>&gt;<i> +# Uncrustify 0.51+svn
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# General options
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# The type of line endings
</I>&gt;<i> +newlines                                 = auto     # auto/lf/crlf/cr
</I>&gt;<i> +
</I>&gt;<i> +# The original size of tabs in the input
</I>&gt;<i> +input_tab_size                           = 4        # number
</I>&gt;<i> +
</I>&gt;<i> +# The size of tabs in the output (only used if align_with_tabs=true)
</I>&gt;<i> +output_tab_size                          = 4        # number
</I>&gt;<i> +
</I>&gt;<i> +# The ascii value of the string escape char, usually 92 (\) or 94  
</I>&gt;<i> (^). (Pawn)
</I>&gt;<i> +string_escape_char                       = 92       # number
</I>&gt;<i> +
</I>&gt;<i> +# Alternate string escape char for Pawn. Only works right before  
</I>&gt;<i> the quote char.
</I>&gt;<i> +string_escape_char2                      = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Indenting
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# The number of columns to indent per level.
</I>&gt;<i> +# Usually 2, 3, 4, or 8.
</I>&gt;<i> +indent_columns                           = 4        # number
</I>&gt;<i> +
</I>&gt;<i> +# How to use tabs when indenting code
</I>&gt;<i> +# 0=spaces only
</I>&gt;<i> +# 1=indent with tabs, align with spaces
</I>&gt;<i> +# 2=indent and align with tabs
</I>&gt;<i> +indent_with_tabs                         = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether to indent strings broken by '\' so that they line up
</I>&gt;<i> +indent_align_string                      = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# The number of spaces to indent multi-line XML strings.
</I>&gt;<i> +# Requires indent_align_string=True
</I>&gt;<i> +indent_xml_string                        = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Spaces to indent '{' from level
</I>&gt;<i> +indent_brace                             = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether braces are indented to the body level
</I>&gt;<i> +indent_braces                            = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Disabled indenting function braces if indent_braces is true
</I>&gt;<i> +indent_braces_no_func                    = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Indent based on the size of the brace parent, ie 'if' =&gt; 3  
</I>&gt;<i> spaces, 'for' =&gt; 4 spaces, etc.
</I>&gt;<i> +indent_brace_parent                      = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether the 'namespace' body is indented
</I>&gt;<i> +indent_namespace                         = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether the 'extern &quot;C&quot;' body is indented
</I>&gt;<i> +indent_extern                            = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether the 'class' body is indented
</I>&gt;<i> +indent_class                             = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to indent the stuff after a leading class colon
</I>&gt;<i> +indent_class_colon                       = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# False=treat 'else\nif' as 'else if' for indenting purposes
</I>&gt;<i> +# True=indent the 'if' one level
</I>&gt;<i> +indent_else_if                           = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Amount to indent variable declarations after a open brace.  
</I>&gt;<i> neg=relative, pos=absolute
</I>&gt;<i> +indent_var_def_blk                       = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# True:  indent continued function call parameters one indent level
</I>&gt;<i> +# False: align parameters under the open paren
</I>&gt;<i> +indent_func_call_param                   = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Same as indent_func_call_param, but for function defs
</I>&gt;<i> +indent_func_def_param                    = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Same as indent_func_call_param, but for function protos
</I>&gt;<i> +indent_func_proto_param                  = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Same as indent_func_call_param, but for class declarations
</I>&gt;<i> +indent_func_class_param                  = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Same as indent_func_call_param, but for class variable constructors
</I>&gt;<i> +indent_func_ctor_var_param               = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Same as indent_func_call_param, but for templates
</I>&gt;<i> +indent_template_param                    = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Double the indent for indent_func_xxx_param options
</I>&gt;<i> +indent_func_param_double                 = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Indentation column for standalone 'const' function decl/proto  
</I>&gt;<i> qualifier
</I>&gt;<i> +indent_func_const                        = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Indentation column for standalone 'throw' function decl/proto  
</I>&gt;<i> qualifier
</I>&gt;<i> +indent_func_throw                        = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of spaces to indent a continued '-&gt;' or '.'
</I>&gt;<i> +# Usually set to 0, 1, or indent_columns.
</I>&gt;<i> +indent_member                            = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Spaces to indent single line ('//') comments on lines before code
</I>&gt;<i> +indent_sing_line_comments                = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# If set, will indent trailing single line ('//') comments relative
</I>&gt;<i> +# to the code instead of trying to keep the same absolute column
</I>&gt;<i> +indent_relative_single_line_comments     = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Spaces to indent 'case' from 'switch'
</I>&gt;<i> +# Usually 0 or indent_columns.
</I>&gt;<i> +indent_switch_case                       = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Spaces to shift the 'case' line, without affecting any other lines
</I>&gt;<i> +# Usually 0.
</I>&gt;<i> +indent_case_shift                        = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Spaces to indent '{' from 'case'.
</I>&gt;<i> +# By default, the brace will appear under the 'c' in case.
</I>&gt;<i> +# Usually set to 0 or indent_columns.
</I>&gt;<i> +indent_case_brace                        = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether to indent comments found in first column
</I>&gt;<i> +indent_col1_comment                      = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# How to indent goto labels
</I>&gt;<i> +#  &gt;0 : absolute column where 1 is the leftmost column
</I>&gt;<i> +#  &lt;=0 : subtract from brace indent
</I>&gt;<i> +indent_label                             = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# Same as indent_label, but for access specifiers that are followed  
</I>&gt;<i> by a colon
</I>&gt;<i> +indent_access_spec                       = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# Indent the code after an access specifier by one level.
</I>&gt;<i> +# If set, this option forces 'indent_access_spec=0'
</I>&gt;<i> +indent_access_spec_body                  = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If an open paren is followed by a newline, indent the next line  
</I>&gt;<i> so that it lines up after the open paren (not recommended)
</I>&gt;<i> +indent_paren_nl                          = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Controls the indent of a close paren after a newline.
</I>&gt;<i> +# 0: Indent to body level
</I>&gt;<i> +# 1: Align under the open paren
</I>&gt;<i> +# 2: Indent to the brace level
</I>&gt;<i> +indent_paren_close                       = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Controls the indent of a comma when inside a paren.If TRUE,  
</I>&gt;<i> aligns under the open paren
</I>&gt;<i> +indent_comma_paren                       = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Controls the indent of a BOOL operator when inside a paren.If  
</I>&gt;<i> TRUE, aligns under the open paren
</I>&gt;<i> +indent_bool_paren                        = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If an open square is followed by a newline, indent the next line  
</I>&gt;<i> so that it lines up after the open square (not recommended)
</I>&gt;<i> +indent_square_nl                         = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Don't change the relative indent of ESQL/C 'EXEC SQL' bodies
</I>&gt;<i> +indent_preserve_sql                      = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Align continued statements at the '='. Default=True
</I>&gt;<i> +# If FALSE or the '=' is followed by a newline, the next line is  
</I>&gt;<i> indent one tab.
</I>&gt;<i> +indent_align_assign                      = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Spacing options
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space around arithmetic operator '+', '-', '/',  
</I>&gt;<i> '*', etc
</I>&gt;<i> +sp_arith                                 = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space around assignment operator '=', '+=', etc
</I>&gt;<i> +sp_assign                                = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before assignment operator '=', '+=', etc.  
</I>&gt;<i> Overrides sp_assign.
</I>&gt;<i> +sp_before_assign                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after assignment operator '=', '+=', etc.  
</I>&gt;<i> Overrides sp_assign.
</I>&gt;<i> +sp_after_assign                          = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space around assignment '=' in enum
</I>&gt;<i> +sp_enum_assign                           = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before assignment '=' in enum. Overrides  
</I>&gt;<i> sp_enum_assign.
</I>&gt;<i> +sp_enum_before_assign                    = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after assignment '=' in enum. Overrides  
</I>&gt;<i> sp_enum_assign.
</I>&gt;<i> +sp_enum_after_assign                     = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space around boolean operators '&amp;&amp;' and '||'
</I>&gt;<i> +sp_bool                                  = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space around compare operator '&lt;', '&gt;', '==', etc
</I>&gt;<i> +sp_compare                               = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside '(' and ')'
</I>&gt;<i> +sp_inside_paren                          = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between nested parens
</I>&gt;<i> +sp_paren_paren                           = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Whether to balance spaces inside nested parens
</I>&gt;<i> +sp_balance_nested_parens                 = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between ')' and '{'
</I>&gt;<i> +sp_paren_brace                           = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before pointer star '*'
</I>&gt;<i> +sp_before_ptr_star                       = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before pointer star '*' that isn't followed  
</I>&gt;<i> by a variable name
</I>&gt;<i> +# If set to 'ignore', sp_before_ptr_star is used instead.
</I>&gt;<i> +sp_before_unnamed_ptr_star               = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between pointer stars '*'
</I>&gt;<i> +sp_between_ptr_star                      = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after pointer star '*', if followed by a word.
</I>&gt;<i> +sp_after_ptr_star                        = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after a pointer star '*', if followed by a  
</I>&gt;<i> func proto/def.
</I>&gt;<i> +sp_after_ptr_star_func                   = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before a pointer star '*', if followed by a  
</I>&gt;<i> func proto/def.
</I>&gt;<i> +sp_before_ptr_star_func                  = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before a reference sign '&amp;'
</I>&gt;<i> +sp_before_byref                          = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before a reference sign '&amp;' that isn't  
</I>&gt;<i> followed by a variable name
</I>&gt;<i> +# If set to 'ignore', sp_before_byref is used instead.
</I>&gt;<i> +sp_before_unnamed_byref                  = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after reference sign '&amp;', if followed by a  
</I>&gt;<i> word.
</I>&gt;<i> +sp_after_byref                           = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after a reference sign '&amp;', if followed by a  
</I>&gt;<i> func proto/def.
</I>&gt;<i> +sp_after_byref_func                      = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before a reference sign '&amp;', if followed by a  
</I>&gt;<i> func proto/def.
</I>&gt;<i> +sp_before_byref_func                     = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between type and word
</I>&gt;<i> +sp_after_type                            = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space in 'template &lt;' vs 'template&lt;'.
</I>&gt;<i> +# If set to ignore, sp_before_angle is used.
</I>&gt;<i> +sp_template_angle                        = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before '&lt;&gt;'
</I>&gt;<i> +sp_before_angle                          = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside '&lt;' and '&gt;'
</I>&gt;<i> +sp_inside_angle                          = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after '&lt;&gt;'
</I>&gt;<i> +sp_after_angle                           = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between '&lt;&gt;' and '(' as found in 'new  
</I>&gt;<i> List&lt;byte&gt;();'
</I>&gt;<i> +sp_angle_paren                           = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between '&lt;&gt;' and a word as in 'List&lt;byte&gt; m;'
</I>&gt;<i> +sp_angle_word                            = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before '(' of 'if', 'for', 'switch', and  
</I>&gt;<i> 'while'
</I>&gt;<i> +sp_before_sparen                         = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside if-condition '(' and ')'
</I>&gt;<i> +sp_inside_sparen                         = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before if-condition ')'. Overrides  
</I>&gt;<i> sp_inside_sparen.
</I>&gt;<i> +sp_inside_sparen_close                   = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after ')' of 'if', 'for', 'switch', and 'while'
</I>&gt;<i> +sp_after_sparen                          = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between ')' and '{' of 'if', 'for', 'switch',  
</I>&gt;<i> and 'while'
</I>&gt;<i> +sp_sparen_brace                          = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'invariant' and '(' in the D language.
</I>&gt;<i> +sp_invariant_paren                       = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the ')' in 'invariant (C) c' in the D  
</I>&gt;<i> language.
</I>&gt;<i> +sp_after_invariant_paren                 = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before empty statement ';' on 'if', 'for' and  
</I>&gt;<i> 'while'
</I>&gt;<i> +sp_special_semi                          = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before ';'
</I>&gt;<i> +sp_before_semi                           = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before ';' in non-empty 'for' statements
</I>&gt;<i> +sp_before_semi_for                       = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before a semicolon of an empty part of a for  
</I>&gt;<i> statment.
</I>&gt;<i> +sp_before_semi_for_empty                 = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the final semicolon of an empty part of  
</I>&gt;<i> a for statment: for ( ; ; &lt;here&gt; ).
</I>&gt;<i> +sp_after_semi_for_empty                  = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before '[' (except '[]')
</I>&gt;<i> +sp_before_square                         = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before '[]'
</I>&gt;<i> +sp_before_squares                        = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside '[' and ']'
</I>&gt;<i> +sp_inside_square                         = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after ','
</I>&gt;<i> +sp_after_comma                           = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before ','
</I>&gt;<i> +sp_before_comma                          = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after class ':'
</I>&gt;<i> +sp_after_class_colon                     = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before class ':'
</I>&gt;<i> +sp_before_class_colon                    = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before case ':'
</I>&gt;<i> +sp_before_case_colon                     = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'operator' and operator sign
</I>&gt;<i> +sp_after_operator                        = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between the operator symbol and the open  
</I>&gt;<i> paren, as in 'operator ++('
</I>&gt;<i> +sp_after_operator_sym                    = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after C/D cast, ie 'cast(int)a' vs 'cast(int)  
</I>&gt;<i> a' or '(int)a' vs '(int) a'
</I>&gt;<i> +sp_after_cast                            = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove spaces inside cast parens
</I>&gt;<i> +sp_inside_paren_cast                     = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between the type and open paren in a C++  
</I>&gt;<i> cast, ie 'int(exp)' vs 'int (exp)'
</I>&gt;<i> +sp_cpp_cast_paren                        = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'sizeof' and '('
</I>&gt;<i> +sp_sizeof_paren                          = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the tag keyword (Pawn)
</I>&gt;<i> +sp_after_tag                             = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside enum '{' and '}'
</I>&gt;<i> +sp_inside_braces_enum                    = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside struct/union '{' and '}'
</I>&gt;<i> +sp_inside_braces_struct                  = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside '{' and '}'
</I>&gt;<i> +sp_inside_braces                         = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside '{}'
</I>&gt;<i> +sp_inside_braces_empty                   = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between return type and function name
</I>&gt;<i> +# A minimum of 1 is forced except for pointer return types.
</I>&gt;<i> +sp_type_func                             = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between function name and '(' on function  
</I>&gt;<i> declaration
</I>&gt;<i> +sp_func_proto_paren                      = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between function name and '(' on function  
</I>&gt;<i> definition
</I>&gt;<i> +sp_func_def_paren                        = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside empty function '()'
</I>&gt;<i> +sp_inside_fparens                        = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space inside function '(' and ')'
</I>&gt;<i> +sp_inside_fparen                         = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between ']' and '(' when part of a function  
</I>&gt;<i> call.
</I>&gt;<i> +sp_square_fparen                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between ')' and '{' of function
</I>&gt;<i> +sp_fparen_brace                          = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between function name and '(' on function calls
</I>&gt;<i> +sp_func_call_paren                       = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between the user function name and '(' on  
</I>&gt;<i> function calls
</I>&gt;<i> +# You need to set a keyword to be a user function, like this: 'set  
</I>&gt;<i> func_call_user _' in the config file.
</I>&gt;<i> +sp_func_call_user_paren                  = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between a constructor/destructor and the open  
</I>&gt;<i> paren
</I>&gt;<i> +sp_func_class_paren                      = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'return' and '('
</I>&gt;<i> +sp_return_paren                          = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between '__attribute__' and '('
</I>&gt;<i> +sp_attribute_paren                       = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'defined' and '(' in '#if defined  
</I>&gt;<i> (FOO)'
</I>&gt;<i> +sp_defined_paren                         = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'throw' and '(' in 'throw (something)'
</I>&gt;<i> +sp_throw_paren                           = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between macro and value
</I>&gt;<i> +sp_macro                                 = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between macro function ')' and value
</I>&gt;<i> +sp_macro_func                            = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'else' and '{' if on the same line
</I>&gt;<i> +sp_else_brace                            = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between '}' and 'else' if on the same line
</I>&gt;<i> +sp_brace_else                            = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between '}' and the name of a typedef on the  
</I>&gt;<i> same line
</I>&gt;<i> +sp_brace_typedef                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'catch' and '{' if on the same line
</I>&gt;<i> +sp_catch_brace                           = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between '}' and 'catch' if on the same line
</I>&gt;<i> +sp_brace_catch                           = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'finally' and '{' if on the same line
</I>&gt;<i> +sp_finally_brace                         = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between '}' and 'finally' if on the same line
</I>&gt;<i> +sp_brace_finally                         = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between 'try' and '{' if on the same line
</I>&gt;<i> +sp_try_brace                             = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space between get/set and '{' if on the same line
</I>&gt;<i> +sp_getset_brace                          = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before the '::' operator
</I>&gt;<i> +sp_before_dc                             = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the '::' operator
</I>&gt;<i> +sp_after_dc                              = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove around the D named array initializer ':' operator
</I>&gt;<i> +sp_d_array_colon                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the '!' (not) operator.
</I>&gt;<i> +sp_not                                   = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the '~' (invert) operator.
</I>&gt;<i> +sp_inv                                   = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the '&amp;' (address-of) operator.
</I>&gt;<i> +# This does not affect the spacing after a '&amp;' that is part of a  
</I>&gt;<i> type.
</I>&gt;<i> +sp_addr                                  = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space around the '.' or '-&gt;' operators
</I>&gt;<i> +sp_member                                = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the '*' (dereference) operator.
</I>&gt;<i> +# This does not affect the spacing after a '*' that is part of a  
</I>&gt;<i> type.
</I>&gt;<i> +sp_deref                                 = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after '+' or '-', as in 'x = -5' or 'y = +7'
</I>&gt;<i> +sp_sign                                  = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before or after '++' and '--', as in '(--x)'  
</I>&gt;<i> or 'y++;'
</I>&gt;<i> +sp_incdec                                = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before a backslash-newline at the end of a line
</I>&gt;<i> +sp_before_nl_cont                        = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the scope '+' or '-', as in '-(void)  
</I>&gt;<i> foo;' or '+(int) bar;'
</I>&gt;<i> +sp_after_oc_scope                        = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the colon in message specs
</I>&gt;<i> +# '-(int) f:(int) x;' vs '-(int) f: (int) x;'
</I>&gt;<i> +sp_after_oc_colon                        = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before the colon in message specs
</I>&gt;<i> +# '-(int) f: (int) x;' vs '-(int) f : (int) x;'
</I>&gt;<i> +sp_before_oc_colon                       = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the colon in message specs
</I>&gt;<i> +# '[object setValue:1];' vs '[object setValue: 1];'
</I>&gt;<i> +sp_after_send_oc_colon                   = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space before the colon in message specs
</I>&gt;<i> +# '[object setValue:1];' vs '[object setValue :1];'
</I>&gt;<i> +sp_before_send_oc_colon                  = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after the (type) in message specs
</I>&gt;<i> +# '-(int) f: (int) x;' vs '-(int) f: (int)x;'
</I>&gt;<i> +sp_after_oc_type                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space around the ':' in 'b ? t : f'
</I>&gt;<i> +sp_cond_colon                            = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space around the '?' in 'b ? t : f'
</I>&gt;<i> +sp_cond_question                         = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Fix the spacing between 'case' and the label. Only 'ignore' and  
</I>&gt;<i> 'force' make sense here.
</I>&gt;<i> +sp_case_label                            = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Control the space around the D '..' operator.
</I>&gt;<i> +sp_range                                 = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Control the space after the opening of a C++ comment '// A' vs '// 
</I>&gt;<i> A'
</I>&gt;<i> +sp_cmt_cpp_start                         = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Code alignment (not left column spaces/tabs)
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# Whether to keep non-indenting tabs
</I>&gt;<i> +align_keep_tabs                          = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to use tabs for alinging
</I>&gt;<i> +align_with_tabs                          = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to bump out to the next tab when aligning
</I>&gt;<i> +align_on_tabstop                         = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to left-align numbers
</I>&gt;<i> +align_number_left                        = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Align variable definitions in prototypes and functions
</I>&gt;<i> +align_func_params                        = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Align parameters in single-line functions that have the same name.
</I>&gt;<i> +# The function names must already be aligned with each other.
</I>&gt;<i> +align_same_func_call_params              = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning variable definitions (0=don't align)
</I>&gt;<i> +align_var_def_span                       = 3        # number
</I>&gt;<i> +
</I>&gt;<i> +# How to align the star in variable definitions.
</I>&gt;<i> +#  0=Part of the type     'void *   foo;'
</I>&gt;<i> +#  1=Part of the variable 'void     *foo;'
</I>&gt;<i> +#  2=Dangling             'void    *foo;'
</I>&gt;<i> +align_var_def_star_style                 = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# How to align the '&amp;' in variable definitions.
</I>&gt;<i> +#  0=Part of the type
</I>&gt;<i> +#  1=Part of the variable
</I>&gt;<i> +#  2=Dangling
</I>&gt;<i> +align_var_def_amp_style                  = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The threshold for aligning variable definitions (0=no limit)
</I>&gt;<i> +align_var_def_thresh                     = 12       # number
</I>&gt;<i> +
</I>&gt;<i> +# The gap for aligning variable definitions
</I>&gt;<i> +align_var_def_gap                        = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether to align the colon in struct bit fields
</I>&gt;<i> +align_var_def_colon                      = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to align inline struct/enum/union variable definitions
</I>&gt;<i> +align_var_def_inline                     = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning on '=' in assignments (0=don't align)
</I>&gt;<i> +align_assign_span                        = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The threshold for aligning on '=' in assignments (0=no limit)
</I>&gt;<i> +align_assign_thresh                      = 4        # number
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning on '=' in enums (0=don't align)
</I>&gt;<i> +align_enum_equ_span                      = 3        # number
</I>&gt;<i> +
</I>&gt;<i> +# The threshold for aligning on '=' in enums (0=no limit)
</I>&gt;<i> +align_enum_equ_thresh                    = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning struct/union (0=don't align)
</I>&gt;<i> +align_var_struct_span                    = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The threshold for aligning struct/union member definitions (0=no  
</I>&gt;<i> limit)
</I>&gt;<i> +align_var_struct_thresh                  = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The gap for aligning struct/union member definitions
</I>&gt;<i> +align_var_struct_gap                     = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning struct initializer values (0=don't align)
</I>&gt;<i> +align_struct_init_span                   = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The minimum space between the type and the synonym of a typedef
</I>&gt;<i> +align_typedef_gap                        = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning single-line typedefs (0=don't align)
</I>&gt;<i> +align_typedef_span                       = 2        # number
</I>&gt;<i> +
</I>&gt;<i> +# How to align typedef'd functions with other typedefs
</I>&gt;<i> +# 0: Don't mix them at all
</I>&gt;<i> +# 1: align the open paren with the types
</I>&gt;<i> +# 2: align the function type name with the other type names
</I>&gt;<i> +align_typedef_func                       = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Controls the positioning of the '*' in typedefs. Just try it.
</I>&gt;<i> +# 0: Align on typdef type, ignore '*'
</I>&gt;<i> +# 1: The '*' is part of type name: typedef int  *pint;
</I>&gt;<i> +# 2: The '*' is part of the type, but dangling: typedef int *pint;
</I>&gt;<i> +align_typedef_star_style                 = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Controls the positioning of the '&amp;' in typedefs. Just try it.
</I>&gt;<i> +# 0: Align on typdef type, ignore '&amp;'
</I>&gt;<i> +# 1: The '&amp;' is part of type name: typedef int  &pint;
</I>&gt;<i> +# 2: The '&amp;' is part of the type, but dangling: typedef int &pint;
</I>&gt;<i> +align_typedef_amp_style                  = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning comments that end lines (0=don't align)
</I>&gt;<i> +align_right_cmt_span                     = 3        # number
</I>&gt;<i> +
</I>&gt;<i> +# If aligning comments, mix with comments after '}' and #endif with  
</I>&gt;<i> less than 3 spaces before the comment
</I>&gt;<i> +align_right_cmt_mix                      = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If a trailing comment is more than this number of columns away  
</I>&gt;<i> from the text it follows,
</I>&gt;<i> +# it will qualify for being aligned.
</I>&gt;<i> +align_right_cmt_gap                      = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning function prototypes (0=don't align)
</I>&gt;<i> +align_func_proto_span                    = 3        # number
</I>&gt;<i> +
</I>&gt;<i> +# Minimum gap between the return type and the function name.
</I>&gt;<i> +align_func_proto_gap                     = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Align function protos on the 'operator' keyword instead of what  
</I>&gt;<i> follows
</I>&gt;<i> +align_on_operator                        = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to mix aligning prototype and variable declarations.
</I>&gt;<i> +# If true, align_var_def_XXX options are used instead of  
</I>&gt;<i> align_func_proto_XXX options.
</I>&gt;<i> +align_mix_var_proto                      = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Align single-line functions with function prototypes, uses  
</I>&gt;<i> align_func_proto_span
</I>&gt;<i> +align_single_line_func                   = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Aligning the open brace of single-line functions.
</I>&gt;<i> +# Requires align_single_line_func=true, uses align_func_proto_span
</I>&gt;<i> +align_single_line_brace                  = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Gap for align_single_line_brace.
</I>&gt;<i> +align_single_line_brace_gap              = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning ObjC msg spec (0=don't align)
</I>&gt;<i> +align_oc_msg_spec_span                   = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether to align macros wrapped with a backslash and a newline.
</I>&gt;<i> +# This will not work right if the macro contains a multi-line  
</I>&gt;<i> comment.
</I>&gt;<i> +align_nl_cont                            = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# The minimum space between label and value of a preprocessor define
</I>&gt;<i> +align_pp_define_gap                      = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The span for aligning on '#define' bodies (0=don't align)
</I>&gt;<i> +align_pp_define_span                     = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# Align lines that start with '&lt;&lt;' with previous '&lt;&lt;'. Default=true
</I>&gt;<i> +align_left_shift                         = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Newline adding and removing options
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# Whether to collapse empty blocks between '{' and '}'
</I>&gt;<i> +nl_collapse_empty_body                   = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Don't split one-line braced assignments - 'foo_t f = { 1, 2 };'
</I>&gt;<i> +nl_assign_leave_one_liners               = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Don't split one-line braced statements inside a class xx { } body
</I>&gt;<i> +nl_class_leave_one_liners                = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Don't split one-line enums: 'enum foo { BAR = 15 };'
</I>&gt;<i> +nl_enum_leave_one_liners                 = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Don't split one-line get or set functions
</I>&gt;<i> +nl_getset_leave_one_liners               = true    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Don't split one-line function definitions - 'int foo() { return  
</I>&gt;<i> 0; }'
</I>&gt;<i> +nl_func_leave_one_liners                 = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Don't split one-line if/else statements - 'if(a) b++;'
</I>&gt;<i> +nl_if_leave_one_liners                   = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newlines at the start of the file
</I>&gt;<i> +nl_start_of_file                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines at the start of the file (only used if  
</I>&gt;<i> nl_start_of_file is 'add' or 'force'
</I>&gt;<i> +nl_start_of_file_min                     = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline at the end of the file
</I>&gt;<i> +nl_end_of_file                           = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines at the end of the file (only used if  
</I>&gt;<i> nl_end_of_file is 'add' or 'force')
</I>&gt;<i> +nl_end_of_file_min                       = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between '=' and '{'
</I>&gt;<i> +nl_assign_brace                          = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between '=' and '[' (D only)
</I>&gt;<i> +nl_assign_square                         = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after '= [' (D only). Will also affect the  
</I>&gt;<i> newline before the ']'
</I>&gt;<i> +nl_after_square_assign                   = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines after a block of variable definitions
</I>&gt;<i> +nl_func_var_def_blk                      = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between a function call's ')' and '{', as in:
</I>&gt;<i> +# list_for_each(item, &amp;list) { }
</I>&gt;<i> +nl_fcall_brace                           = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'enum' and '{'
</I>&gt;<i> +nl_enum_brace                            = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'struct and '{'
</I>&gt;<i> +nl_struct_brace                          = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'union' and '{'
</I>&gt;<i> +nl_union_brace                           = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'if' and '{'
</I>&gt;<i> +nl_if_brace                              = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between '}' and 'else'
</I>&gt;<i> +nl_brace_else                            = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'else if' and '{'
</I>&gt;<i> +# If set to ignore, nl_if_brace is used instead
</I>&gt;<i> +nl_elseif_brace                          = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'else' and '{'
</I>&gt;<i> +nl_else_brace                            = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'else' and 'if'
</I>&gt;<i> +nl_else_if                               = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between '}' and 'finally'
</I>&gt;<i> +nl_brace_finally                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'finally' and '{'
</I>&gt;<i> +nl_finally_brace                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'try' and '{'
</I>&gt;<i> +nl_try_brace                             = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between get/set and '{'
</I>&gt;<i> +nl_getset_brace                          = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'for' and '{'
</I>&gt;<i> +nl_for_brace                             = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'catch' and '{'
</I>&gt;<i> +nl_catch_brace                           = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between '}' and 'catch'
</I>&gt;<i> +nl_brace_catch                           = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'while' and '{'
</I>&gt;<i> +nl_while_brace                           = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'do' and '{'
</I>&gt;<i> +nl_do_brace                              = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between '}' and 'while' of 'do' statement
</I>&gt;<i> +nl_brace_while                           = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'switch' and '{'
</I>&gt;<i> +nl_switch_brace                          = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline when condition spans two or more lines
</I>&gt;<i> +nl_multi_line_cond                       = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Force a newline in a define after the macro name for multi-line  
</I>&gt;<i> defines.
</I>&gt;<i> +nl_multi_line_define                     = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a newline before 'case' statement
</I>&gt;<i> +nl_before_case                           = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between ')' and 'throw'
</I>&gt;<i> +nl_before_throw                          = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a newline after 'case' statement
</I>&gt;<i> +nl_after_case                            = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Newline between namespace and {
</I>&gt;<i> +nl_namespace_brace                       = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'template&lt;&gt;' and whatever follows.
</I>&gt;<i> +nl_template_class                        = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between 'class' and '{'
</I>&gt;<i> +nl_class_brace                           = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after each ',' in the constructor member  
</I>&gt;<i> initialization
</I>&gt;<i> +nl_class_init_args                       = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between return type and function name in  
</I>&gt;<i> definition
</I>&gt;<i> +nl_func_type_name                        = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between return type and function name in a  
</I>&gt;<i> prototype
</I>&gt;<i> +nl_func_proto_type_name                  = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between a function name and the opening '('
</I>&gt;<i> +nl_func_paren                            = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after '(' in a function declaration
</I>&gt;<i> +nl_func_decl_start                       = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after each ',' in a function declaration
</I>&gt;<i> +nl_func_decl_args                        = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline before the ')' in a function declaration
</I>&gt;<i> +nl_func_decl_end                         = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline between function signature and '{'
</I>&gt;<i> +nl_fdef_brace                            = force    # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a newline after 'return' statement
</I>&gt;<i> +nl_after_return                          = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove a newline between the return keyword and return  
</I>&gt;<i> expression.
</I>&gt;<i> +nl_return_expr                           = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a newline after semicolons, except in 'for'  
</I>&gt;<i> statements
</I>&gt;<i> +nl_after_semicolon                       = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a newline after brace open.
</I>&gt;<i> +# This also adds a newline before the matching brace close.
</I>&gt;<i> +nl_after_brace_open                      = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If nl_after_brace_open and nl_after_brace_open_cmt are true, a  
</I>&gt;<i> newline is
</I>&gt;<i> +# placed between the open brace and a trailing single-line comment.
</I>&gt;<i> +nl_after_brace_open_cmt                  = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a newline after a virtual brace open.
</I>&gt;<i> +# These occur in un-braced if/while/do/for statement bodies.
</I>&gt;<i> +nl_after_vbrace_open                     = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to alter newlines in '#define' macros
</I>&gt;<i> +nl_define_macro                          = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to not put blanks after '#ifxx', '#elxx', or before  
</I>&gt;<i> '#endif'
</I>&gt;<i> +nl_squeeze_ifdef                         = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline before 'if'
</I>&gt;<i> +nl_before_if                             = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after 'if'
</I>&gt;<i> +nl_after_if                              = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline before 'for'
</I>&gt;<i> +nl_before_for                            = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after 'for'
</I>&gt;<i> +nl_after_for                             = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline before 'while'
</I>&gt;<i> +nl_before_while                          = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after 'while'
</I>&gt;<i> +nl_after_while                           = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline before 'switch'
</I>&gt;<i> +nl_before_switch                         = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after 'switch'
</I>&gt;<i> +nl_after_switch                          = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline before 'do'
</I>&gt;<i> +nl_before_do                             = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove newline after 'do'
</I>&gt;<i> +nl_after_do                              = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Whether to double-space commented-entries in struct/enum
</I>&gt;<i> +nl_ds_struct_enum_cmt                    = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to double-space before the close brace of a struct/union/ 
</I>&gt;<i> enum
</I>&gt;<i> +nl_ds_struct_enum_close_brace            = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove a newline around a class colon.
</I>&gt;<i> +# Related to pos_class_colon, nl_class_init_args, and pos_comma.
</I>&gt;<i> +nl_class_colon                           = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Change simple unbraced if statements into a one-liner
</I>&gt;<i> +# 'if(b)\n i++;' =&gt; 'if(b) i++;'
</I>&gt;<i> +nl_create_if_one_liner                   = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Change simple unbraced for statements into a one-liner
</I>&gt;<i> +# 'for (i=0;i&lt;5;i++)\n foo(i);' =&gt; 'for (i=0;i&lt;5;i++) foo(i);'
</I>&gt;<i> +nl_create_for_one_liner                  = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Change simple unbraced while statements into a one-liner
</I>&gt;<i> +# 'while (i&lt;5)\n foo(i++);' =&gt; 'while (i&lt;5) foo(i++);'
</I>&gt;<i> +nl_create_while_one_liner                = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Positioning options
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# The position of arithmetic operators in wrapped expressions
</I>&gt;<i> +pos_arith                                = ignore   # ignore/lead/ 
</I>&gt;<i> trail
</I>&gt;<i> +
</I>&gt;<i> +# The position of assignment in wrapped expressions
</I>&gt;<i> +pos_assign                               = ignore   # ignore/lead/ 
</I>&gt;<i> trail
</I>&gt;<i> +
</I>&gt;<i> +# The position of boolean operators in wrapped expressions
</I>&gt;<i> +pos_bool                                 = lead     # ignore/lead/ 
</I>&gt;<i> trail
</I>&gt;<i> +
</I>&gt;<i> +# The position of the comma in wrapped expressions
</I>&gt;<i> +pos_comma                                = trail    # ignore/lead/ 
</I>&gt;<i> trail
</I>&gt;<i> +
</I>&gt;<i> +# The position of the comma in the constructor initialization list
</I>&gt;<i> +pos_class_comma                          = ignore   # ignore/lead/ 
</I>&gt;<i> trail
</I>&gt;<i> +
</I>&gt;<i> +# The position of colons between constructor and member  
</I>&gt;<i> initialization
</I>&gt;<i> +pos_class_colon                          = trail    # ignore/lead/ 
</I>&gt;<i> trail
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Line Splitting options
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# Try to limit code width to N number of columns
</I>&gt;<i> +code_width                               = 120      # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether to fully split long 'for' statements at semi-colons
</I>&gt;<i> +ls_for_split_full                        = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to fully split long function protos/calls at commas
</I>&gt;<i> +ls_func_split_full                       = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Blank line options
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# The maximum consecutive newlines
</I>&gt;<i> +nl_max                                   = 3        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines after a function prototype, if followed by  
</I>&gt;<i> another function prototype
</I>&gt;<i> +nl_after_func_proto                      = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines after a function prototype, if not  
</I>&gt;<i> followed by another function prototype
</I>&gt;<i> +nl_after_func_proto_group                = 2        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines after '}' of a multi-line function body
</I>&gt;<i> +nl_after_func_body                       = 3        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines after '}' of a single line function body
</I>&gt;<i> +nl_after_func_body_one_liner             = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The minimum number of newlines before a multi-line comment.
</I>&gt;<i> +# Doesn't apply if after a brace open or another multi-line comment.
</I>&gt;<i> +nl_before_block_comment                  = 2        # number
</I>&gt;<i> +
</I>&gt;<i> +# The minimum number of newlines before a single-line C comment.
</I>&gt;<i> +# Doesn't apply if after a brace open or other single-line C  
</I>&gt;<i> comments.
</I>&gt;<i> +nl_before_c_comment                      = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The minimum number of newlines before a CPP comment.
</I>&gt;<i> +# Doesn't apply if after a brace open or other CPP comments.
</I>&gt;<i> +nl_before_cpp_comment                    = 2        # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether to force a newline after a mulit-line comment.
</I>&gt;<i> +nl_after_multiline_comment               = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines before a 'private:', 'public:',  
</I>&gt;<i> 'protected:', 'signals:', or 'slots:' label.
</I>&gt;<i> +# Will not change the newline count if after a brace open.
</I>&gt;<i> +# 0 = No change.
</I>&gt;<i> +nl_before_access_spec                    = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines after a 'private:', 'public:',  
</I>&gt;<i> 'protected:', 'signals:', or 'slots:' label.
</I>&gt;<i> +# 0 = No change.
</I>&gt;<i> +nl_after_access_spec                     = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines between a function def and the function  
</I>&gt;<i> comment.
</I>&gt;<i> +# 0 = No change.
</I>&gt;<i> +nl_comment_func_def                      = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines after a try-catch-finally block that isn't  
</I>&gt;<i> followed by a brace close.
</I>&gt;<i> +# 0 = No change.
</I>&gt;<i> +nl_after_try_catch_finally               = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines before and after a property, indexer or  
</I>&gt;<i> event decl.
</I>&gt;<i> +# 0 = No change.
</I>&gt;<i> +nl_around_cs_property                    = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of newlines between the get/set/add/remove handlers in  
</I>&gt;<i> C#.
</I>&gt;<i> +# 0 = No change.
</I>&gt;<i> +nl_between_get_set                       = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether to remove blank lines after '{'
</I>&gt;<i> +eat_blanks_after_open_brace              = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to remove blank lines before '}'
</I>&gt;<i> +eat_blanks_before_close_brace            = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Code modifying options (non-whitespace)
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove braces on single-line 'do' statement
</I>&gt;<i> +mod_full_brace_do                        = add      # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove braces on single-line 'for' statement
</I>&gt;<i> +mod_full_brace_for                       = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove braces on single-line function defintions. (Pawn)
</I>&gt;<i> +mod_full_brace_function                  = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove braces on single-line 'if' statement. Will not  
</I>&gt;<i> remove the braces if they contain an 'else'.
</I>&gt;<i> +mod_full_brace_if                        = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Don't remove braces around statements that span N newlines
</I>&gt;<i> +mod_full_brace_nl                        = 3        # number
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove braces on single-line 'while' statement
</I>&gt;<i> +mod_full_brace_while                     = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove unnecessary paren on 'return' statement
</I>&gt;<i> +mod_paren_on_return                      = remove   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Whether to change optional semicolons to real semicolons
</I>&gt;<i> +mod_pawn_semicolon                       = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Add parens on 'while' and 'if' statement around bools
</I>&gt;<i> +mod_full_paren_if_bool                   = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to remove superfluous semicolons
</I>&gt;<i> +mod_remove_extra_semicolon               = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If a function body exceeds the specified number of newlines and  
</I>&gt;<i> doesn't have a comment after
</I>&gt;<i> +# the close brace, a comment will be added.
</I>&gt;<i> +mod_add_long_function_closebrace_comment = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# If a switch body exceeds the specified number of newlines and  
</I>&gt;<i> doesn't have a comment after
</I>&gt;<i> +# the close brace, a comment will be added.
</I>&gt;<i> +mod_add_long_switch_closebrace_comment   = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# If TRUE, will sort consecutive single-line 'import' statements  
</I>&gt;<i> [Java, D]
</I>&gt;<i> +mod_sort_import                          = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If TRUE, will sort consecutive single-line 'using' statements [C#]
</I>&gt;<i> +mod_sort_using                           = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If TRUE, will sort consecutive single-line '#include' statements  
</I>&gt;<i> [C/C++] and '#import' statements [Obj-C]
</I>&gt;<i> +# This is generally a bad idea, as it may break your code.
</I>&gt;<i> +mod_sort_include                         = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If TRUE, it will move a 'break' that appears after a fully braced  
</I>&gt;<i> 'case' before the close brace.
</I>&gt;<i> +mod_move_case_break                      = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If TRUE, it will remove a void 'return;' that appears as the last  
</I>&gt;<i> statement in a function.
</I>&gt;<i> +mod_remove_empty_return                  = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Comment modifications
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# Try to wrap comments at cmt_width columns
</I>&gt;<i> +cmt_width                                = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# If false, disable all multi-line comment changes, including  
</I>&gt;<i> cmt_width and leading chars.
</I>&gt;<i> +# Default is true.
</I>&gt;<i> +cmt_indent_multi                         = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to group c-comments that look like they are in a block
</I>&gt;<i> +cmt_c_group                              = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put an empty '/*' on the first line of the combined c- 
</I>&gt;<i> comment
</I>&gt;<i> +cmt_c_nl_start                           = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a newline before the closing '*/' of the combined  
</I>&gt;<i> c-comment
</I>&gt;<i> +cmt_c_nl_end                             = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to group cpp-comments that look like they are in a block
</I>&gt;<i> +cmt_cpp_group                            = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put an empty '/*' on the first line of the combined  
</I>&gt;<i> cpp-comment
</I>&gt;<i> +cmt_cpp_nl_start                         = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a newline before the closing '*/' of the combined  
</I>&gt;<i> cpp-comment
</I>&gt;<i> +cmt_cpp_nl_end                           = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to change cpp-comments into c-comments
</I>&gt;<i> +cmt_cpp_to_c                             = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to put a star on subsequent comment lines
</I>&gt;<i> +cmt_star_cont                            = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# The number of spaces to insert at the start of subsequent comment  
</I>&gt;<i> lines
</I>&gt;<i> +cmt_sp_before_star_cont                  = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# The number of spaces to insert after the star on subsequent  
</I>&gt;<i> comment lines
</I>&gt;<i> +cmt_sp_after_star_cont                   = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# For multi-line comments with a '*' lead, remove leading spaces if  
</I>&gt;<i> the first and last lines of
</I>&gt;<i> +# the comment are the same length. Default=True
</I>&gt;<i> +cmt_multi_check_last                     = true     # false/true
</I>&gt;<i> +
</I>&gt;<i> +# The filename that contains text to insert at the head of a file  
</I>&gt;<i> if the file doesn't start with a C/C++ comment.
</I>&gt;<i> +# Will substitue $(filename) with the current file's name.
</I>&gt;<i> +cmt_insert_file_header                   = &quot;&quot;         # string
</I>&gt;<i> +
</I>&gt;<i> +# The filename that contains text to insert before a function  
</I>&gt;<i> implementation if the function isn't preceeded with a C/C++ comment.
</I>&gt;<i> +# Will substitue $(function) with the function name and $ 
</I>&gt;<i> (javaparam) with the javadoc @param and @return stuff.
</I>&gt;<i> +# Will also substitute $(fclass) with the class name: void  
</I>&gt;<i> CFoo::Bar() { ... }
</I>&gt;<i> +cmt_insert_func_header                   = &quot;&quot;         # string
</I>&gt;<i> +
</I>&gt;<i> +# The filename that contains text to insert before a class if the  
</I>&gt;<i> class isn't preceeded with a C/C++ comment.
</I>&gt;<i> +# Will substitue $(class) with the class name.
</I>&gt;<i> +cmt_insert_class_header                  = &quot;&quot;         # string
</I>&gt;<i> +
</I>&gt;<i> +# If a preprocessor is encountered when stepping backwards from a  
</I>&gt;<i> function name, then
</I>&gt;<i> +# this option decides whether the comment should be inserted.
</I>&gt;<i> +# Affects cmt_insert_func_header and cmt_insert_class_header.
</I>&gt;<i> +cmt_insert_before_preproc                = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +#
</I>&gt;<i> +# Preprocessor options
</I>&gt;<i> +#
</I>&gt;<i> +
</I>&gt;<i> +# Control indent of preprocessors inside #if blocks at brace level 0
</I>&gt;<i> +pp_indent                                = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Whether to indent #if/#else/#endif at the brace level (true) or  
</I>&gt;<i> from column 1 (false)
</I>&gt;<i> +pp_indent_at_level                       = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If pp_indent_at_level=false, specifies the number of columns to  
</I>&gt;<i> indent per level. Default=1.
</I>&gt;<i> +pp_indent_count                          = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# Add or remove space after # based on pp_level of #if blocks
</I>&gt;<i> +pp_space                                 = ignore   # ignore/add/ 
</I>&gt;<i> remove/force
</I>&gt;<i> +
</I>&gt;<i> +# Sets the number of spaces added with pp_space
</I>&gt;<i> +pp_space_count                           = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# The indent for #region and #endregion in C# and '#pragma region'  
</I>&gt;<i> in C/C++
</I>&gt;<i> +pp_indent_region                         = 0        # number
</I>&gt;<i> +
</I>&gt;<i> +# Whether to indent the code between #region and #endregion
</I>&gt;<i> +pp_region_indent_code                    = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# If pp_indent_at_level=true, sets the indent for #if, #else, and  
</I>&gt;<i> #endif when not at file-level
</I>&gt;<i> +pp_indent_if                             = 1        # number
</I>&gt;<i> +
</I>&gt;<i> +# Control whether to indent the code between #if, #else and #endif  
</I>&gt;<i> when not at file-level
</I>&gt;<i> +pp_if_indent_code                        = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# Whether to indent '#define' at the brace level (true) or from  
</I>&gt;<i> column 1 (false)
</I>&gt;<i> +pp_define_at_level                       = false    # false/true
</I>&gt;<i> +
</I>&gt;<i> +# You can force a token to be a type with the 'type' option.
</I>&gt;<i> +# Example:
</I>&gt;<i> +# type myfoo1 myfoo2
</I>&gt;<i> +#
</I>&gt;<i> +# You can create custom macro-based indentation using macro-open,
</I>&gt;<i> +# macro-else and macro-close.
</I>&gt;<i> +# Example:
</I>&gt;<i> +# macro-open  BEGIN_TEMPLATE_MESSAGE_MAP
</I>&gt;<i> +# macro-open  BEGIN_MESSAGE_MAP
</I>&gt;<i> +# macro-close END_MESSAGE_MAP
</I>&gt;<i> +#
</I>&gt;<i> +# You can assign any keyword to any type with the set option.
</I>&gt;<i> +# set func_call_user _ N_
</I>&gt;<i> Index: uncrustify1.sh
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- uncrustify1.sh	(revision 0)
</I>&gt;<i> +++ uncrustify1.sh	(revision 0)
</I>&gt;<i> @@ -0,0 +1,30 @@
</I>&gt;<i> +#!/bin/sh
</I>&gt;<i> +# Run the beautifier &quot;Uncrustify&quot; on a single file.
</I>&gt;<i> +# Because the file &quot;uncrustify.cfg&quot; only exists in the top level of  
</I>&gt;<i> the project
</I>&gt;<i> +# you should run this script from there so this script can find  
</I>&gt;<i> your uncrustify.cfg file.
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +UNCRUSTIFYTMP=/tmp/uncrustify.tmp
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +if [ ! -f uncrustify.cfg ]; then
</I>&gt;<i> +    echo &quot;unable to find uncrustify.cfg, aborting&quot;
</I>&gt;<i> +    exit 1
</I>&gt;<i> +fi
</I>&gt;<i> +
</I>&gt;<i> +UNCRUSTIFYBIN=`which uncrustify`
</I>&gt;<i> +
</I>&gt;<i> +if [ &quot;$UNCRUSTIFYBIN&quot; = &quot;&quot; ]; then
</I>&gt;<i> +    echo &quot;you must specify uncrustify in your PATH, I cannot find it&quot;
</I>&gt;<i> +    exit 2
</I>&gt;<i> +fi
</I>&gt;<i> +
</I>&gt;<i> +if [ $# -lt 1 ]; then
</I>&gt;<i> +    echo &quot;Usage $0 &lt;filename .c or .h&gt;&quot;
</I>&gt;<i> +    exit 3
</I>&gt;<i> +fi
</I>&gt;<i> +
</I>&gt;<i> +uncrustify -c uncrustify.cfg &lt;$1 &gt;$UNCRUSTIFYTMP
</I>&gt;<i> +
</I>&gt;<i> +# you can comment this out while tuning the uncrustify.cfg file:
</I>&gt;<i> +mv $UNCRUSTIFYTMP $1
</I>&gt;<i>
</I>&gt;<i> Property changes on: uncrustify1.sh
</I>&gt;<i> ___________________________________________________________________
</I>&gt;<i> Added: svn:executable
</I>&gt;<i>   + *
</I>&gt;<i> Added: svn:mime-type
</I>&gt;<i>   + text/x-sh
</I>&gt;<i> Added: svn:keywords
</I>&gt;<i>   + Id
</I>&gt;<i> Added: svn:eol-style
</I>&gt;<i>   + native
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Openocd-development mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">Openocd-development at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">https://lists.berlios.de/mailman/listinfo/openocd-development</A>
</I>
--
Rick Altherr
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">kc8apf at kc8apf.net</A>

&quot;He said he hadn't had a byte in three days. I had a short, so I split  
it with him.&quot;
  -- Unsigned



-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 2446 bytes
Desc: not available
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/openocd-development/attachments/20090202/87194530/attachment.bin">https://lists.berlios.de/pipermail/openocd-development/attachments/20090202/87194530/attachment.bin</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004635.html">[Openocd-development] [PATCH] Doxygen
</A></li>
	<LI>Next message: <A HREF="004637.html">[Openocd-development] [PATCH] Doxygen
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4636">[ date ]</a>
              <a href="thread.html#4636">[ thread ]</a>
              <a href="subject.html#4636">[ subject ]</a>
              <a href="author.html#4636">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-development">More information about the Openocd-development
mailing list</a><br>
</body></html>
