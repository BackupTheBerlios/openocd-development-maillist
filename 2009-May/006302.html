<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-development] The &quot;in_handler&quot; Incident
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-development/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20The%20%22in_handler%22%20Incident&In-Reply-To=%3C4A04918E.3000709%40mlu.mine.nu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006299.html">
   <LINK REL="Next"  HREF="006311.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-development] The &quot;in_handler&quot; Incident</H1>
    <B>Magnus Lundin</B> 
    <A HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20The%20%22in_handler%22%20Incident&In-Reply-To=%3C4A04918E.3000709%40mlu.mine.nu%3E"
       TITLE="[Openocd-development] The &quot;in_handler&quot; Incident">lundin at mlu.mine.nu
       </A><BR>
    <I>Fri May  8 22:09:50 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="006299.html">[Openocd-development] The &quot;in_handler&quot; Incident
</A></li>
        <LI>Next message: <A HREF="006311.html">[Openocd-development] The &quot;in_handler&quot; Incident
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6302">[ date ]</a>
              <a href="thread.html#6302">[ thread ]</a>
              <a href="subject.html#6302">[ subject ]</a>
              <a href="author.html#6302">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I will not reply to specific comments but rather make some more general 
statements that hopefully are relevant, I know that this somewhat 
overlap the solicitations for process.

-  During all of this I and &#214;yvind have been communicating patches, 
error reporting and suggestions. He has handled that very well even if 
he is a stubborn Viking from the west fiords (we know them around here, 
bet Egil was worse)

-  The disagreements has nothing whatsoever to do with formatting or 
whitespace policies, it is about deeply tchnical issues and about how we 
resolve differences of opinion. It is not about the verision handling 
system, git might be useful to find a release where things broke but I 
could do that with SVN in 30 minutes for the arm_adi code I was focusing on.

-  Making every nontrivial patch pass through  a community process will 
slow development to a halt, this community does not work like that. We 
have more priciple discussions than discussion about actual technical 
merit. How many here do actually analyze the code and potential impact 
before arguing? I often subit nontrivial changes to the Cortex 
subsystem, who wants to review them ? I really would like that input, 
and rest assured I do have a long list of internals that should be fixed up.

- I am warming to the use of a stable branch and an unstable branch. We 
have had  small fixes reported, I have outstanding work  that I would 
not hesitate to commit to a stable branch  but presently I have put them 
on hold.

Best regards
Magnus


Zach Welch wrote:
&gt;<i> On Fri, 2009-05-08 at 17:05 +0200, Magnus Lundin wrote: 
</I>&gt;<i>   
</I>&gt;&gt;<i> Zach Welch wrote:
</I>&gt;&gt;<i>     
</I>&gt;&gt;&gt;<i> On Fri, 2009-05-08 at 13:49 +0200, Magnus Lundin wrote:
</I>&gt;&gt;&gt;<i>       
</I>&gt;<i> [snip] 
</I>&gt;<i>   
</I>&gt;&gt;&gt;&gt;<i> Zach Welch wrote:
</I>&gt;&gt;&gt;&gt;<i>     
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;<i> [snip]
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;&gt;&gt;<i> * Are you _certain_ the current bugs being experienced cannot be the
</I>&gt;&gt;&gt;&gt;&gt;<i> result of other bugs that were uncovered by the removal of the
</I>&gt;&gt;&gt;&gt;&gt;<i> in_handler code?  If they are, &#216;yvind just did us a service.
</I>&gt;&gt;&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;&gt;&gt;<i>           
</I>&gt;&gt;&gt;&gt;<i> The bugs I have seen have all been caused by pushing unteted code into 
</I>&gt;&gt;&gt;&gt;<i> hede. Basically to quick and not careful enough. There were some ideas 
</I>&gt;&gt;&gt;&gt;<i> but this was not a carefull thought out architectural resturcturing. I 
</I>&gt;&gt;&gt;&gt;<i> hope to show that the old code is definetly a carefully planned archtecture.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The architecture he proposes will work if cleanly implementd.
</I>&gt;&gt;&gt;&gt;<i>     
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;<i> You are saying his ideas can be implemented successfully?  Okay... the
</I>&gt;&gt;&gt;<i> only problem here is that you introduced ambiguity in the pronoun 'he'.
</I>&gt;&gt;&gt;<i> I can read your reply such that it refers to either Dominic or &#216;yvind;
</I>&gt;&gt;&gt;<i> your intention is not perfectly clear from the context.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> Wrong reading, I am saying that &#214;vinds ideas, as I interpret them can be 
</I>&gt;&gt;<i> implemented and made to work.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Sorry.  Mea culpa.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> Problem is that they lack more precise substance than : We shall mkove 
</I>&gt;&gt;<i> things and it will became better, cleaner and faster.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> For the most part I agree, but I also know that sometimes the best plan
</I>&gt;<i> comes to you after you are halfway through the patch series.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> He does not state how to do it or in any detal why it will be faster, 
</I>&gt;&gt;<i> but he is given the benfit of a  doubt
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> I gave him the benefit of the doubt because he earned it by being a
</I>&gt;<i> regularly active contributer to the project.  Given the reaction, I
</I>&gt;<i> would not be as sympathetic in the future, but I have pointed out that
</I>&gt;<i> we lacked policies for branches prior to this incident.
</I>&gt;<i>
</I>&gt;<i> I think that policy will be changing after this, don't you?
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;&gt;&gt;&gt;<i> * Are you _positive_ the &quot;lost performance&quot; will not be regained by any
</I>&gt;&gt;&gt;&gt;&gt;<i> other means?  If it can, then that argument is insufficient.
</I>&gt;&gt;&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;&gt;&gt;<i>           
</I>&gt;&gt;&gt;&gt;<i> It might be regained, but in that case I am positive that we we have 
</I>&gt;&gt;&gt;&gt;<i> either built the same asych callback functionality somwhere else, or 
</I>&gt;&gt;&gt;&gt;<i> trimmed the USB layer, in which case even more performance can be gained 
</I>&gt;&gt;&gt;&gt;<i> by reverting.
</I>&gt;&gt;&gt;&gt;<i>     
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;<i> I expect the functionality to be re-implemented in a way that the
</I>&gt;&gt;&gt;<i> community will support, even if that means adding back nearly identical
</I>&gt;&gt;&gt;<i> code.  If I were in &#216;yvind's shoes, I would rather see the in_handler
</I>&gt;&gt;&gt;<i> functionality re-implemented cleanly than just put it back as it was.
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> True,
</I>&gt;&gt;<i> but nobody has argued against reimplementing cleanly, but that is not retiring functionality and changing the API.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> One reason that I did not jump in sooner was that it has always been
</I>&gt;<i> clear to me that the code in question could be cleaned up.  Removing it
</I>&gt;<i> and starting back at a stable state seems like a fine plan; replacing it
</I>&gt;<i> with a clean implementation would have been a better first step.
</I>&gt;<i>
</I>&gt;<i> Even assuming he used a branch, there is no way for any one person can
</I>&gt;<i> test architectural changes in one.  Stuff would be broken in the trunk
</I>&gt;<i> after the merge, but -- instead of watching the progress from beginning
</I>&gt;<i> to end -- users now effectively receive a single patch series that
</I>&gt;<i> absorbs all of the changes into the tree at once.  The same series of
</I>&gt;<i> problems will hit the tree, just now there are more revisions to bisect
</I>&gt;<i> and clean up.  After all, most users will not take the chance to work
</I>&gt;<i> incrementally with the branch author.
</I>&gt;<i>
</I>&gt;<i> I honestly do not know if that will be a better process or not, given
</I>&gt;<i> the number of active contributors.  It seems better to use an external
</I>&gt;<i> patch tracking or branching mechanism (e.g. quilt or git-svn) and
</I>&gt;<i> continue using patches.
</I>&gt;<i>
</I>&gt;<i> My biggest idea to fix this is simple: &quot;no one is allowed to commit
</I>&gt;<i> their own patches; every patch must go through the list, and at least
</I>&gt;<i> two active contributors must publicly ratify each one to be committed.&quot;
</I>&gt;<i> Or something like that; I'll respond to my policy thread at some point
</I>&gt;<i> with a whole lot of idea like that.
</I>&gt;<i>
</I>&gt;<i> [snip]
</I>&gt;<i>   
</I>&gt;&gt;&gt;&gt;<i> Prime example of this is indata from ARM7 scanchain 1. This data is 
</I>&gt;&gt;&gt;&gt;<i> bitswapped.  Something users that target read register funtions are not 
</I>&gt;&gt;&gt;&gt;<i> aware of. So the issuer of the  Scanchain 1 scan structure tells the 
</I>&gt;&gt;&gt;&gt;<i> jtag layer about this by adding the relevant function to the  in_handler 
</I>&gt;&gt;&gt;&gt;<i> field. When the data is received the code has long since move away form 
</I>&gt;&gt;&gt;&gt;<i> this function and we are  in the upper layer  function that simply 
</I>&gt;&gt;&gt;&gt;<i> expects a u32 value.
</I>&gt;&gt;&gt;&gt;<i>     
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;<i> Okay.  This upper layer that expects the u32...  how do the functions
</I>&gt;&gt;&gt;<i> that use this value and the functions that setup the scan to retrieve it
</I>&gt;&gt;&gt;<i> relate to each other?  Specifically, are those functions that setup
</I>&gt;&gt;&gt;<i> scans and those that use the results tightly coupled together?  
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> The upper layer users are general functions  that does things like calls 
</I>&gt;&gt;<i> to   target-&gt;type-&gt;read_memory(),
</I>&gt;&gt;<i> The scan setup comes from calling the exact architecture specific calls 
</I>&gt;&gt;<i> that can read from a certain target.
</I>&gt;&gt;<i> for ARM7TDMI the call chain is as follows
</I>&gt;&gt;<i> arm7_9_read_memory()  -&gt;  arm7_9-&gt;load_word_regs() -&gt; 
</I>&gt;&gt;<i> arm7tdmi_load_word_regs() -&gt; arm7tdmi_clock_out().
</I>&gt;&gt;<i> Here in  arm7tdmi_clock_out(). the in_handler is set to flip the bits 
</I>&gt;&gt;<i> and then a dr scan is added
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     
</I>&gt;&gt;&gt;<i> To start, I will assume they are.  If this is the case, the situation
</I>&gt;&gt;&gt;<i> with in_handler seemed to be this:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * We want a u32, so setup a scan to get it, with an in_handler to fix
</I>&gt;&gt;&gt;<i> the data when it comes in.
</I>&gt;&gt;&gt;<i> * At some point, jtag_execute_queue() will retrieve this value and call
</I>&gt;&gt;&gt;<i> the in_handler to convert it.
</I>&gt;&gt;&gt;<i> * Later yet, the function that needs that value uses it.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Likewise, the new implementation may simply look like:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> * We want a u32, so setup a scan to get it.
</I>&gt;&gt;&gt;<i> * At some point, jtag_execute_queue() will retrieve this value.
</I>&gt;&gt;&gt;<i> * Layer yet, the function that needs that value can ask to retrieve it.
</I>&gt;&gt;&gt;<i> * A helper function takes the former in_handler and lazily converts it.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> You ar right that we can do lazy conversions we have thrown away the 
</I>&gt;&gt;<i> information about which handler to use. The upper layer does not know 
</I>&gt;&gt;<i> which handler to call without doing some target specific look up of 
</I>&gt;&gt;<i> which handler to use. Basically going down the call chain to look this 
</I>&gt;&gt;<i> up again.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> It seems better to me for the JTAG layer to track the required
</I>&gt;<i> information for the caller, allowing this kind of lazy evaluation.
</I>&gt;<i> Arguably, this is very similar to the in_handler, but it eliminates the
</I>&gt;<i> function pointer and puts the responsibility in the proper layer.
</I>&gt;<i>
</I>&gt;<i> Or have I missed something?
</I>&gt;<i>
</I>&gt;<i> [snip]
</I>&gt;<i>   
</I>&gt;&gt;&gt;&gt;&gt;<i> Show me the &quot;lost work&quot; by answering the above, and I will defend you.
</I>&gt;&gt;&gt;&gt;&gt;<i> If this is not forthcoming, then it is in our interest to continue on
</I>&gt;&gt;&gt;&gt;&gt;<i> the current path, despite any further objections.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;&gt;&gt;<i>           
</I>&gt;&gt;&gt;&gt;<i> Hope this explains the background.
</I>&gt;&gt;&gt;&gt;<i>     
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;<i> It does provide more context, but I do not think that it explains why
</I>&gt;&gt;&gt;<i> the implementation cannot be improved.  The resistance to change in this
</I>&gt;&gt;&gt;<i> community worries me.  The code is not in _any_ shape to be &quot;preserved&quot;
</I>&gt;&gt;&gt;<i> in its current state (unless we are talking about archiving backups).
</I>&gt;&gt;&gt;<i> OpenOCD needs to grow and evolve or it will not survive.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> If change is painful, then evolution is an outright killer.  
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> C'est la vie,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Zach
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> I am tired of hearing this argument about resisting change. It is simply 
</I>&gt;&gt;<i> not true. I hear arguments about improving architecture, great but then 
</I>&gt;&gt;<i> there should be an new architectural plan at least for the affected 
</I>&gt;&gt;<i> parts. But changes done without understanding the code is not 
</I>&gt;&gt;<i> evolution.  Big experiments should be done as experiments and then 
</I>&gt;&gt;<i> evaluated.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> I am just as tired of having to argue for change, but I have been
</I>&gt;<i> convinced that my argument here was flawed.  You are correct in saying
</I>&gt;<i> that the size of these changes deserved a branch, but this admission
</I>&gt;<i> stems directly from hindsight.
</I>&gt;<i>
</I>&gt;<i> Breaking the trunk only causes problems because _everyone_ is using it
</I>&gt;<i> instead of regular releases.  That is the maintainers fault to be sure;
</I>&gt;<i> this would not be a huge problem if everyone had their attention focused
</I>&gt;<i> on a release branch.  This does not excuse rampant experimentation.
</I>&gt;<i>
</I>&gt;<i> In theory, the trunk _is_ an experimental branch to some extent.  This
</I>&gt;<i> community's reliance on it helped show that &#216;yvind surpassed the de
</I>&gt;<i> facto limit to the community's tolerance for mainline breakage.
</I>&gt;<i> Arguably, this is not his problem alone.  The community must shoulder
</I>&gt;<i> part of the blame for failing to make regular branches of the trunk for
</I>&gt;<i> the explicit purpose of maintaining stability... and for failing to
</I>&gt;<i> provide failsafe processes for handling experimental patches.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In this respect, I am starting to worry about the patches that I have
</I>&gt;<i> pending... are they too invasive?  Should I post them first?  If I have
</I>&gt;<i> to post every patch for others to consider, then why do I have commit
</I>&gt;<i> access to the repository (well, for my proposed rule above, to start).
</I>&gt;<i> Clear lines must be drawn, but these did not exist in any form.  
</I>&gt;<i>
</I>&gt;<i> I know there are no policies because I asked _explicitly_ to see the
</I>&gt;<i> rules before agreeing to become a maintainer, initially declining while
</I>&gt;<i> waiting to see them.  Despite my caution, I was assured that things were
</I>&gt;<i> kosher without written policies, but my instincts turned out correctly.
</I>&gt;<i> I mean, it could just as well have been me making a large commit that
</I>&gt;<i> angered the spirits down below.
</I>&gt;<i>
</I>&gt;<i> I tell ya':  I would be on my way out the door if I had gotten the net
</I>&gt;<i> response that &#216;yvind received today, after only three weeks on the job
</I>&gt;<i> and given my initial reservations.  During this all, I think he has
</I>&gt;<i> acted very professionally.  I can see why Dick and Jeff left, and I am
</I>&gt;<i> feeling bad about the part that I played in it.  Contributing to a
</I>&gt;<i> project without meaningful processes is too much like gambling.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> At this point, I think we should treat it as water under the bridge and
</I>&gt;<i> move forward to ensure this kind of problem does not happen again.
</I>&gt;<i> A comedy of errors that will result in improved processes and a happy
</I>&gt;<i> ending for everyone.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Cheers,
</I>&gt;<i>
</I>&gt;<i> Zach
</I>&gt;<i>
</I>&gt;<i>   
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006299.html">[Openocd-development] The &quot;in_handler&quot; Incident
</A></li>
	<LI>Next message: <A HREF="006311.html">[Openocd-development] The &quot;in_handler&quot; Incident
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6302">[ date ]</a>
              <a href="thread.html#6302">[ thread ]</a>
              <a href="subject.html#6302">[ subject ]</a>
              <a href="author.html#6302">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-development">More information about the Openocd-development
mailing list</a><br>
</body></html>
