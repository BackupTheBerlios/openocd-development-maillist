<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-development] The &quot;in_handler&quot; Incident
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-development/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20The%20%22in_handler%22%20Incident&In-Reply-To=%3C4A044A53.2080206%40mlu.mine.nu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006276.html">
   <LINK REL="Next"  HREF="006275.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-development] The &quot;in_handler&quot; Incident</H1>
    <B>Magnus Lundin</B> 
    <A HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20The%20%22in_handler%22%20Incident&In-Reply-To=%3C4A044A53.2080206%40mlu.mine.nu%3E"
       TITLE="[Openocd-development] The &quot;in_handler&quot; Incident">lundin at mlu.mine.nu
       </A><BR>
    <I>Fri May  8 17:05:55 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="006276.html">[Openocd-development] The &quot;in_handler&quot; Incident
</A></li>
        <LI>Next message: <A HREF="006275.html">[Openocd-development] The &quot;in_handler&quot; Incident
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6273">[ date ]</a>
              <a href="thread.html#6273">[ thread ]</a>
              <a href="subject.html#6273">[ subject ]</a>
              <a href="author.html#6273">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Zach Welch wrote:
&gt;<i> On Fri, 2009-05-08 at 13:49 +0200, Magnus Lundin wrote:
</I>&gt;<i>   
</I>&gt;&gt;<i> I'll give it a go, and I do think I understand what is going on under 
</I>&gt;&gt;<i> the hood in some detail.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Thank you for providing your explanations.  This has been the most
</I>&gt;<i> constructive attempt to address the technical issues, and I appreciate
</I>&gt;<i> your focusing on it from this perspective.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> Also there are a lot of cleanup to be done.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> And the documentation about some finer technical points is somewhere 
</I>&gt;&gt;<i> between bad, nonexsistant or can be found in Dominics thesis paper.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Which was last updated when?  I will make it a priority to grok this
</I>&gt;<i> document and regurgitate anything useful that I find to the list, but I
</I>&gt;<i> just want to point out that the lack of up-to-date backing documentation
</I>&gt;<i> raises questions about the objectivity of anyone's current opinions.
</I>&gt;<i> I believe internals should be fair game for being rewritten at any time.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> Zach Welch wrote:
</I>&gt;&gt;<i>     
</I>&gt;<i> [snip]
</I>&gt;<i>   
</I>&gt;&gt;&gt;<i> * Are you _certain_ the current bugs being experienced cannot be the
</I>&gt;&gt;&gt;<i> result of other bugs that were uncovered by the removal of the
</I>&gt;&gt;&gt;<i> in_handler code?  If they are, &#216;yvind just did us a service.
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> The bugs I have seen have all been caused by pushing unteted code into 
</I>&gt;&gt;<i> hede. Basically to quick and not careful enough. There were some ideas 
</I>&gt;&gt;<i> but this was not a carefull thought out architectural resturcturing. I 
</I>&gt;&gt;<i> hope to show that the old code is definetly a carefully planned archtecture.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The architecture he proposes will work if cleanly implementd.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> You are saying his ideas can be implemented successfully?  Okay... the
</I>&gt;<i> only problem here is that you introduced ambiguity in the pronoun 'he'.
</I>&gt;<i> I can read your reply such that it refers to either Dominic or &#216;yvind;
</I>&gt;<i> your intention is not perfectly clear from the context.
</I>&gt;<i>
</I>&gt;<i>   
</I>Wrong reading, I am saying that &#214;vinds ideas, as I interpret them can be 
implemented and made to work.
Problem is that they lack more precise substance than : We shall mkove 
things and it will became better, cleaner and faster.
He does not state how to do it or in any detal why it will be faster, 
but he is given the benfit of a  doubt
&gt;&gt;&gt;<i> * Are you _positive_ the &quot;lost performance&quot; will not be regained by any
</I>&gt;&gt;&gt;<i> other means?  If it can, then that argument is insufficient.
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> It might be regained, but in that case I am positive that we we have 
</I>&gt;&gt;<i> either built the same asych callback functionality somwhere else, or 
</I>&gt;&gt;<i> trimmed the USB layer, in which case even more performance can be gained 
</I>&gt;&gt;<i> by reverting.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> I expect the functionality to be re-implemented in a way that the
</I>&gt;<i> community will support, even if that means adding back nearly identical
</I>&gt;<i> code.  If I were in &#216;yvind's shoes, I would rather see the in_handler
</I>&gt;<i> functionality re-implemented cleanly than just put it back as it was.
</I>&gt;<i>   
</I>True,
but nobody has argued against reimplementing cleanly, but that is not retiring functionality and changing the API.

&gt;&gt;&gt;<i> * How _exactly_ does the in_handler callback fit into it?  Again, this
</I>&gt;&gt;&gt;<i> needs to be explained in fairly complete technical detail.  Or maybe
</I>&gt;&gt;&gt;<i> someone can link to the on-line documentation....
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> Actually we are talking about two different functionalities here.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - The handling of asychronous reads from the jtag,  and the extra data 
</I>&gt;&gt;<i> treansformation done by the in_handler funtions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> In order to issue  several read requests  where the result should be 
</I>&gt;&gt;<i> stored in  different locations and avoid doing a full roundtrip for each 
</I>&gt;&gt;<i> call, the address of the receiving location is stored in the in_variable 
</I>&gt;&gt;<i> field when issuing a scan request to the jtag layer. When a 
</I>&gt;&gt;<i> jtag_execute_que() is completed the all oustanding such queued reads are 
</I>&gt;&gt;<i> completed.
</I>&gt;&gt;<i> So the calling sequence is
</I>&gt;&gt;<i> - issue as many in scans as possible,
</I>&gt;&gt;<i> - when we need the return walue,  call jtag_execute_queue(), if this 
</I>&gt;&gt;<i> succeds we are guaranteed that the values are in place.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> I follow you so far.  We want to decouple reads of results from the
</I>&gt;<i> writes, so both can happen asynchronously.  jtag_execute_queue() is a
</I>&gt;<i> sync point that ensures all queued write/read pairs have completed.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> This introduces the potential of receiving value going out of scope, 
</I>&gt;&gt;<i> this happens if we ask for a value to be stored in a local variable and 
</I>&gt;&gt;<i> exit before calling jtag_execute_scan, which is a type of an &quot;unused 
</I>&gt;&gt;<i> variable assignment&quot;
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> I am okay up until &quot;, which is...&quot;.  The last phrase is confusing.
</I>&gt;<i>
</I>&gt;<i>   
</I>If you ask the jtag layer for a variable, it should be be used before 
going out of scope, otherwise it is  a type of unused varable assignment 
problem.
&gt;&gt;<i> The natural place for  this functionality is  in the jtag layer.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> This is not entire clear just yet, but I will assume this for now since
</I>&gt;<i> you seem to be mostly on-track so far.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> The in_handler functionality tells the jtag layer to apply an in_handler 
</I>&gt;&gt;<i> supplied with the inscan command  to the received  value before storing 
</I>&gt;&gt;<i> it in the receiving location. This transformation is something that must 
</I>&gt;&gt;<i> be done somewhere to adaptet the received jtag data to the data format 
</I>&gt;&gt;<i> of the receiving variable. So some part of the code must handle this 
</I>&gt;&gt;<i> transformation. And it must be done after receiving the jtag in data and 
</I>&gt;&gt;<i> before the result is used. Possible choises are jtag or  target variant 
</I>&gt;&gt;<i> specific code.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Right: in_handler is/was a scan-specific &quot;value fix-up&quot; callback.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> Prime example of this is indata from ARM7 scanchain 1. This data is 
</I>&gt;&gt;<i> bitswapped.  Something users that target read register funtions are not 
</I>&gt;&gt;<i> aware of. So the issuer of the  Scanchain 1 scan structure tells the 
</I>&gt;&gt;<i> jtag layer about this by adding the relevant function to the  in_handler 
</I>&gt;&gt;<i> field. When the data is received the code has long since move away form 
</I>&gt;&gt;<i> this function and we are  in the upper layer  function that simply 
</I>&gt;&gt;<i> expects a u32 value.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Okay.  This upper layer that expects the u32...  how do the functions
</I>&gt;<i> that use this value and the functions that setup the scan to retrieve it
</I>&gt;<i> relate to each other?  Specifically, are those functions that setup
</I>&gt;<i> scans and those that use the results tightly coupled together?  
</I>&gt;<i>   
</I>The upper layer users are general functions  that does things like calls 
to   target-&gt;type-&gt;read_memory(),
The scan setup comes from calling the exact architecture specific calls 
that can read from a certain target.
for ARM7TDMI the call chain is as follows
arm7_9_read_memory()  -&gt;  arm7_9-&gt;load_word_regs() -&gt; 
arm7tdmi_load_word_regs() -&gt; arm7tdmi_clock_out().
Here in  arm7tdmi_clock_out(). the in_handler is set to flip the bits 
and then a dr scan is added

&gt;<i> To start, I will assume they are.  If this is the case, the situation
</I>&gt;<i> with in_handler seemed to be this:
</I>&gt;<i>
</I>&gt;<i> * We want a u32, so setup a scan to get it, with an in_handler to fix
</I>&gt;<i> the data when it comes in.
</I>&gt;<i> * At some point, jtag_execute_queue() will retrieve this value and call
</I>&gt;<i> the in_handler to convert it.
</I>&gt;<i> * Later yet, the function that needs that value uses it.
</I>&gt;<i>
</I>&gt;<i> Likewise, the new implementation may simply look like:
</I>&gt;<i>
</I>&gt;<i> * We want a u32, so setup a scan to get it.
</I>&gt;<i> * At some point, jtag_execute_queue() will retrieve this value.
</I>&gt;<i> * Layer yet, the function that needs that value can ask to retrieve it.
</I>&gt;<i> * A helper function takes the former in_handler and lazily converts it.
</I>&gt;<i>
</I>&gt;<i>   
</I>You ar right that we can do lazy conversions we have thrown away the 
information about which handler to use. The upper layer does not know 
which handler to call without doing some target specific look up of 
which handler to use. Basically going down the call chain to look this 
up again.

&gt;<i> Now, one might assume the opposite: that the scan setup/usage functions
</I>&gt;<i> are not as tightly coupled.  If that is the case, then your very example
</I>&gt;<i> seems to be a layering violation: you want target-specific fix-ups to be
</I>&gt;<i> processed by the jtag layer?  
</I>&gt;<i>
</I>&gt;<i> Am I thoroughly confused here, or is this a correct interpretation of
</I>&gt;<i> the situation?
</I>&gt;<i>
</I>&gt;<i>   
</I>Since target debug unit uses diffent  mappings between  scanchain  bits 
and  the memory data  we are trying to read it is tightly coupled.
&gt;&gt;&gt;<i> * Where are the patches to finish implementing this work?  My impression
</I>&gt;&gt;&gt;<i> has been that this feature is mostly &quot;for future use&quot;, and that is not a
</I>&gt;&gt;&gt;<i> sufficient reason to keep it -- unless it is being actively worked on.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> The stuff above is finished, it has been used for a long time, cleanup 
</I>&gt;&gt;<i> and polishing is always good but this is a core functionlity that is 
</I>&gt;&gt;<i> working.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Right.  I do agree that future changes of this magnitude should be
</I>&gt;<i> completed in advance of being committed to the head of the trunk.
</I>&gt;<i> I think r1607 should have been floated for at least 24 hours before
</I>&gt;<i> further work was done, and &#216;yvind might have been wise to stop until the
</I>&gt;<i> community was satisfied with the path forward.
</I>&gt;<i>
</I>&gt;<i> I apologize to everyone that finds this difficult, but breakage _should_
</I>&gt;<i> occasionally happen in the trunk or we are being too conservative in our
</I>&gt;<i> development practices.  [[Not this much breakage though!]]  Still, it
</I>&gt;<i> helps to have clear plans in the public view for a decent amount of time
</I>&gt;<i> for consideration, then one can just say &quot;I tried to warn you&quot;.
</I>&gt;<i>
</I>&gt;<i> I have a series of big patches pending, but they should not break
</I>&gt;<i> anything for anyone.  Even in my completely non-functional changes,
</I>&gt;<i> there will be room for controversy though, so stay tuned. :)
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;&gt;<i> Show me the &quot;lost work&quot; by answering the above, and I will defend you.
</I>&gt;&gt;&gt;<i> If this is not forthcoming, then it is in our interest to continue on
</I>&gt;&gt;&gt;<i> the current path, despite any further objections.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;<i> Hope this explains the background.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> It does provide more context, but I do not think that it explains why
</I>&gt;<i> the implementation cannot be improved.  The resistance to change in this
</I>&gt;<i> community worries me.  The code is not in _any_ shape to be &quot;preserved&quot;
</I>&gt;<i> in its current state (unless we are talking about archiving backups).
</I>&gt;<i> OpenOCD needs to grow and evolve or it will not survive.
</I>&gt;<i>
</I>&gt;<i> If change is painful, then evolution is an outright killer.  
</I>&gt;<i>
</I>&gt;<i> C'est la vie,
</I>&gt;<i>
</I>&gt;<i> Zach
</I>&gt;<i>
</I>&gt;<i>   
</I>I am tired of hearing this argument about resisting change. It is simply 
not true. I hear arguments about improving architecture, great but then 
there should be an new architectural plan at least for the affected 
parts. But changes done without understanding the code is not 
evolution.  Big experiments should be done as experiments and then 
evaluated.

Regards
Magnus


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006276.html">[Openocd-development] The &quot;in_handler&quot; Incident
</A></li>
	<LI>Next message: <A HREF="006275.html">[Openocd-development] The &quot;in_handler&quot; Incident
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6273">[ date ]</a>
              <a href="thread.html#6273">[ thread ]</a>
              <a href="subject.html#6273">[ subject ]</a>
              <a href="author.html#6273">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-development">More information about the Openocd-development
mailing list</a><br>
</body></html>
