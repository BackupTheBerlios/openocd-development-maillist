<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-development] Outsider's point of view
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-development/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20Outsider%27s%20point%20of%20view&In-Reply-To=%3C200905122138.08391.david-b%40pacbell.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006451.html">
   <LINK REL="Next"  HREF="006453.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-development] Outsider's point of view</H1>
    <B>David Brownell</B> 
    <A HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20Outsider%27s%20point%20of%20view&In-Reply-To=%3C200905122138.08391.david-b%40pacbell.net%3E"
       TITLE="[Openocd-development] Outsider's point of view">david-b at pacbell.net
       </A><BR>
    <I>Wed May 13 06:38:08 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="006451.html">[Openocd-development] Outsider's point of view
</A></li>
        <LI>Next message: <A HREF="006453.html">[Openocd-development] Outsider's point of view
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6452">[ date ]</a>
              <a href="thread.html#6452">[ thread ]</a>
              <a href="subject.html#6452">[ subject ]</a>
              <a href="author.html#6452">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> &gt; Right.  I think some patches should certainly be able
</I>&gt;<i> &gt; to fit into the &quot;keep that in the -next queue&quot; category.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Effective review is probably not easy here; who knows
</I>&gt;<i> &gt; JTAG well enough to contribute non-cosmetic feedback?
</I>&gt;<i> 
</I>&gt;<i> Actually, a fair number of us _do_ know JTAG fairly well.
</I>
That's good ... I guess I was thinking more about the
difficulties in expanding that set.  (The code could
not have gotten to its current state without at least
a core of folk with the relevant skills!)


&gt;<i> The target protocols are another matter.
</I>
Right; needs hardware, testers, &quot;users&quot;, etc.


&gt;<i> &gt; One process that could hardly help but improve things
</I>&gt;<i> &gt; is to define a &quot;release manager&quot; who herds patches for
</I>&gt;<i> &gt; a given release ... and someone else who herds patches
</I>&gt;<i> &gt; for the next one, keeping the queues in sync.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; OpenOCD doesn't seem to have anyone responsible for
</I>&gt;<i> &gt; the &quot;next&quot; release, whatever it's called (maybe a
</I>&gt;<i> &gt; datecode like &quot;2009-06&quot;?).  Such roles should ideally
</I>&gt;<i> &gt; be rotated.  Some projects have teams defining them.
</I>&gt;<i> &gt;
</I>&gt;<i> 
</I>&gt;<i> Technically, I took that role for the 0.1.0 release.  There were two  
</I>&gt;<i> factors that have make continuing as such for 0.2.0 challenging: my  
</I>&gt;<i> home life and lack of community support.  My home life is in a bit of  
</I>&gt;<i> turmoil due to a home remodel, new baby, and looking for a new day  
</I>&gt;<i> job.  The community support was nearly non-existent.
</I>
Getting a release out is rarely a picnic even
in the best of cases!


And it seems like you really needed help that you
weren't getting (but should have had):

&gt;<i> Even slowing   
</I>&gt;<i> things down for 0.1.0 was difficult but I managed.  As soon as 0.1.0  
</I>&gt;<i> was released, trunk had already progressed well ahead and was in  
</I>&gt;<i> chaos.  Attempting to slow things down and establish which in-progress  
</I>&gt;<i> developments need to be finished has been met with resistance.  As  
</I>&gt;<i> soon as one in-progress item is finished, 3 others have been partially  
</I>&gt;<i> introduced.  _If_ a process was put in place for accepting patches to  
</I>&gt;<i> trunk, the job of release management _might_ be possible.
</I>
Likewise, for deferring some patches until the next release.

This is one of the things that Linux does interestingly.
Except for a brief &quot;merge window&quot; and things like new code
that can't break anything (new drivers etc), the &quot;trunk&quot; is
managed *always* as a release stage.  Everything else gets
batched up to merge later, in that merge window.

It took time to get that process working well, but at this
point there are a LOT of developers who are used to it.


&gt;<i> Otherwise,   
</I>&gt;<i> it primarily means picking an arbitrary revision of trunk and making  
</I>&gt;<i> it the branch.  Then, as in-progress items are finished, merge the  
</I>&gt;<i> patches from trunk into the branch.  It sucks and makes the release  
</I>&gt;<i> manager do _a lot_ of work.  It's not an easy job watching every  
</I>&gt;<i> commit and determining if it should be taken for the release or not.   
</I>&gt;<i> It's also not easy backporting fixes that don't apply cleanly because  
</I>&gt;<i> trunk has moved on with other widespread changes.
</I>
Hrrm, yes.  Those all seem like *very* significant problems.
It should not have been your job, actually ... folk should
have said &quot;this needs to get into &lt;next release&gt;&quot; when the
patches were submitted, and if it did need tweaks the work
should have been done by the patch submitter.


&gt;<i> Enough ranting from me.  We need to set some criteria for introducing  
</I>&gt;<i> patches into trunk and formalize the process.  We also need to  
</I>&gt;<i> establish the same for release branches.  Then, everyone with commit  
</I>&gt;<i> access needs to respect those processes.  If we all play by the same  
</I>&gt;<i> rules, cutting releases more frequently will be easy and the overall  
</I>&gt;<i> quality of trunk will be better.
</I>
Given what I've seen work on other projects, I'd agree.
 

&gt;<i> &gt; Regular status updates help too.  Linux has clear
</I>&gt;<i> &gt; progress markers via version codes (2.6.29, then
</I>&gt;<i> &gt; merge window, then 2.6.30-rc1, etc) *and* at least
</I>&gt;<i> &gt; brief status reports every weeks when a new version
</I>&gt;<i> &gt; is tagged. GCC has different status reports (which
</I>&gt;<i> &gt; get rotated among release team members) and very
</I>&gt;<i> &gt; clear tree status.  OOCD has nothing similar.
</I>&gt;<i> &gt;
</I>&gt;<i> 
</I>&gt;<i> Right.  This follows from the above.  If you have a process, it is  
</I>&gt;<i> easy to send out updates about what stage we are in.  The releases  
</I>&gt;<i> don't need to be on a strict timeline, but knowing that this release  
</I>&gt;<i> is slowing down and another will be opening helps patch authors set  
</I>&gt;<i> their schedules and use their time effectively.
</I>
Status is both output of, and feedback into, the
process.  Without status, you don't really have a
process ... once you start tracking and measuring
things (against goals), that is itself a process.
Chicken/egg.


&gt;<i> &gt; If they were merged, I would have argued against &quot;opt-in&quot;.
</I>&gt;<i> &gt; When a patch is basically good, any remaining bugs should
</I>&gt;<i> &gt; just get fixed.  If it isn't, it shouldn't merge.
</I>&gt;<i> &gt;
</I>&gt;<i> 
</I>&gt;<i> Actually, in this case, opt-in was the right model.  In general I  
</I>&gt;<i> agree with you, but when you are changing such a fundamental part of  
</I>&gt;<i> the code, it will take time for the other pieces to be tested and  
</I>&gt;<i> debugged.
</I>
So opt-in was just a testing aid?  That's better.  I'd
still have set the build option the other way ... so the
testing was maximized.  Maybe not for a week or two, but
certainly not very long after merge.


&gt;<i> &gt; Right.  The guts of it boil down, IMO, to defining some
</I>&gt;<i> &gt; responsible roles ... and having people meet those roles.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Given that, some tools work better than others.  GIT makes
</I>&gt;<i> &gt; it easy to have any number of branches without needing to
</I>&gt;<i> &gt; grant excess permissions to anyone, for example.  But we
</I>&gt;<i> &gt; have all probably seen projects managed effectively using
</I>&gt;<i> &gt; tools like CVS or SVN.  The tools are secondary to having
</I>&gt;<i> &gt; a process which uses them well.
</I>&gt;<i> 
</I>&gt;<i> I'm not entirely sold on GIT as a project source control system, but  
</I>&gt;<i> things like git-svn enable individuals to maintain their own GIT  
</I>&gt;<i> branches and push them to the project as a patch.  That provides a  
</I>&gt;<i> reasonable balance between the needs of the project and the needs of  
</I>&gt;<i> the contributors.
</I>
I'm using git-svn now, FWIW, and quilt on top.  It's good having
the entire project history accessible without needing server access;
and patch bisection &quot;just works&quot;.

- Dave

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006451.html">[Openocd-development] Outsider's point of view
</A></li>
	<LI>Next message: <A HREF="006453.html">[Openocd-development] Outsider's point of view
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6452">[ date ]</a>
              <a href="thread.html#6452">[ thread ]</a>
              <a href="subject.html#6452">[ subject ]</a>
              <a href="author.html#6452">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-development">More information about the Openocd-development
mailing list</a><br>
</body></html>
