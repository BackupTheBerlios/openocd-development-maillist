<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-development] [PATCH 4/4] - add dsp563xx support
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-development/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20%5BPATCH%204/4%5D%20-%20add%20dsp563xx%20support&In-Reply-To=%3C4B1A674B.6020207%40freenet.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013383.html">
   <LINK REL="Next"  HREF="013384.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-development] [PATCH 4/4] - add dsp563xx support</H1>
    <B>Mathias K.</B> 
    <A HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20%5BPATCH%204/4%5D%20-%20add%20dsp563xx%20support&In-Reply-To=%3C4B1A674B.6020207%40freenet.de%3E"
       TITLE="[Openocd-development] [PATCH 4/4] - add dsp563xx support">kesmtp at freenet.de
       </A><BR>
    <I>Sat Dec  5 14:59:39 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="013383.html">[Openocd-development] [PATCH 3/4] - add dsp563xx support
</A></li>
        <LI>Next message: <A HREF="013384.html">[Openocd-development] [PATCH 4/4] - add dsp563xx support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13380">[ date ]</a>
              <a href="thread.html#13380">[ thread ]</a>
              <a href="subject.html#13380">[ subject ]</a>
              <a href="author.html#13380">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This patch adds Freescale DSP563xx and DSP563xx-ONCE (one chip emulation) support.

---
 src/target/dsp563xx.c      |  875 ++++++++++++++++++++++++++++++++++++++++++++
 src/target/dsp563xx.h      |   73 ++++
 src/target/dsp563xx_once.c |  116 ++++++
 src/target/dsp563xx_once.h |   71 ++++
 4 files changed, 1135 insertions(+), 0 deletions(-)
 create mode 100644 src/target/dsp563xx.c
 create mode 100644 src/target/dsp563xx.h
 create mode 100644 src/target/dsp563xx_once.c
 create mode 100644 src/target/dsp563xx_once.h

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
new file mode 100644
index 0000000..e75137c
--- /dev/null
+++ b/src/target/dsp563xx.c
@@ -0,0 +1,875 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">mkdorg at users.sourceforge.net</A>                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;target.h&quot;
+#include &quot;target_type.h&quot;
+#include &quot;register.h&quot;
+#include &quot;dsp563xx.h&quot;
+#include &quot;dsp563xx_once.h&quot;
+
+#define DSP563XX_JTAG_INS_LEN	4
+
+#define JTAG_STATUS_NORMAL	0x01
+#define JTAG_STATUS_STOPWAIT	0x05
+#define JTAG_STATUS_BUSY	0x09
+#define JTAG_STATUS_DEBUG	0x0d
+
+#define JTAG_INSTR_EXTEST		0x00
+#define JTAG_INSTR_SAMPLE_PRELOAD	0x01
+#define JTAG_INSTR_IDCODE		0x02
+#define JTAG_INSTR_CLAMP		0x03
+#define JTAG_INSTR_HIZ			0x04
+#define JTAG_INSTR_ENABLE_ONCE		0x06
+#define JTAG_INSTR_DEBUG_REQUEST	0x07
+#define JTAG_INSTR_BYPASS		0x0F
+
+/* forward declarations */
+int dsp563xx_target_create(struct target *target, Jim_Interp *interp);
+int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target);
+
+int dsp563xx_arch_state(struct target *target);
+int dsp563xx_poll(struct target *target);
+int dsp563xx_halt(struct target *target);
+int dsp563xx_resume(struct target *target, int current, uint32_t address, int handle_breakpoints,
int debug_execution);
+int dsp563xx_step(struct target *target, int current, uint32_t address, int handle_breakpoints);
+
+int dsp563xx_assert_reset(struct target *target);
+int dsp563xx_deassert_reset(struct target *target);
+int dsp563xx_soft_reset_halt(struct target *target);
+
+/* IR and DR functions */
+int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out);
+int dsp563xx_jtag_senddat(struct jtag_tap *tap, uint32_t *dr_in, uint32_t dr_out, int len);
+
+int dsp563xx_read_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count,
uint8_t *buffer);
+int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count,
uint8_t *buffer);
+
+char* dsp563xx_core_reg_list[] =
+{
+	&quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r4&quot;, &quot;r5&quot;, &quot;r6&quot;, &quot;r7&quot;,&quot;ep&quot;,
+	&quot;n0&quot;, &quot;n1&quot;, &quot;n2&quot;, &quot;n3&quot;, &quot;n4&quot;, &quot;n5&quot;, &quot;n6&quot;, &quot;n7&quot;,
+	&quot;m0&quot;, &quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;, &quot;m4&quot;, &quot;m5&quot;, &quot;m6&quot;, &quot;m7&quot;,
+	&quot;x0&quot;, &quot;x1&quot;, &quot;y0&quot;, &quot;y1&quot;,
+	&quot;a0&quot;, &quot;a1&quot;, &quot;a2&quot;,
+	&quot;b0&quot;, &quot;b1&quot;, &quot;b2&quot;,
+	&quot;sr&quot;, &quot;lc&quot;, &quot;la&quot;, &quot;ssh&quot;, &quot;ssl&quot;, &quot;omr&quot;, &quot;pc&quot;
+};
+
+#define ASM_REG_R_R0	0x607000
+#define ASM_REG_R_R1	0x617000
+#define ASM_REG_R_R2	0x627000
+#define ASM_REG_R_R3	0x637000
+#define ASM_REG_R_R4	0x647000
+#define ASM_REG_R_R5	0x657000
+#define ASM_REG_R_R6	0x667000
+#define ASM_REG_R_R7	0x677000
+#define ASM_REG_R_EP	0x05702A
+
+#define ASM_REG_R_N0	0x707000
+#define ASM_REG_R_N1	0x717000
+#define ASM_REG_R_N2	0x727000
+#define ASM_REG_R_N3	0x737000
+#define ASM_REG_R_N4	0x747000
+#define ASM_REG_R_N5	0x757000
+#define ASM_REG_R_N6	0x767000
+#define ASM_REG_R_N7	0x777000
+
+#define ASM_REG_R_M0	0x057020
+#define ASM_REG_R_M1	0x057021
+#define ASM_REG_R_M2	0x057022
+#define ASM_REG_R_M3	0x057023
+#define ASM_REG_R_M4	0x057024
+#define ASM_REG_R_M5	0x057025
+#define ASM_REG_R_M6	0x057026
+#define ASM_REG_R_M7	0x057027
+
+#define ASM_REG_R_X0	0x447000
+#define ASM_REG_R_X1	0x457000
+#define ASM_REG_R_Y0	0x467000
+#define ASM_REG_R_Y1	0x477000
+
+#define ASM_REG_R_A0	0x507000
+#define ASM_REG_R_A1	0x547000
+#define ASM_REG_R_A2	0x527000
+
+#define ASM_REG_R_B0	0x517000
+#define ASM_REG_R_B1	0x557000
+#define ASM_REG_R_B2	0x537000
+
+#define ASM_REG_R_SR	0x0450B9
+#define ASM_REG_R_LC	0x0446BF
+#define ASM_REG_R_LA	0x0446BE
+#define ASM_REG_R_SSH	0x0446BC
+#define ASM_REG_R_SSL	0x0446BD
+#define ASM_REG_R_OMR	0x0446BA
+#define ASM_REG_R_PC	0x000000
+
+struct dsp563xx_core_reg dsp563xx_core_reg_list_arch_info[DSP563XX_NUMCOREREGS] =
+{
+	{0, 24, ASM_REG_R_R0, NULL, NULL},
+	{1, 24, ASM_REG_R_R1, NULL, NULL},
+	{2, 24, ASM_REG_R_R2, NULL, NULL},
+	{3, 24, ASM_REG_R_R3, NULL, NULL},
+	{4, 24, ASM_REG_R_R4, NULL, NULL},
+	{5, 24, ASM_REG_R_R5, NULL, NULL},
+	{6, 24, ASM_REG_R_R6, NULL, NULL},
+	{7, 24, ASM_REG_R_R7, NULL, NULL},
+	{8, 24, ASM_REG_R_EP, NULL, NULL},
+	
+	{9, 24, ASM_REG_R_N0, NULL, NULL},
+	{10, 24, ASM_REG_R_N1, NULL, NULL},
+	{11, 24, ASM_REG_R_N2, NULL, NULL},
+	{12, 24, ASM_REG_R_N3, NULL, NULL},
+	{13, 24, ASM_REG_R_N4, NULL, NULL},
+	{14, 24, ASM_REG_R_N5, NULL, NULL},
+	{15, 24, ASM_REG_R_N6, NULL, NULL},
+	{16, 24, ASM_REG_R_N7, NULL, NULL},
+	
+	{17, 24, ASM_REG_R_M0, NULL, NULL},
+	{18, 24, ASM_REG_R_M1, NULL, NULL},
+	{19, 24, ASM_REG_R_M2, NULL, NULL},
+	{20, 24, ASM_REG_R_M3, NULL, NULL},
+	{21, 24, ASM_REG_R_M4, NULL, NULL},
+	{22, 24, ASM_REG_R_M5, NULL, NULL},
+	{23, 24, ASM_REG_R_M6, NULL, NULL},
+	{24, 24, ASM_REG_R_M7, NULL, NULL},
+	
+	{25, 24, ASM_REG_R_X0, NULL, NULL},
+	{26, 24, ASM_REG_R_X1, NULL, NULL},
+	{27, 24, ASM_REG_R_Y0, NULL, NULL},
+	{28, 24, ASM_REG_R_Y1, NULL, NULL},
+	
+	{29, 24, ASM_REG_R_A0, NULL, NULL},
+	{30, 24, ASM_REG_R_A1, NULL, NULL},
+	{31, 8, ASM_REG_R_A2, NULL, NULL},
+	
+	{32, 24, ASM_REG_R_B0, NULL, NULL},
+	{33, 24, ASM_REG_R_B1, NULL, NULL},
+	{34, 8, ASM_REG_R_B2, NULL, NULL},
+	
+	{35, 24, ASM_REG_R_SR, NULL, NULL},
+	{36, 24, ASM_REG_R_LC, NULL, NULL},
+	{37, 24, ASM_REG_R_LA, NULL, NULL},
+	{38, 24, ASM_REG_R_SSH, NULL, NULL},
+	{39, 24, ASM_REG_R_SSL, NULL, NULL},
+	{40, 24, ASM_REG_R_OMR, NULL, NULL},
+	{41, 24, ASM_REG_R_PC, NULL, NULL}
+};
+
+struct target_type dsp563xx_target =
+{
+	.name = &quot;dsp56&quot;,
+
+	.poll = dsp563xx_poll,
+	.arch_state = dsp563xx_arch_state,
+
+	.target_request_data = NULL,
+
+	.halt = dsp563xx_halt,
+	.resume = dsp563xx_resume,
+	.step = dsp563xx_step,
+
+	.assert_reset = dsp563xx_assert_reset,
+	.deassert_reset = dsp563xx_deassert_reset,
+	.soft_reset_halt = dsp563xx_soft_reset_halt,
+	
+	.read_memory = dsp563xx_read_memory_p,
+	.write_memory = dsp563xx_write_memory_p,
+	
+/*
+	.get_gdb_reg_list = dsp563xx_get_gdb_reg_list,
+
+	.write_memory = dsp563xx_write_memory,
+	.bulk_write_memory = dsp563xx_bulk_write_memory,
+	.checksum_memory = dsp563xx_checksum_memory,
+	.blank_check_memory = dsp563xx_blank_check_memory,
+
+	.run_algorithm = dsp563xx_run_algorithm,
+
+	.add_breakpoint = dsp563xx_add_breakpoint,
+	.remove_breakpoint = dsp563xx_remove_breakpoint,
+	.add_watchpoint = dsp563xx_add_watchpoint,
+	.remove_watchpoint = dsp563xx_remove_watchpoint,
+*/
+	.target_create = dsp563xx_target_create,
+	.init_target = dsp563xx_init_target,
+};
+
+int dsp563xx_read_core_reg(struct target *target, int num)
+{
+	uint32_t reg_value;
+	struct dsp563xx_core_reg *dsp563xx_core_reg;
+	
+	/* get pointers to arch-specific information */
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	if ((num &lt; 0) || (num &gt;= DSP563XX_NUMCOREREGS))
+		return ERROR_INVALID_ARGUMENTS;
+	
+	dsp563xx_core_reg = dsp563xx-&gt;core_cache-&gt;reg_list[num].arch_info;
+	reg_value = dsp563xx-&gt;core_regs[num];
+	buf_set_u32(dsp563xx-&gt;core_cache-&gt;reg_list[num].value, 0, 32, reg_value);
+	dsp563xx-&gt;core_cache-&gt;reg_list[num].valid = 1;
+	dsp563xx-&gt;core_cache-&gt;reg_list[num].dirty = 0;
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_write_core_reg(struct target *target, int num)
+{
+	uint32_t reg_value;
+	struct dsp563xx_core_reg *dsp563xx_core_reg;
+	
+	/* get pointers to arch-specific information */
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	if ((num &lt; 0) || (num &gt;= DSP563XX_NUMCOREREGS))
+		return ERROR_INVALID_ARGUMENTS;
+	
+	reg_value = buf_get_u32(dsp563xx-&gt;core_cache-&gt;reg_list[num].value, 0, 32);
+	dsp563xx_core_reg = dsp563xx-&gt;core_cache-&gt;reg_list[num].arch_info;
+	dsp563xx-&gt;core_regs[num] = reg_value;
+	dsp563xx-&gt;core_cache-&gt;reg_list[num].valid = 1;
+	dsp563xx-&gt;core_cache-&gt;reg_list[num].dirty = 0;
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct dsp563xx_common *dsp563xx = calloc(1, sizeof(struct dsp563xx_common));
+
+	dsp563xx-&gt;jtag_info.tap = target-&gt;tap;
+	target-&gt;arch_info = dsp563xx;
+	dsp563xx-&gt;read_core_reg = dsp563xx_read_core_reg;
+	dsp563xx-&gt;write_core_reg = dsp563xx_write_core_reg;
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_get_core_reg(struct reg *reg)
+{
+	int retval=0;
+
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	
+	struct dsp563xx_core_reg *dsp563xx_reg = reg-&gt;arch_info;
+	struct target *target = dsp563xx_reg-&gt;target;
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = dsp563xx-&gt;read_core_reg(target, dsp563xx_reg-&gt;num);
+	
+	return retval;
+}
+
+int dsp563xx_set_core_reg(struct reg *reg, uint8_t *buf)
+{
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	
+	struct dsp563xx_core_reg *dsp563xx_reg = reg-&gt;arch_info;
+	struct target *target = dsp563xx_reg-&gt;target;
+	uint32_t value = buf_get_u32(buf, 0, 32);
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	buf_set_u32(reg-&gt;value, 0, reg-&gt;size, value);
+	reg-&gt;dirty = 1;
+	reg-&gt;valid = 1;
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_save_context(struct target *target)
+{
+	int i;
+	uint32_t data=0;
+	
+	/* get pointers to arch-specific information */
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	for (i = 0; i &lt; DSP563XX_NUMCOREREGS-1; i++)
+	{
+		dsp563xx_once_execute_dw_ir(target-&gt;tap,dsp563xx_core_reg_list_arch_info[i].r_cmd,0xfffffc);
+		dsp563xx_once_execute_sw_ir(target-&gt;tap,0x000000);
+		dsp563xx_once_reg_read(target-&gt;tap,ONCE_OGDBR,&amp;data);
+		dsp563xx-&gt;core_regs[i] = data;
+	}
+
+	/* read pc */
+	dsp563xx_once_reg_read(target-&gt;tap,ONCE_OPABEX,&amp;data);
+	dsp563xx-&gt;core_regs[i] = data;
+	
+	/* read core registers */
+	for (i = 0; i &lt; DSP563XX_NUMCOREREGS; i++)
+	{
+// 		if (!dsp563xx-&gt;core_cache-&gt;reg_list[i].valid)
+		{
+			dsp563xx-&gt;read_core_reg(target, i);
+		}
+	}
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_restore_context(struct target *target)
+{
+	int i;
+	
+	/* get pointers to arch-specific information */
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	for (i = 0; i &lt; DSP563XX_NUMCOREREGS-1; i++)
+	{
+// 		if (dsp563xx-&gt;core_cache-&gt;reg_list[i].dirty)
+		{
+			dsp563xx-&gt;write_core_reg(target, i);
+		}
+	}
+	
+	/* TODO: store regs */
+	
+	return ERROR_OK;
+}
+
+static const struct reg_arch_type dsp563xx_reg_type = {
+	.get = dsp563xx_get_core_reg,
+	.set = dsp563xx_set_core_reg,
+};
+
+int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target)
+{
+	/* get pointers to arch-specific information */
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	int num_regs = DSP563XX_NUMCOREREGS;
+	struct reg_cache **cache_p = register_get_last_cache_p(&amp;target-&gt;reg_cache);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = malloc(sizeof(struct reg) * num_regs);
+	struct dsp563xx_core_reg *arch_info = malloc(sizeof(struct dsp563xx_core_reg) * num_regs);
+	int i;
+
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	
+	/* Build the process context cache */
+	cache-&gt;name = &quot;dsp563xx registers&quot;;
+	cache-&gt;next = NULL;
+	cache-&gt;reg_list = reg_list;
+	cache-&gt;num_regs = num_regs;
+	(*cache_p) = cache;
+	dsp563xx-&gt;core_cache = cache;
+	
+	for (i = 0; i &lt; num_regs; i++)
+	{
+		arch_info[i] = dsp563xx_core_reg_list_arch_info[i];
+		arch_info[i].target = target;
+		arch_info[i].dsp563xx_common = dsp563xx;
+		reg_list[i].name = dsp563xx_core_reg_list[i];
+		reg_list[i].size = dsp563xx_core_reg_list_arch_info[i].size;
+		reg_list[i].value = calloc(1, 4);
+		reg_list[i].dirty = 0;
+		reg_list[i].valid = 0;
+		reg_list[i].type = &amp;dsp563xx_reg_type;
+		reg_list[i].arch_info = &amp;arch_info[i];
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_arch_state(struct target *target)
+{
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	return ERROR_OK;
+}
+
+int dsp563xx_jtag_status(struct target *target,uint8_t * status)
+{
+	uint8_t ir_in;
+
+	ir_in=0;
+	
+	dsp563xx_jtag_sendinstr(target-&gt;tap,&amp;ir_in,JTAG_INSTR_ENABLE_ONCE);
+	dsp563xx_execute_queue();
+	
+	*status = ir_in;
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_jtag_debug_request(struct target *target)
+{
+	uint8_t ir_in = 0;
+	uint32_t retry = 0;
+	
+	while ( ir_in != JTAG_STATUS_DEBUG )
+	{
+		dsp563xx_jtag_sendinstr(target-&gt;tap,&amp;ir_in,JTAG_INSTR_DEBUG_REQUEST);
+		dsp563xx_execute_queue();
+		LOG_DEBUG(&quot;JTAG CMD 7 res: %02X&quot;,ir_in);
+		dsp563xx_jtag_sendinstr(target-&gt;tap,&amp;ir_in,JTAG_INSTR_ENABLE_ONCE);
+		dsp563xx_execute_queue();
+		LOG_DEBUG(&quot;JTAG CMD 6 res: %02X&quot;,ir_in);
+		
+		if ( retry++ == 100 )
+			return ERROR_TARGET_FAILURE;
+	}
+	
+	if ( ir_in != JTAG_STATUS_DEBUG )
+	{
+		return ERROR_TARGET_FAILURE;
+	}
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_poll(struct target *target)
+{
+	uint8_t jtag_status;
+	uint32_t once_status;
+
+	dsp563xx_jtag_status(target,&amp;jtag_status);
+
+	if ( (jtag_status &amp; 1) != 1 )
+	{
+		target-&gt;state = TARGET_UNKNOWN;
+		LOG_ERROR(&quot;jtag status contains invalid mode value - communication failure&quot;);
+		return ERROR_TARGET_FAILURE;
+	}
+
+	if ( jtag_status != 0x0d )
+	{
+		target-&gt;state = TARGET_RUNNING;
+	}
+
+	dsp563xx_once_reg_read(target-&gt;tap,ONCE_OSCR,&amp;once_status);
+
+	if ( jtag_status == 0x0d )
+	{
+		target-&gt;state = TARGET_HALTED;
+		
+	}
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_halt(struct target *target)
+{
+	uint8_t jtag_status;
+	uint32_t once_status;
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	if (target-&gt;state == TARGET_HALTED)
+	{
+		LOG_DEBUG(&quot;target was already halted&quot;);
+		return ERROR_OK;
+	}
+	
+	if (target-&gt;state == TARGET_UNKNOWN)
+	{
+		LOG_WARNING(&quot;target was in unknown state when halt was requested&quot;);
+	}
+	
+// 	if ( jtag_status != 0x0d )
+	{
+		dsp563xx_jtag_debug_request(target);
+
+		dsp563xx_once_reg_read(target-&gt;tap,ONCE_OPILR,&amp;dsp563xx-&gt;pipeline_context.once_opilr);
+		dsp563xx_once_reg_read(target-&gt;tap,ONCE_OPDBR,&amp;dsp563xx-&gt;pipeline_context.once_opdbr);
+		
+		dsp563xx_save_context(target);
+
+		dsp563xx_jtag_status(target,&amp;jtag_status);
+		LOG_DEBUG(&quot;%02X&quot;,jtag_status);
+		dsp563xx_once_reg_read(target-&gt;tap,ONCE_OSCR,&amp;once_status);
+		LOG_DEBUG(&quot;%02X&quot;,once_status);
+	}
+	
+	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
+		  target_state_name(target));
+	
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	
+	return ERROR_OK;
+}
+
+#define DSP563XX_ASM_CMD_JUMP	0x0AF080
+
+int dsp563xx_resume(struct target *target, int current, uint32_t address, int handle_breakpoints,
int debug_execution)
+{
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	
+	dsp563xx_restore_context(target);
+	
+	if ( current )
+	{
+		/* restore pipeline registers and go */
+		dsp563xx_once_reg_write(target-&gt;tap,ONCE_OPILR,dsp563xx-&gt;pipeline_context.once_opilr);
+	
dsp563xx_once_reg_write(target-&gt;tap,ONCE_OPDBR|ONCE_OCR_EX|ONCE_OCR_GO,dsp563xx-&gt;pipeline_context.once_opdbr);
+	}
+	else
+	{
+		/* set to go register and jump */
+		dsp563xx_once_reg_write(target-&gt;tap,ONCE_OPDBR,DSP563XX_ASM_CMD_JUMP);
+		dsp563xx_once_reg_write(target-&gt;tap,ONCE_PDBGOTO|ONCE_OCR_EX|ONCE_OCR_GO,address);
+	}
+	
+	target-&gt;state = TARGET_RUNNING;
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
+{
+	uint32_t once_status;
+	uint32_t dr_in;
+	struct dsp563xx_common *dsp563xx = target-&gt;arch_info;
+	
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_DEBUG(&quot;target was not halted&quot;);
+		return ERROR_OK;
+	}
+	
+	LOG_DEBUG(&quot;%s %08X %08X&quot;, __FUNCTION__, current, address);
+	
+	dsp563xx_jtag_debug_request(target);
+	
+	dsp563xx_restore_context(target);
+	
+	/* reset trace mode */
+	dsp563xx_once_reg_write(target-&gt;tap,ONCE_OSCR,0x000000);
+	/* enable trace mode */
+	dsp563xx_once_reg_write(target-&gt;tap,ONCE_OSCR,ONCE_OSCR_TME);
+	/* load step counter with N-1 */
+	dsp563xx_once_reg_write(target-&gt;tap,ONCE_OTC,0x000000);
+	
+	if ( current )
+	{
+		/* restore pipeline registers and go */
+		dsp563xx_once_reg_write(target-&gt;tap,ONCE_OPILR,dsp563xx-&gt;pipeline_context.once_opilr);
+	
dsp563xx_once_reg_write(target-&gt;tap,ONCE_OPDBR|ONCE_OCR_EX|ONCE_OCR_GO,dsp563xx-&gt;pipeline_context.once_opdbr);
+	}
+	else
+	{
+		/* set to go register and jump */
+		dsp563xx_once_reg_write(target-&gt;tap,ONCE_OPDBR,DSP563XX_ASM_CMD_JUMP);
+		dsp563xx_once_reg_write(target-&gt;tap,ONCE_PDBGOTO|ONCE_OCR_EX|ONCE_OCR_GO,address);
+	}
+	
+	while(1)
+	{
+		dsp563xx_once_reg_read(target-&gt;tap,ONCE_OSCR,&amp;once_status);
+		
+		if ( once_status &amp; (1&lt;&lt;4) )
+		{
+			dsp563xx_once_reg_read(target-&gt;tap,ONCE_OPILR,&amp;dsp563xx-&gt;pipeline_context.once_opilr);
+			dsp563xx_once_reg_read(target-&gt;tap,ONCE_OPDBR,&amp;dsp563xx-&gt;pipeline_context.once_opdbr);
+
+			dsp563xx_save_context(target);
+			
+			dsp563xx_once_reg_read(target-&gt;tap,ONCE_OPABFR,&amp;dr_in);
+			LOG_DEBUG(&quot;%08X&quot;, dr_in);
+			dsp563xx_once_reg_read(target-&gt;tap,ONCE_OPABDR,&amp;dr_in);
+			LOG_DEBUG(&quot;%08X&quot;, dr_in);
+			dsp563xx_once_reg_read(target-&gt;tap,ONCE_OPABEX,&amp;dr_in);
+			LOG_DEBUG(&quot;%08X&quot;, dr_in);
+			
+			
+			/* reset trace mode */
+			dsp563xx_once_reg_write(target-&gt;tap,ONCE_OSCR,0x000000);
+			break;
+		}
+	}
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_assert_reset(struct target *target)
+{
+	target-&gt;state = TARGET_RESET;
+
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	return ERROR_OK;
+}
+
+int dsp563xx_deassert_reset(struct target *target)
+{
+	target-&gt;state = TARGET_RUNNING;
+
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	return ERROR_OK;
+}
+
+int dsp563xx_soft_reset_halt(struct target *target)
+{
+	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
+	return ERROR_OK;
+}
+
+/*
+* 000000			nop
+* 46F400 AABBCC		move              #$aabbcc,y0
+* 60F400 AABBCC		move              #$aabbcc,r0
+* 467000 AABBCC		move              y0,x:AABBCC
+* 607000 AABBCC		move              r0,x:AABBCC
+
+* 46E000		move              x:(r0),y0
+* 4EE000		move              y:(r0),y0
+* 07E086		move              p:(r0),y0
+
+* 0450B9		move              sr,r0
+* 0446BA		move              omr,y0
+* 0446BC		move              ssh,y0
+* 0446BD		move              ssl,y0
+* 0446BE		move              la,y0
+* 0446BF		move              lc,y0
+*
+* 61F000 AABBCC		move              x:AABBCC,r1
+* 076190		movem             r0,p:(r1)
+*
+*/
+
+int dsp563xx_read_memory_p(struct target *target, uint32_t address,
+		      uint32_t size, uint32_t count, uint8_t *buffer)
+{
+// 	uint32_t *buf32;
+	uint32_t i,x;
+	uint32_t data;
+	uint8_t *b;
+// 	int retval;
+
+	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, size: 0x%8.8&quot; PRIx32 &quot;, count: 0x%8.8&quot; PRIx32, address,
size, count);
+	
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_WARNING(&quot;target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+	
+	x = count;
+	
+	for(i=0;i&lt;x;i++)
+	{
+		dsp563xx_once_execute_dw_ir_nq(target-&gt;tap,0x60F400,address+i);
+		dsp563xx_once_execute_sw_ir_nq(target-&gt;tap,0x07E086);
+		dsp563xx_once_execute_dw_ir_nq(target-&gt;tap,0x467000,0xfffffc);
+		dsp563xx_execute_queue();
+		
+		dsp563xx_once_reg_read(target-&gt;tap,ONCE_OGDBR,&amp;data);
+		
+		b = buffer+4*i;
+		if ( size &gt; 0 ) *b++ = data &gt;&gt; 0;
+		if ( size &gt; 1 ) *b++ = data &gt;&gt; 8;
+		if ( size &gt; 2 ) *b++ = data &gt;&gt; 16;
+		if ( size &gt; 3 ) *b++ = 0x00;
+	}
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count,
uint8_t *buffer)
+{
+	uint32_t i,x;
+	uint32_t data;
+	uint8_t *b;
+	
+	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, size: 0x%8.8&quot; PRIx32 &quot;, count: 0x%8.8&quot; PRIx32 &quot;&quot;, address,
size, count);
+	
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_WARNING(&quot;target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+	
+	x = count;
+	
+	for(i=0;i&lt;x;i++)
+	{
+		b = buffer+4*i;
+		
+		data = 0;
+		if ( size &gt; 0 ) data = *buffer++;
+		if ( size &gt; 1 ) data |= (*buffer++)&lt;&lt;8;
+		if ( size &gt; 2 ) data |= (*buffer++)&lt;&lt;16;
+		if ( size &gt; 3 ) data |= (*buffer++)&lt;&lt;24;
+		
+// 		LOG_DEBUG(&quot;%08X&quot;, data);
+		
+		dsp563xx_once_execute_dw_ir_nq(target-&gt;tap,0x61F400,address+i);
+		dsp563xx_once_execute_dw_ir_nq(target-&gt;tap,0x60F400,data);
+		dsp563xx_once_execute_sw_ir_nq(target-&gt;tap,0x076190);
+		dsp563xx_execute_queue();
+	}
+	
+	return ERROR_OK;
+}
+
+int dsp563xx_jtag_senddat(struct jtag_tap *tap, uint32_t* dr_in, uint32_t dr_out, int len)
+{
+	return dsp563xx_write_dr_u32(tap, dr_in, dr_out, len, 1);
+}
+
+int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out)
+{
+	return dsp563xx_write_ir_u8(tap, ir_in, ir_out, DSP563XX_JTAG_INS_LEN, 1);
+}
+
+/* IR and DR functions */
+int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti)
+{
+	if (NULL == tap)
+	{
+		LOG_ERROR(&quot;invalid tap&quot;);
+		return ERROR_FAIL;
+	}
+	if (ir_len != tap-&gt;ir_length)
+	{
+		LOG_ERROR(&quot;invalid ir_len&quot;);
+		return ERROR_FAIL;
+	}
+
+	{
+		struct scan_field field[1];
+
+		field[0].tap = tap;
+		field[0].num_bits = tap-&gt;ir_length;
+		field[0].out_value = ir_out;
+		field[0].in_value = ir_in;
+		jtag_add_plain_ir_scan(ARRAY_SIZE(field), field, jtag_set_end_state(TAP_IDLE));
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti)
+{
+	if (NULL == tap)
+	{
+		LOG_ERROR(&quot;invalid tap&quot;);
+		return ERROR_FAIL;
+	}
+
+	{
+		struct scan_field field[1];
+
+		field[0].tap = tap;
+		field[0].num_bits = dr_len;
+		field[0].out_value = dr_out;
+		field[0].in_value = dr_in;
+		jtag_add_plain_dr_scan(ARRAY_SIZE(field), field, jtag_set_end_state(TAP_IDLE));
+	}
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti)
+{
+	if (ir_len &gt; 8)
+	{
+		LOG_ERROR(&quot;ir_len overflow, maxium is 8&quot;);
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_ir(tap, ir_in, &amp;ir_out, ir_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t *dr_in, uint8_t dr_out, int dr_len, int rti)
+{
+	if (dr_len &gt; 8)
+	{
+		LOG_ERROR(&quot;dr_len overflow, maxium is 8&quot;);
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_dr(tap, dr_in, &amp;dr_out, dr_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_ir_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int ir_len, int rti)
+{
+	if (ir_len &gt; 16)
+	{
+		LOG_ERROR(&quot;ir_len overflow, maxium is 16&quot;);
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_ir(tap, (uint8_t*)ir_in, (uint8_t*)&amp;ir_out, ir_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_dr_u16(struct jtag_tap *tap, uint16_t *dr_in, uint16_t dr_out, int dr_len, int rti)
+{
+	if (dr_len &gt; 16)
+	{
+		LOG_ERROR(&quot;dr_len overflow, maxium is 16&quot;);
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_dr(tap, (uint8_t*)dr_in, (uint8_t*)&amp;dr_out, dr_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_ir_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti)
+{
+	if (ir_len &gt; 32)
+	{
+		LOG_ERROR(&quot;ir_len overflow, maxium is 32&quot;);
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_ir(tap, (uint8_t*)ir_in, (uint8_t*)&amp;ir_out, ir_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t *dr_in, uint32_t dr_out, int dr_len, int rti)
+{
+	if (dr_len &gt; 32)
+	{
+		LOG_ERROR(&quot;dr_len overflow, maxium is 32&quot;);
+		return ERROR_FAIL;
+	}
+
+	dsp563xx_write_dr(tap, (uint8_t*)dr_in, (uint8_t*)&amp;dr_out, dr_len, rti);
+
+	return ERROR_OK;
+}
+
+int dsp563xx_execute_queue(void)
+{
+	return jtag_execute_queue();
+}
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
new file mode 100644
index 0000000..7ca8f03
--- /dev/null
+++ b/src/target/dsp563xx.h
@@ -0,0 +1,73 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">mkdorg at users.sourceforge.net</A>                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef DSP563XX_H
+#define DSP563XX_H
+
+#include &quot;jtag.h&quot;
+
+#define DSP563XX_NUMCOREREGS	42
+
+struct mcu_jtag
+{
+	struct jtag_tap *tap;
+};
+
+struct dsp563xx_pipeline_context
+{
+	/* PIL Register */
+	uint32_t once_opilr;
+	/* PDB Register */
+	uint32_t once_opdbr;
+};
+
+struct dsp563xx_common
+{
+	struct mcu_jtag jtag_info;
+	struct reg_cache *core_cache;
+	uint32_t core_regs[DSP563XX_NUMCOREREGS];
+	
+	struct dsp563xx_pipeline_context pipeline_context;
+	
+	/* register cache to processor synchronization */
+	int (*read_core_reg)(struct target *target, int num);
+	int (*write_core_reg)(struct target *target, int num);
+};
+
+struct dsp563xx_core_reg
+{
+	uint32_t num;
+	uint32_t size;
+	uint32_t r_cmd;
+	struct target *target;
+	struct dsp563xx_common *dsp563xx_common;
+};
+
+int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti);
+int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti);
+int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti);
+int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int dr_len, int rti);
+int dsp563xx_write_ir_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int ir_len, int rti);
+int dsp563xx_write_dr_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int dr_len, int rti);
+int dsp563xx_write_ir_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti);
+int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int dr_len, int rti);
+
+int dsp563xx_execute_queue(void);
+
+#endif /* DSP563XX_H */
diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
new file mode 100644
index 0000000..5884dae
--- /dev/null
+++ b/src/target/dsp563xx_once.c
@@ -0,0 +1,116 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">mkdorg at users.sourceforge.net</A>                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;target.h&quot;
+#include &quot;target_type.h&quot;
+#include &quot;register.h&quot;
+#include &quot;dsp563xx.h&quot;
+#include &quot;dsp563xx_once.h&quot;
+
+/** single word instruction */
+int dsp563xx_once_ir_exec(struct jtag_tap *tap,uint8_t instr,uint8_t rw,uint8_t go,uint8_t ex)
+{
+	dsp563xx_write_dr_u8(tap,0,instr|(ex&lt;&lt;5)|(go&lt;&lt;6)|(rw&lt;&lt;7),8,0);
+	dsp563xx_execute_queue();
+	
+	return ERROR_OK;
+}
+
+/** single word instruction */
+int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap,uint8_t instr,uint8_t rw,uint8_t go,uint8_t ex)
+{
+	dsp563xx_write_dr_u8(tap,0,instr|(ex&lt;&lt;5)|(go&lt;&lt;6)|(rw&lt;&lt;7),8,0);
+	
+	return ERROR_OK;
+}
+
+/** once read register */
+int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data )
+{
+	uint32_t dr_in;
+	
+	dr_in = 0;
+	
+	dsp563xx_once_ir_exec(tap,reg,1,0,0);
+	dsp563xx_write_dr_u32(tap,&amp;dr_in,0x00,24,0);
+	dsp563xx_execute_queue();
+	
+	*data = dr_in;
+	
+	return ERROR_OK;
+}
+
+/** once write register */
+int dsp563xx_once_reg_write(struct jtag_tap *tap, uint8_t reg, uint32_t data )
+{
+	dsp563xx_once_ir_exec(tap,reg,0,0,0);
+	dsp563xx_write_dr_u32(tap,0x00,data,24,0);
+	dsp563xx_execute_queue();
+	
+	return ERROR_OK;
+}
+
+/** single word instruction */
+int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap,uint32_t opcode)
+{
+	dsp563xx_once_ir_exec(tap,ONCE_OPDBR,0,1,0);
+	dsp563xx_write_dr_u32(tap,0,opcode,24,0);
+	dsp563xx_execute_queue();
+	
+	return ERROR_OK;
+}
+
+/** double word instruction */
+int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap,uint32_t opcode,uint32_t operand)
+{
+	dsp563xx_once_ir_exec(tap,ONCE_OPDBR,0,0,0);
+	dsp563xx_write_dr_u32(tap,0,opcode,24,0);
+	dsp563xx_execute_queue();
+	
+	dsp563xx_once_ir_exec(tap,ONCE_OPDBR,0,1,0);
+	dsp563xx_write_dr_u32(tap,0,operand,24,0);
+	dsp563xx_execute_queue();
+	
+	return ERROR_OK;
+}
+
+/** single word instruction */
+int dsp563xx_once_execute_sw_ir_nq(struct jtag_tap *tap,uint32_t opcode)
+{
+	dsp563xx_once_ir_exec_nq(tap,ONCE_OPDBR,0,1,0);
+	dsp563xx_write_dr_u32(tap,0,opcode,24,0);
+
+	return ERROR_OK;
+}
+
+/** double word instruction */
+int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap,uint32_t opcode,uint32_t operand)
+{
+	dsp563xx_once_ir_exec_nq(tap,ONCE_OPDBR,0,0,0);
+	dsp563xx_write_dr_u32(tap,0,opcode,24,0);
+	
+	dsp563xx_once_ir_exec_nq(tap,ONCE_OPDBR,0,1,0);
+	dsp563xx_write_dr_u32(tap,0,operand,24,0);
+
+	return ERROR_OK;
+}
diff --git a/src/target/dsp563xx_once.h b/src/target/dsp563xx_once.h
new file mode 100644
index 0000000..5dbe01f
--- /dev/null
+++ b/src/target/dsp563xx_once.h
@@ -0,0 +1,71 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">mkdorg at users.sourceforge.net</A>                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef DSP563XX_ONCE_H
+#define DSP563XX_ONCE_H
+
+#include &quot;jtag.h&quot;
+
+#define ONCE_OCR_EX	(1&lt;&lt;5)
+#define ONCE_OCR_GO	(1&lt;&lt;6)
+#define ONCE_OCR_RW	(1&lt;&lt;7)
+
+#define ONCE_OSCR_OS1	(1&lt;&lt;7)
+#define ONCE_OSCR_OS0	(1&lt;&lt;6)
+#define ONCE_OSCR_HIT	(1&lt;&lt;5)
+#define ONCE_OSCR_TO	(1&lt;&lt;4)
+#define ONCE_OSCR_MBO	(1&lt;&lt;3)
+#define ONCE_OSCR_SWO	(1&lt;&lt;2)
+#define ONCE_OSCR_IME	(1&lt;&lt;1)
+#define ONCE_OSCR_TME	(1&lt;&lt;0)
+
+#define ONCE_OSCR	0x000
+#define ONCE_OMBC	0x001
+#define ONCE_OBCR	0x002
+#define ONCE_OMLR0	0x005
+#define ONCE_OMLR1	0x006
+#define ONCE_OGDBR	0x009
+#define ONCE_OPDBR	0x00A
+#define ONCE_OPILR	0x00B
+#define ONCE_PDBGOTO	0x00C
+#define ONCE_OTC	0x00D
+#define ONCE_TAGB	0x00E
+#define ONCE_OPABFR	0x00F
+#define ONCE_OPABDR	0x010
+#define ONCE_OPABEX	0x011
+#define ONCE_NOREG	0x01F
+
+/** single word instruction */
+int dsp563xx_once_ir_exec(struct jtag_tap *tap,uint8_t instr,uint8_t rw,uint8_t go,uint8_t ex);
+/** single word instruction */
+int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap,uint8_t instr,uint8_t rw,uint8_t go,uint8_t ex);
+/** once read register */
+int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data );
+/** once write register */
+int dsp563xx_once_reg_write(struct jtag_tap *tap, uint8_t reg, uint32_t data );
+/** single word instruction */
+int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap,uint32_t opcode);
+/** double word instruction */
+int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap,uint32_t opcode,uint32_t operand);
+/** single word instruction */
+int dsp563xx_once_execute_sw_ir_nq(struct jtag_tap *tap,uint32_t opcode);
+/** double word instruction */
+int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap,uint32_t opcode,uint32_t operand);
+
+#endif /* DSP563XX_ONCE_H */
-- 1.6.5.4

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013383.html">[Openocd-development] [PATCH 3/4] - add dsp563xx support
</A></li>
	<LI>Next message: <A HREF="013384.html">[Openocd-development] [PATCH 4/4] - add dsp563xx support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13380">[ date ]</a>
              <a href="thread.html#13380">[ thread ]</a>
              <a href="subject.html#13380">[ subject ]</a>
              <a href="author.html#13380">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-development">More information about the Openocd-development
mailing list</a><br>
</body></html>
