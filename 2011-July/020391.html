<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-development] [PATCH 1/4] flash: update stm32 driver names
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-development/2011-July/index.html" >
   <LINK REL="made" HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20%5BPATCH%201/4%5D%20flash%3A%20update%20stm32%20driver%20names&In-Reply-To=%3C1311853942-26763-2-git-send-email-spen%40spen-soft.co.uk%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020389.html">
   <LINK REL="Next"  HREF="020402.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-development] [PATCH 1/4] flash: update stm32 driver names</H1>
    <B>Spencer Oliver</B> 
    <A HREF="mailto:openocd-development%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-development%5D%20%5BPATCH%201/4%5D%20flash%3A%20update%20stm32%20driver%20names&In-Reply-To=%3C1311853942-26763-2-git-send-email-spen%40spen-soft.co.uk%3E"
       TITLE="[Openocd-development] [PATCH 1/4] flash: update stm32 driver names">spen at spen-soft.co.uk
       </A><BR>
    <I>Thu Jul 28 13:52:19 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="020389.html">[Openocd-development] [PATCH]rename stm32 flash drivers
</A></li>
        <LI>Next message: <A HREF="020402.html">[Openocd-development] [PATCH 1/4] flash: update stm32 driver	names
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20391">[ date ]</a>
              <a href="thread.html#20391">[ thread ]</a>
              <a href="subject.html#20391">[ subject ]</a>
              <a href="author.html#20391">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>From: Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">ntfreak at users.sourceforge.net</A>&gt;

Use consistent names for the stm32 family flash drivers, eg.
stm32x -&gt; stm32f1x
stm32f2xxx -&gt; stm32f2x

this makes it easier to add support for newer stm32 families.

Signed-off-by: Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">ntfreak at users.sourceforge.net</A>&gt;
---
 src/flash/nor/Makefile.am  |    4 +-
 src/flash/nor/drivers.c    |    8 +-
 src/flash/nor/stm32f1x.c   | 1568 ++++++++++++++++++++++++++++++++++++++++++++
 src/flash/nor/stm32f2x.c   |  706 ++++++++++++++++++++
 src/flash/nor/stm32f2xxx.c |  707 --------------------
 src/flash/nor/stm32x.c     | 1568 --------------------------------------------
 6 files changed, 2280 insertions(+), 2281 deletions(-)
 create mode 100644 src/flash/nor/stm32f1x.c
 create mode 100644 src/flash/nor/stm32f2x.c
 delete mode 100644 src/flash/nor/stm32f2xxx.c
 delete mode 100644 src/flash/nor/stm32x.c

diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index c897851..6dd95fe 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -24,8 +24,8 @@ NOR_DRIVERS = \
 	pic32mx.c \
 	stmsmi.c \
 	stellaris.c \
-	stm32x.c \
-	stm32f2xxx.c \
+	stm32f1x.c \
+	stm32f2x.c \
 	str7x.c \
 	str9x.c \
 	str9xpec.c \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index dc927b3..669b0b9 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -32,8 +32,8 @@ extern struct flash_driver str9x_flash;
 extern struct flash_driver aduc702x_flash;
 extern struct flash_driver stellaris_flash;
 extern struct flash_driver str9xpec_flash;
-extern struct flash_driver stm32x_flash;
-extern struct flash_driver stm32xf2xxx_flash;
+extern struct flash_driver stm32f1x_flash;
+extern struct flash_driver stm32f2x_flash;
 extern struct flash_driver tms470_flash;
 extern struct flash_driver ecosflash_flash;
 extern struct flash_driver ocl_flash;
@@ -62,8 +62,8 @@ static struct flash_driver *flash_drivers[] = {
 	&amp;aduc702x_flash,
 	&amp;stellaris_flash,
 	&amp;str9xpec_flash,
-	&amp;stm32x_flash,
-	&amp;stm32xf2xxx_flash,
+	&amp;stm32f1x_flash,
+	&amp;stm32f2x_flash,
 	&amp;tms470_flash,
 	&amp;ecosflash_flash,
 	&amp;ocl_flash,
diff --git a/src/flash/nor/stm32f1x.c b/src/flash/nor/stm32f1x.c
new file mode 100644
index 0000000..6bc4300
--- /dev/null
+++ b/src/flash/nor/stm32f1x.c
@@ -0,0 +1,1568 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">Dominic.Rath at gmx.de</A>                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">spen at spen-soft.co.uk</A>                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;imp.h&quot;
+#include &lt;helper/binarybuffer.h&gt;
+#include &lt;target/algorithm.h&gt;
+#include &lt;target/armv7m.h&gt;
+
+/* stm32x register locations */
+
+#define STM32_FLASH_ACR		0x40022000
+#define STM32_FLASH_KEYR	0x40022004
+#define STM32_FLASH_OPTKEYR	0x40022008
+#define STM32_FLASH_SR		0x4002200C
+#define STM32_FLASH_CR		0x40022010
+#define STM32_FLASH_AR		0x40022014
+#define STM32_FLASH_OBR		0x4002201C
+#define STM32_FLASH_WRPR	0x40022020
+
+/* option byte location */
+
+#define STM32_OB_RDP		0x1FFFF800
+#define STM32_OB_USER		0x1FFFF802
+#define STM32_OB_DATA0		0x1FFFF804
+#define STM32_OB_DATA1		0x1FFFF806
+#define STM32_OB_WRP0		0x1FFFF808
+#define STM32_OB_WRP1		0x1FFFF80A
+#define STM32_OB_WRP2		0x1FFFF80C
+#define STM32_OB_WRP3		0x1FFFF80E
+
+/* FLASH_CR register bits */
+
+#define FLASH_PG		(1 &lt;&lt; 0)
+#define FLASH_PER		(1 &lt;&lt; 1)
+#define FLASH_MER		(1 &lt;&lt; 2)
+#define FLASH_OPTPG		(1 &lt;&lt; 4)
+#define FLASH_OPTER		(1 &lt;&lt; 5)
+#define FLASH_STRT		(1 &lt;&lt; 6)
+#define FLASH_LOCK		(1 &lt;&lt; 7)
+#define FLASH_OPTWRE	(1 &lt;&lt; 9)
+
+/* FLASH_SR register bits */
+
+#define FLASH_BSY		(1 &lt;&lt; 0)
+#define FLASH_PGERR		(1 &lt;&lt; 2)
+#define FLASH_WRPRTERR	(1 &lt;&lt; 4)
+#define FLASH_EOP		(1 &lt;&lt; 5)
+
+/* STM32_FLASH_OBR bit definitions (reading) */
+
+#define OPT_ERROR		0
+#define OPT_READOUT		1
+#define OPT_RDWDGSW		2
+#define OPT_RDRSTSTOP	3
+#define OPT_RDRSTSTDBY	4
+#define OPT_BFB2		5	/* dual flash bank only */
+
+/* register unlock keys */
+
+#define KEY1			0x45670123
+#define KEY2			0xCDEF89AB
+
+/* we use an offset to access the second bank on dual flash devices
+ * strangely the protection of the second bank is done on the bank0 reg's */
+
+#define FLASH_OFFSET_B0	0x00
+#define FLASH_OFFSET_B1 0x40
+
+struct stm32x_options
+{
+	uint16_t RDP;
+	uint16_t user_options;
+	uint16_t protection[4];
+};
+
+struct stm32x_flash_bank
+{
+	struct stm32x_options option_bytes;
+	struct working_area *write_algorithm;
+	int ppage_size;
+	int probed;
+
+	bool has_dual_banks;
+	/* used to access dual flash bank stm32xl
+	 * 0x00 will address bank 0 flash
+	 * 0x40 will address bank 1 flash */
+	int register_offset;
+};
+
+static int stm32x_mass_erase(struct flash_bank *bank);
+
+/* flash bank stm32x &lt;base&gt; &lt;size&gt; 0 0 &lt;target#&gt;
+ */
+FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
+{
+	struct stm32x_flash_bank *stm32x_info;
+
+	if (CMD_ARGC &lt; 6)
+	{
+		LOG_WARNING(&quot;incomplete flash_bank stm32x configuration&quot;);
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	stm32x_info = malloc(sizeof(struct stm32x_flash_bank));
+	bank-&gt;driver_priv = stm32x_info;
+
+	stm32x_info-&gt;write_algorithm = NULL;
+	stm32x_info-&gt;probed = 0;
+	stm32x_info-&gt;has_dual_banks = false;
+	stm32x_info-&gt;register_offset = FLASH_OFFSET_B0;
+
+	return ERROR_OK;
+}
+
+static inline int stm32x_get_flash_reg(struct flash_bank *bank, uint32_t reg)
+{
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+	return reg + stm32x_info-&gt;register_offset;
+}
+
+static inline int stm32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
+{
+	struct target *target = bank-&gt;target;
+	return target_read_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR), status);
+}
+
+static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
+{
+	struct target *target = bank-&gt;target;
+	uint32_t status;
+	int retval = ERROR_OK;
+
+	/* wait for busy to clear */
+	for (;;)
+	{
+		retval = stm32x_get_flash_status(bank, &amp;status);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG(&quot;status: 0x%&quot; PRIx32 &quot;&quot;, status);
+		if ((status &amp; FLASH_BSY) == 0)
+			break;
+		if (timeout-- &lt;= 0)
+		{
+			LOG_ERROR(&quot;timed out waiting for flash&quot;);
+			return ERROR_FAIL;
+		}
+		alive_sleep(1);
+	}
+
+	if (status &amp; FLASH_WRPRTERR)
+	{
+		LOG_ERROR(&quot;stm32x device protected&quot;);
+		retval = ERROR_FAIL;
+	}
+
+	if (status &amp; FLASH_PGERR)
+	{
+		LOG_ERROR(&quot;stm32x device programming failed&quot;);
+		retval = ERROR_FAIL;
+	}
+
+	/* Clear but report errors */
+	if (status &amp; (FLASH_WRPRTERR | FLASH_PGERR))
+	{
+		/* If this operation fails, we ignore it and report the original
+		 * retval
+		 */
+		target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR),
+				FLASH_WRPRTERR | FLASH_PGERR);
+	}
+	return retval;
+}
+
+int stm32x_check_operation_supported(struct flash_bank *bank)
+{
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+
+	/* if we have a dual flash bank device then
+	 * we need to perform option byte stuff on bank0 only */
+	if (stm32x_info-&gt;register_offset != FLASH_OFFSET_B0)
+	{
+		LOG_ERROR(&quot;Option Byte Operation's must use bank0&quot;);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+static int stm32x_read_options(struct flash_bank *bank)
+{
+	uint32_t optiondata;
+	struct stm32x_flash_bank *stm32x_info = NULL;
+	struct target *target = bank-&gt;target;
+
+	stm32x_info = bank-&gt;driver_priv;
+
+	/* read current option bytes */
+	int retval = target_read_u32(target, STM32_FLASH_OBR, &amp;optiondata);
+	if (retval != ERROR_OK)
+		return retval;
+
+	stm32x_info-&gt;option_bytes.user_options = (uint16_t)0xFFF8 | ((optiondata &gt;&gt; 2) &amp; 0x07);
+	stm32x_info-&gt;option_bytes.RDP = (optiondata &amp; (1 &lt;&lt; OPT_READOUT)) ? 0xFFFF : 0x5AA5;
+
+	if (optiondata &amp; (1 &lt;&lt; OPT_READOUT))
+		LOG_INFO(&quot;Device Security Bit Set&quot;);
+
+	/* each bit refers to a 4bank protection */
+	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;optiondata);
+	if (retval != ERROR_OK)
+		return retval;
+
+	stm32x_info-&gt;option_bytes.protection[0] = (uint16_t)optiondata;
+	stm32x_info-&gt;option_bytes.protection[1] = (uint16_t)(optiondata &gt;&gt; 8);
+	stm32x_info-&gt;option_bytes.protection[2] = (uint16_t)(optiondata &gt;&gt; 16);
+	stm32x_info-&gt;option_bytes.protection[3] = (uint16_t)(optiondata &gt;&gt; 24);
+
+	return ERROR_OK;
+}
+
+static int stm32x_erase_options(struct flash_bank *bank)
+{
+	struct stm32x_flash_bank *stm32x_info = NULL;
+	struct target *target = bank-&gt;target;
+
+	stm32x_info = bank-&gt;driver_priv;
+
+	/* read current options */
+	stm32x_read_options(bank);
+
+	/* unlock flash registers */
+	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* unlock option flash registers */
+	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* erase option bytes */
+	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTER | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTER | FLASH_STRT | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32x_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* clear readout protection and complementary option bytes
+	 * this will also force a device unlock if set */
+	stm32x_info-&gt;option_bytes.RDP = 0x5AA5;
+
+	return ERROR_OK;
+}
+
+static int stm32x_write_options(struct flash_bank *bank)
+{
+	struct stm32x_flash_bank *stm32x_info = NULL;
+	struct target *target = bank-&gt;target;
+
+	stm32x_info = bank-&gt;driver_priv;
+
+	/* unlock flash registers */
+	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* unlock option flash registers */
+	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* program option bytes */
+	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTPG | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write user option byte */
+	retval = target_write_u16(target, STM32_OB_USER, stm32x_info-&gt;option_bytes.user_options);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32x_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write protection byte 1 */
+	retval = target_write_u16(target, STM32_OB_WRP0, stm32x_info-&gt;option_bytes.protection[0]);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32x_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write protection byte 2 */
+	retval = target_write_u16(target, STM32_OB_WRP1, stm32x_info-&gt;option_bytes.protection[1]);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32x_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write protection byte 3 */
+	retval = target_write_u16(target, STM32_OB_WRP2, stm32x_info-&gt;option_bytes.protection[2]);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32x_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write protection byte 4 */
+	retval = target_write_u16(target, STM32_OB_WRP3, stm32x_info-&gt;option_bytes.protection[3]);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32x_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write readout protection bit */
+	retval = target_write_u16(target, STM32_OB_RDP, stm32x_info-&gt;option_bytes.RDP);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32x_wait_status_busy(bank, 10);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int stm32x_protect_check(struct flash_bank *bank)
+{
+	struct target *target = bank-&gt;target;
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+
+	uint32_t protection;
+	int i, s;
+	int num_bits;
+	int set;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	int retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	/* medium density - each bit refers to a 4bank protection
+	 * high density - each bit refers to a 2bank protection */
+	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;protection);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* medium density - each protection bit is for 4 * 1K pages
+	 * high density - each protection bit is for 2 * 2K pages */
+	num_bits = (bank-&gt;num_sectors / stm32x_info-&gt;ppage_size);
+
+	if (stm32x_info-&gt;ppage_size == 2)
+	{
+		/* high density flash/connectivity line protection */
+
+		set = 1;
+
+		if (protection &amp; (1 &lt;&lt; 31))
+			set = 0;
+
+		/* bit 31 controls sector 62 - 255 protection for high density
+		 * bit 31 controls sector 62 - 127 protection for connectivity line */
+		for (s = 62; s &lt; bank-&gt;num_sectors; s++)
+		{
+			bank-&gt;sectors[s].is_protected = set;
+		}
+
+		if (bank-&gt;num_sectors &gt; 61)
+			num_bits = 31;
+
+		for (i = 0; i &lt; num_bits; i++)
+		{
+			set = 1;
+
+			if (protection &amp; (1 &lt;&lt; i))
+				set = 0;
+
+			for (s = 0; s &lt; stm32x_info-&gt;ppage_size; s++)
+				bank-&gt;sectors[(i * stm32x_info-&gt;ppage_size) + s].is_protected = set;
+		}
+	}
+	else
+	{
+		/* low/medium density flash protection */
+		for (i = 0; i &lt; num_bits; i++)
+		{
+			set = 1;
+
+			if (protection &amp; (1 &lt;&lt; i))
+				set = 0;
+
+			for (s = 0; s &lt; stm32x_info-&gt;ppage_size; s++)
+				bank-&gt;sectors[(i * stm32x_info-&gt;ppage_size) + s].is_protected = set;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int stm32x_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank-&gt;target;
+	int i;
+
+	if (bank-&gt;target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if ((first == 0) &amp;&amp; (last == (bank-&gt;num_sectors - 1)))
+	{
+		return stm32x_mass_erase(bank);
+	}
+
+	/* unlock flash registers */
+	int retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	for (i = first; i &lt;= last; i++)
+	{
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PER);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_AR),
+				bank-&gt;base + bank-&gt;sectors[i].offset);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u32(target,
+				stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PER | FLASH_STRT);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, 100);
+		if (retval != ERROR_OK)
+			return retval;
+
+		bank-&gt;sectors[i].is_erased = 1;
+	}
+
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	struct stm32x_flash_bank *stm32x_info = NULL;
+	struct target *target = bank-&gt;target;
+	uint16_t prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
+	int i, reg, bit;
+	int status;
+	uint32_t protection;
+
+	stm32x_info = bank-&gt;driver_priv;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	int retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if ((first % stm32x_info-&gt;ppage_size) != 0)
+	{
+		LOG_WARNING(&quot;aligned start protect sector to a %d sector boundary&quot;,
+				stm32x_info-&gt;ppage_size);
+		first = first - (first % stm32x_info-&gt;ppage_size);
+	}
+	if (((last + 1) % stm32x_info-&gt;ppage_size) != 0)
+	{
+		LOG_WARNING(&quot;aligned end protect sector to a %d sector boundary&quot;,
+				stm32x_info-&gt;ppage_size);
+		last++;
+		last = last - (last % stm32x_info-&gt;ppage_size);
+		last--;
+	}
+
+	/* medium density - each bit refers to a 4bank protection
+	 * high density - each bit refers to a 2bank protection */
+	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;protection);
+	if (retval != ERROR_OK)
+		return retval;
+
+	prot_reg[0] = (uint16_t)protection;
+	prot_reg[1] = (uint16_t)(protection &gt;&gt; 8);
+	prot_reg[2] = (uint16_t)(protection &gt;&gt; 16);
+	prot_reg[3] = (uint16_t)(protection &gt;&gt; 24);
+
+	if (stm32x_info-&gt;ppage_size == 2)
+	{
+		/* high density flash */
+
+		/* bit 7 controls sector 62 - 255 protection */
+		if (last &gt; 61)
+		{
+			if (set)
+				prot_reg[3] &amp;= ~(1 &lt;&lt; 7);
+			else
+				prot_reg[3] |= (1 &lt;&lt; 7);
+		}
+
+		if (first &gt; 61)
+			first = 62;
+		if (last &gt; 61)
+			last = 61;
+
+		for (i = first; i &lt;= last; i++)
+		{
+			reg = (i / stm32x_info-&gt;ppage_size) / 8;
+			bit = (i / stm32x_info-&gt;ppage_size) - (reg * 8);
+
+			if (set)
+				prot_reg[reg] &amp;= ~(1 &lt;&lt; bit);
+			else
+				prot_reg[reg] |= (1 &lt;&lt; bit);
+		}
+	}
+	else
+	{
+		/* medium density flash */
+		for (i = first; i &lt;= last; i++)
+		{
+			reg = (i / stm32x_info-&gt;ppage_size) / 8;
+			bit = (i / stm32x_info-&gt;ppage_size) - (reg * 8);
+
+			if (set)
+				prot_reg[reg] &amp;= ~(1 &lt;&lt; bit);
+			else
+				prot_reg[reg] |= (1 &lt;&lt; bit);
+		}
+	}
+
+	if ((status = stm32x_erase_options(bank)) != ERROR_OK)
+		return status;
+
+	stm32x_info-&gt;option_bytes.protection[0] = prot_reg[0];
+	stm32x_info-&gt;option_bytes.protection[1] = prot_reg[1];
+	stm32x_info-&gt;option_bytes.protection[2] = prot_reg[2];
+	stm32x_info-&gt;option_bytes.protection[3] = prot_reg[3];
+
+	return stm32x_write_options(bank);
+}
+
+static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+	struct target *target = bank-&gt;target;
+	uint32_t buffer_size = 16384;
+	struct working_area *source;
+	uint32_t address = bank-&gt;base + offset;
+	struct reg_param reg_params[4];
+	struct armv7m_algorithm armv7m_info;
+	int retval = ERROR_OK;
+
+	/* see contib/loaders/flash/stm32x.s for src */
+
+	static const uint8_t stm32x_flash_write_code[] = {
+									/* #define STM32_FLASH_CR_OFFSET	0x10 */
+									/* #define STM32_FLASH_SR_OFFSET	0x0C */
+									/* write: */
+		0x08, 0x4c,					/* ldr	r4, STM32_FLASH_BASE */
+		0x1c, 0x44,					/* add	r4, r3 */
+									/* write_half_word: */
+		0x01, 0x23,					/* movs	r3, #0x01 */
+		0x23, 0x61,					/* str	r3, [r4, #STM32_FLASH_CR_OFFSET] */
+		0x30, 0xf8, 0x02, 0x3b,		/* ldrh	r3, [r0], #0x02 */
+		0x21, 0xf8, 0x02, 0x3b,		/* strh	r3, [r1], #0x02 */
+									/* busy: */
+		0xe3, 0x68,					/* ldr	r3, [r4, #STM32_FLASH_SR_OFFSET] */
+		0x13, 0xf0, 0x01, 0x0f,		/* tst	r3, #0x01 */
+		0xfb, 0xd0,					/* beq	busy */
+		0x13, 0xf0, 0x14, 0x0f,		/* tst	r3, #0x14 */
+		0x01, 0xd1,					/* bne	exit */
+		0x01, 0x3a,					/* subs	r2, r2, #0x01 */
+		0xf0, 0xd1,					/* bne	write_half_word */
+									/* exit: */
+		0x00, 0xbe,					/* bkpt	#0x00 */
+		0x00, 0x20, 0x02, 0x40,		/* STM32_FLASH_BASE: .word 0x40022000 */
+	};
+
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(stm32x_flash_write_code),
+			&amp;stm32x_info-&gt;write_algorithm) != ERROR_OK)
+	{
+		LOG_WARNING(&quot;no working area available, can't do block memory writes&quot;);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+
+	if ((retval = target_write_buffer(target, stm32x_info-&gt;write_algorithm-&gt;address,
+			sizeof(stm32x_flash_write_code),
+			(uint8_t*)stm32x_flash_write_code)) != ERROR_OK)
+		return retval;
+
+	/* memory buffer */
+	while (target_alloc_working_area_try(target, buffer_size, &amp;source) != ERROR_OK)
+	{
+		buffer_size /= 2;
+		if (buffer_size &lt;= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
+			if (stm32x_info-&gt;write_algorithm)
+				target_free_working_area(target, stm32x_info-&gt;write_algorithm);
+
+			LOG_WARNING(&quot;no large enough working area available, can't do block memory writes&quot;);
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	};
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARMV7M_MODE_ANY;
+
+	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT);
+	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT);
+	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT);
+	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_IN_OUT);
+
+	while (count &gt; 0)
+	{
+		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ?
+				(buffer_size / 2) : count;
+
+		if ((retval = target_write_buffer(target, source-&gt;address,
+				thisrun_count * 2, buffer)) != ERROR_OK)
+			break;
+
+		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
+		buf_set_u32(reg_params[1].value, 0, 32, address);
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+		buf_set_u32(reg_params[3].value, 0, 32, stm32x_info-&gt;register_offset);
+
+		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
+				stm32x_info-&gt;write_algorithm-&gt;address,
+				0,
+				10000, &amp;armv7m_info)) != ERROR_OK)
+		{
+			LOG_ERROR(&quot;error executing stm32x flash write algorithm&quot;);
+			break;
+		}
+
+		if (buf_get_u32(reg_params[3].value, 0, 32) &amp; FLASH_PGERR)
+		{
+			LOG_ERROR(&quot;flash memory not erased before writing&quot;);
+			/* Clear but report errors */
+			target_write_u32(target, STM32_FLASH_SR, FLASH_PGERR);
+			retval = ERROR_FAIL;
+			break;
+		}
+
+		if (buf_get_u32(reg_params[3].value, 0, 32) &amp; FLASH_WRPRTERR)
+		{
+			LOG_ERROR(&quot;flash memory write protected&quot;);
+			/* Clear but report errors */
+			target_write_u32(target, STM32_FLASH_SR, FLASH_WRPRTERR);
+			retval = ERROR_FAIL;
+			break;
+		}
+
+		buffer += thisrun_count * 2;
+		address += thisrun_count * 2;
+		count -= thisrun_count;
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, stm32x_info-&gt;write_algorithm);
+
+	destroy_reg_param(&amp;reg_params[0]);
+	destroy_reg_param(&amp;reg_params[1]);
+	destroy_reg_param(&amp;reg_params[2]);
+	destroy_reg_param(&amp;reg_params[3]);
+
+	return retval;
+}
+
+static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank-&gt;target;
+	uint32_t words_remaining = (count / 2);
+	uint32_t bytes_remaining = (count &amp; 0x00000001);
+	uint32_t address = bank-&gt;base + offset;
+	uint32_t bytes_written = 0;
+	int retval;
+
+	if (bank-&gt;target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset &amp; 0x1)
+	{
+		LOG_WARNING(&quot;offset 0x%&quot; PRIx32 &quot; breaks required 2-byte alignment&quot;, offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	/* unlock flash registers */
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* multiple half words (2-byte) to be programmed? */
+	if (words_remaining &gt; 0)
+	{
+		/* try using a block write */
+		if ((retval = stm32x_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
+		{
+			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+			{
+				/* if block write failed (no sufficient working area),
+				 * we use normal (slow) single dword accesses */
+				LOG_WARNING(&quot;couldn't use block writes, falling back to single memory accesses&quot;);
+			}
+		}
+		else
+		{
+			buffer += words_remaining * 2;
+			address += words_remaining * 2;
+			words_remaining = 0;
+		}
+	}
+
+	if ((retval != ERROR_OK) &amp;&amp; (retval != ERROR_TARGET_RESOURCE_NOT_AVAILABLE))
+		return retval;
+
+	while (words_remaining &gt; 0)
+	{
+		uint16_t value;
+		memcpy(&amp;value, buffer + bytes_written, sizeof(uint16_t));
+
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PG);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u16(target, address, value);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, 5);
+		if (retval != ERROR_OK)
+			return retval;
+
+		bytes_written += 2;
+		words_remaining--;
+		address += 2;
+	}
+
+	if (bytes_remaining)
+	{
+		uint16_t value = 0xffff;
+		memcpy(&amp;value, buffer + bytes_written, bytes_remaining);
+
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PG);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u16(target, address, value);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, 5);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
+}
+
+static int stm32x_probe(struct flash_bank *bank)
+{
+	struct target *target = bank-&gt;target;
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+	int i;
+	uint16_t num_pages;
+	uint32_t device_id;
+	int page_size;
+	uint32_t base_address = 0x08000000;
+
+	stm32x_info-&gt;probed = 0;
+	stm32x_info-&gt;register_offset = FLASH_OFFSET_B0;
+
+	/* read stm32 device id register */
+	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
+	if (retval != ERROR_OK)
+		return retval;
+	LOG_INFO(&quot;device id = 0x%08&quot; PRIx32 &quot;&quot;, device_id);
+
+	/* get flash size from target. */
+	retval = target_read_u16(target, 0x1FFFF7E0, &amp;num_pages);
+	if (retval != ERROR_OK)
+	{
+		LOG_WARNING(&quot;failed reading flash size, default to max target family&quot;);
+		/* failed reading flash size, default to max target family */
+		num_pages = 0xffff;
+	}
+
+	if ((device_id &amp; 0x7ff) == 0x410)
+	{
+		/* medium density - we have 1k pages
+		 * 4 pages for a protection area */
+		page_size = 1024;
+		stm32x_info-&gt;ppage_size = 4;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors incorrect on revA */
+			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 128k flash&quot;);
+			num_pages = 128;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x412)
+	{
+		/* low density - we have 1k pages
+		 * 4 pages for a protection area */
+		page_size = 1024;
+		stm32x_info-&gt;ppage_size = 4;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors incorrect on revA */
+			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 32k flash&quot;);
+			num_pages = 32;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x414)
+	{
+		/* high density - we have 2k pages
+		 * 2 pages for a protection area */
+		page_size = 2048;
+		stm32x_info-&gt;ppage_size = 2;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors incorrect on revZ */
+			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 512k flash&quot;);
+			num_pages = 512;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x418)
+	{
+		/* connectivity line density - we have 2k pages
+		 * 2 pages for a protection area */
+		page_size = 2048;
+		stm32x_info-&gt;ppage_size = 2;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors incorrect on revZ */
+			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 256k flash&quot;);
+			num_pages = 256;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x420)
+	{
+		/* value line density - we have 1k pages
+		 * 4 pages for a protection area */
+		page_size = 1024;
+		stm32x_info-&gt;ppage_size = 4;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors may be incorrrect on early silicon */
+			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 128k flash&quot;);
+			num_pages = 128;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x430)
+	{
+		/* xl line density - we have 2k pages
+		 * 2 pages for a protection area */
+		page_size = 2048;
+		stm32x_info-&gt;ppage_size = 2;
+		stm32x_info-&gt;has_dual_banks = true;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors may be incorrrect on early silicon */
+			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 1024k flash&quot;);
+			num_pages = 1024;
+		}
+
+		/* split reported size into matching bank */
+		if (bank-&gt;base != 0x08080000)
+		{
+			/* bank 0 will be fixed 512k */
+			num_pages = 512;
+		}
+		else
+		{
+			num_pages -= 512;
+			/* bank1 also uses a register offset */
+			stm32x_info-&gt;register_offset = FLASH_OFFSET_B1;
+			base_address = 0x08080000;
+		}
+	}
+	else
+	{
+		LOG_WARNING(&quot;Cannot identify target as a STM32 family.&quot;);
+		return ERROR_FAIL;
+	}
+
+	LOG_INFO(&quot;flash size = %dkbytes&quot;, num_pages);
+
+	/* calculate numbers of pages */
+	num_pages /= (page_size / 1024);
+
+	if (bank-&gt;sectors)
+	{
+		free(bank-&gt;sectors);
+		bank-&gt;sectors = NULL;
+	}
+
+	bank-&gt;base = base_address;
+	bank-&gt;size = (num_pages * page_size);
+	bank-&gt;num_sectors = num_pages;
+	bank-&gt;sectors = malloc(sizeof(struct flash_sector) * num_pages);
+
+	for (i = 0; i &lt; num_pages; i++)
+	{
+		bank-&gt;sectors[i].offset = i * page_size;
+		bank-&gt;sectors[i].size = page_size;
+		bank-&gt;sectors[i].is_erased = -1;
+		bank-&gt;sectors[i].is_protected = 1;
+	}
+
+	stm32x_info-&gt;probed = 1;
+
+	return ERROR_OK;
+}
+
+static int stm32x_auto_probe(struct flash_bank *bank)
+{
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+	if (stm32x_info-&gt;probed)
+		return ERROR_OK;
+	return stm32x_probe(bank);
+}
+
+#if 0
+COMMAND_HANDLER(stm32x_handle_part_id_command)
+{
+	return ERROR_OK;
+}
+#endif
+
+static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct target *target = bank-&gt;target;
+	uint32_t device_id;
+	int printed;
+
+	/* read stm32 device id register */
+	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((device_id &amp; 0x7ff) == 0x410)
+	{
+		printed = snprintf(buf, buf_size, &quot;stm32x (Medium Density) - Rev: &quot;);
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id &gt;&gt; 16)
+		{
+			case 0x0000:
+				snprintf(buf, buf_size, &quot;A&quot;);
+				break;
+
+			case 0x2000:
+				snprintf(buf, buf_size, &quot;B&quot;);
+				break;
+
+			case 0x2001:
+				snprintf(buf, buf_size, &quot;Z&quot;);
+				break;
+
+			case 0x2003:
+				snprintf(buf, buf_size, &quot;Y&quot;);
+				break;
+
+			default:
+				snprintf(buf, buf_size, &quot;unknown&quot;);
+				break;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x412)
+	{
+		printed = snprintf(buf, buf_size, &quot;stm32x (Low Density) - Rev: &quot;);
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id &gt;&gt; 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, &quot;A&quot;);
+				break;
+
+			default:
+				snprintf(buf, buf_size, &quot;unknown&quot;);
+				break;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x414)
+	{
+		printed = snprintf(buf, buf_size, &quot;stm32x (High Density) - Rev: &quot;);
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id &gt;&gt; 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, &quot;A&quot;);
+				break;
+
+			case 0x1001:
+				snprintf(buf, buf_size, &quot;Z&quot;);
+				break;
+
+			default:
+				snprintf(buf, buf_size, &quot;unknown&quot;);
+				break;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x418)
+	{
+		printed = snprintf(buf, buf_size, &quot;stm32x (Connectivity) - Rev: &quot;);
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id &gt;&gt; 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, &quot;A&quot;);
+				break;
+
+			case 0x1001:
+				snprintf(buf, buf_size, &quot;Z&quot;);
+				break;
+
+			default:
+				snprintf(buf, buf_size, &quot;unknown&quot;);
+				break;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x420)
+	{
+		printed = snprintf(buf, buf_size, &quot;stm32x (Value) - Rev: &quot;);
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id &gt;&gt; 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, &quot;A&quot;);
+				break;
+
+			case 0x1001:
+				snprintf(buf, buf_size, &quot;Z&quot;);
+				break;
+
+			default:
+				snprintf(buf, buf_size, &quot;unknown&quot;);
+				break;
+		}
+	}
+	else if ((device_id &amp; 0x7ff) == 0x430)
+	{
+		printed = snprintf(buf, buf_size, &quot;stm32x (XL) - Rev: &quot;);
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id &gt;&gt; 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, &quot;A&quot;);
+				break;
+
+			default:
+				snprintf(buf, buf_size, &quot;unknown&quot;);
+				break;
+		}
+	}
+	else
+	{
+		snprintf(buf, buf_size, &quot;Cannot identify target as a stm32x\n&quot;);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(stm32x_handle_lock_command)
+{
+	struct target *target = NULL;
+	struct stm32x_flash_bank *stm32x_info = NULL;
+
+	if (CMD_ARGC &lt; 1)
+	{
+		command_print(CMD_CTX, &quot;stm32x lock &lt;bank&gt;&quot;);
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	stm32x_info = bank-&gt;driver_priv;
+
+	target = bank-&gt;target;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (stm32x_erase_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;stm32x failed to erase options&quot;);
+		return ERROR_OK;
+	}
+
+	/* set readout protection */
+	stm32x_info-&gt;option_bytes.RDP = 0;
+
+	if (stm32x_write_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;stm32x failed to lock device&quot;);
+		return ERROR_OK;
+	}
+
+	command_print(CMD_CTX, &quot;stm32x locked&quot;);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(stm32x_handle_unlock_command)
+{
+	struct target *target = NULL;
+
+	if (CMD_ARGC &lt; 1)
+	{
+		command_print(CMD_CTX, &quot;stm32x unlock &lt;bank&gt;&quot;);
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	target = bank-&gt;target;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (stm32x_erase_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;stm32x failed to unlock device&quot;);
+		return ERROR_OK;
+	}
+
+	if (stm32x_write_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;stm32x failed to lock device&quot;);
+		return ERROR_OK;
+	}
+
+	command_print(CMD_CTX, &quot;stm32x unlocked.\n&quot;
+			&quot;INFO: a reset or power cycle is required &quot;
+			&quot;for the new settings to take effect.&quot;);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(stm32x_handle_options_read_command)
+{
+	uint32_t optionbyte;
+	struct target *target = NULL;
+	struct stm32x_flash_bank *stm32x_info = NULL;
+
+	if (CMD_ARGC &lt; 1)
+	{
+		command_print(CMD_CTX, &quot;stm32x options_read &lt;bank&gt;&quot;);
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	stm32x_info = bank-&gt;driver_priv;
+
+	target = bank-&gt;target;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = target_read_u32(target, STM32_FLASH_OBR, &amp;optionbyte);
+	if (retval != ERROR_OK)
+		return retval;
+	command_print(CMD_CTX, &quot;Option Byte: 0x%&quot; PRIx32 &quot;&quot;, optionbyte);
+
+	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_ERROR, 1))
+		command_print(CMD_CTX, &quot;Option Byte Complement Error&quot;);
+
+	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_READOUT, 1))
+		command_print(CMD_CTX, &quot;Readout Protection On&quot;);
+	else
+		command_print(CMD_CTX, &quot;Readout Protection Off&quot;);
+
+	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_RDWDGSW, 1))
+		command_print(CMD_CTX, &quot;Software Watchdog&quot;);
+	else
+		command_print(CMD_CTX, &quot;Hardware Watchdog&quot;);
+
+	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_RDRSTSTOP, 1))
+		command_print(CMD_CTX, &quot;Stop: No reset generated&quot;);
+	else
+		command_print(CMD_CTX, &quot;Stop: Reset generated&quot;);
+
+	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_RDRSTSTDBY, 1))
+		command_print(CMD_CTX, &quot;Standby: No reset generated&quot;);
+	else
+		command_print(CMD_CTX, &quot;Standby: Reset generated&quot;);
+
+	if (stm32x_info-&gt;has_dual_banks)
+	{
+		if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_BFB2, 1))
+			command_print(CMD_CTX, &quot;Boot: Bank 0&quot;);
+		else
+			command_print(CMD_CTX, &quot;Boot: Bank 1&quot;);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(stm32x_handle_options_write_command)
+{
+	struct target *target = NULL;
+	struct stm32x_flash_bank *stm32x_info = NULL;
+	uint16_t optionbyte = 0xF8;
+
+	if (CMD_ARGC &lt; 4)
+	{
+		command_print(CMD_CTX, &quot;stm32x options_write &lt;bank&gt; &lt;SWWDG | HWWDG&gt; &quot;
+				&quot;&lt;RSTSTNDBY | NORSTSTNDBY&gt; &lt;RSTSTOP | NORSTSTOP&gt; &lt;BOOT0 | BOOT1&gt;&quot;);
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	stm32x_info = bank-&gt;driver_priv;
+
+	target = bank-&gt;target;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = stm32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	/* REVISIT: ignores some options which we will display...
+	 * and doesn't insist on the specified syntax.
+	 */
+
+	/* OPT_RDWDGSW */
+	if (strcmp(CMD_ARGV[1], &quot;SWWDG&quot;) == 0)
+	{
+		optionbyte |= (1 &lt;&lt; 0);
+	}
+	else	/* REVISIT must be &quot;HWWDG&quot; then ... */
+	{
+		optionbyte &amp;= ~(1 &lt;&lt; 0);
+	}
+
+	/* OPT_RDRSTSTOP */
+	if (strcmp(CMD_ARGV[2], &quot;NORSTSTOP&quot;) == 0)
+	{
+		optionbyte |= (1 &lt;&lt; 1);
+	}
+	else	/* REVISIT must be &quot;RSTSTNDBY&quot; then ... */
+	{
+		optionbyte &amp;= ~(1 &lt;&lt; 1);
+	}
+
+	/* OPT_RDRSTSTDBY */
+	if (strcmp(CMD_ARGV[3], &quot;NORSTSTNDBY&quot;) == 0)
+	{
+		optionbyte |= (1 &lt;&lt; 2);
+	}
+	else	/* REVISIT must be &quot;RSTSTOP&quot; then ... */
+	{
+		optionbyte &amp;= ~(1 &lt;&lt; 2);
+	}
+
+	if (CMD_ARGC &gt; 4 &amp;&amp; stm32x_info-&gt;has_dual_banks)
+	{
+		/* OPT_BFB2 */
+		if (strcmp(CMD_ARGV[4], &quot;BOOT0&quot;) == 0)
+		{
+			optionbyte |= (1 &lt;&lt; 3);
+		}
+		else
+		{
+			optionbyte &amp;= ~(1 &lt;&lt; 3);
+		}
+	}
+
+	if (stm32x_erase_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;stm32x failed to erase options&quot;);
+		return ERROR_OK;
+	}
+
+	stm32x_info-&gt;option_bytes.user_options = optionbyte;
+
+	if (stm32x_write_options(bank) != ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;stm32x failed to write options&quot;);
+		return ERROR_OK;
+	}
+
+	command_print(CMD_CTX, &quot;stm32x write options complete.\n&quot;
+				&quot;INFO: a reset or power cycle is required &quot;
+				&quot;for the new settings to take effect.&quot;);
+
+	return ERROR_OK;
+}
+
+static int stm32x_mass_erase(struct flash_bank *bank)
+{
+	struct target *target = bank-&gt;target;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* unlock option flash registers */
+	int retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* mass erase flash memory */
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER | FLASH_STRT);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32x_wait_status_busy(bank, 100);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(stm32x_handle_mass_erase_command)
+{
+	int i;
+
+	if (CMD_ARGC &lt; 1)
+	{
+		command_print(CMD_CTX, &quot;stm32x mass_erase &lt;bank&gt;&quot;);
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = stm32x_mass_erase(bank);
+	if (retval == ERROR_OK)
+	{
+		/* set all sectors as erased */
+		for (i = 0; i &lt; bank-&gt;num_sectors; i++)
+		{
+			bank-&gt;sectors[i].is_erased = 1;
+		}
+
+		command_print(CMD_CTX, &quot;stm32x mass erase complete&quot;);
+	}
+	else
+	{
+		command_print(CMD_CTX, &quot;stm32x mass erase failed&quot;);
+	}
+
+	return retval;
+}
+
+static const struct command_registration stm32x_exec_command_handlers[] = {
+	{
+		.name = &quot;lock&quot;,
+		.handler = stm32x_handle_lock_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;bank_id&quot;,
+		.help = &quot;Lock entire flash device.&quot;,
+	},
+	{
+		.name = &quot;unlock&quot;,
+		.handler = stm32x_handle_unlock_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;bank_id&quot;,
+		.help = &quot;Unlock entire protected flash device.&quot;,
+	},
+	{
+		.name = &quot;mass_erase&quot;,
+		.handler = stm32x_handle_mass_erase_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;bank_id&quot;,
+		.help = &quot;Erase entire flash device.&quot;,
+	},
+	{
+		.name = &quot;options_read&quot;,
+		.handler = stm32x_handle_options_read_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;bank_id&quot;,
+		.help = &quot;Read and display device option byte.&quot;,
+	},
+	{
+		.name = &quot;options_write&quot;,
+		.handler = stm32x_handle_options_write_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;bank_id ('SWWDG'|'HWWDG') &quot;
+			&quot;('RSTSTNDBY'|'NORSTSTNDBY') &quot;
+			&quot;('RSTSTOP'|'NORSTSTOP')&quot;,
+		.help = &quot;Replace bits in device option byte.&quot;,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration stm32x_command_handlers[] = {
+	{
+		.name = &quot;stm32f1x&quot;,
+		.mode = COMMAND_ANY,
+		.help = &quot;stm32f1x flash command group&quot;,
+		.chain = stm32x_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver stm32f1x_flash = {
+	.name = &quot;stm32f1x&quot;,
+	.commands = stm32x_command_handlers,
+	.flash_bank_command = stm32x_flash_bank_command,
+	.erase = stm32x_erase,
+	.protect = stm32x_protect,
+	.write = stm32x_write,
+	.read = default_flash_read,
+	.probe = stm32x_probe,
+	.auto_probe = stm32x_auto_probe,
+	.erase_check = default_flash_mem_blank_check,
+	.protect_check = stm32x_protect_check,
+	.info = get_stm32x_info,
+};
diff --git a/src/flash/nor/stm32f2x.c b/src/flash/nor/stm32f2x.c
new file mode 100644
index 0000000..c2f586a
--- /dev/null
+++ b/src/flash/nor/stm32f2x.c
@@ -0,0 +1,706 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">Dominic.Rath at gmx.de</A>                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">spen at spen-soft.co.uk</A>                                                  *
+ *                                                                         *
+ *   Copyright (C) 2011 &#195;&#152;yvind Harboe                                      *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">oyvind.harboe at zylin.com</A>                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;imp.h&quot;
+#include &lt;helper/binarybuffer.h&gt;
+#include &lt;target/algorithm.h&gt;
+#include &lt;target/armv7m.h&gt;
+
+/* Regarding performance:
+ *
+ * Short story - it might be best to leave the performance at
+ * current levels.
+ *
+ * You may see a jump in speed if you change to using
+ * 32bit words for the block programming.
+ *
+ * Its a shame you cannot use the double word as its
+ * even faster - but you require external VPP for that mode.
+ *
+ * Having said all that 16bit writes give us the widest vdd
+ * operating range, so may be worth adding a note to that effect.
+ *
+ */
+
+/* Danger!!!! The STM32F1x and STM32F2x series actually have
+ * quite different flash controllers.
+ *
+ * What's more scary is that the names of the registers and their
+ * addresses are the same, but the actual bits and what they do are
+ * can be very different.
+ *
+ * To reduce testing complexity and dangers of regressions,
+ * a seperate file is used for stm32fx2x.
+ *
+ * 1mByte part with 4 x 16, 1 x 64, 7 x 128kBytes sectors
+ *
+ * What's the protection page size???
+ *
+ * Tested with STM3220F-EVAL board.
+ *
+ * STM32F21xx series for reference.
+ *
+ * RM0033
+ * <A HREF="http://www.st.com/internet/mcu/product/250192.jsp">http://www.st.com/internet/mcu/product/250192.jsp</A>
+ *
+ * PM0059
+ * www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/PROGRAMMING_MANUAL/CD00233952.pdf
+ *
+ * STM32F1x series - notice that this code was copy, pasted and knocked
+ * into a stm32f2x driver, so in case something has been converted or
+ * bugs haven't been fixed, here are the original manuals:
+ *
+ * RM0008 - Reference manual
+ *
+ * RM0042, the Flash programming manual for low-, medium- high-density and
+ * connectivity line STM32F10x devices
+ *
+ * PM0068, the Flash programming manual for XL-density STM32F10x devices.
+ *
+ */
+
+ // Erase time can be as high as 1000ms, 10x this and it's toast...
+#define FLASH_ERASE_TIMEOUT 10000
+#define FLASH_WRITE_TIMEOUT 5
+
+
+#define STM32_FLASH_BASE	0x40023c00
+#define STM32_FLASH_ACR		0x40023c00
+#define STM32_FLASH_KEYR	0x40023c04
+#define STM32_FLASH_OPTKEYR	0x40023c08
+#define STM32_FLASH_SR		0x40023c0C
+#define STM32_FLASH_CR		0x40023c10
+#define STM32_FLASH_OPTCR	0x40023c14
+#define STM32_FLASH_OBR		0x40023c1C
+
+
+
+/* option byte location */
+
+#define STM32_OB_RDP		0x1FFFF800
+#define STM32_OB_USER		0x1FFFF802
+#define STM32_OB_DATA0		0x1FFFF804
+#define STM32_OB_DATA1		0x1FFFF806
+#define STM32_OB_WRP0		0x1FFFF808
+#define STM32_OB_WRP1		0x1FFFF80A
+#define STM32_OB_WRP2		0x1FFFF80C
+#define STM32_OB_WRP3		0x1FFFF80E
+
+/* FLASH_CR register bits */
+
+#define FLASH_PG		(1 &lt;&lt; 0)
+#define FLASH_SER		(1 &lt;&lt; 1)
+#define FLASH_MER		(1 &lt;&lt; 2)
+#define FLASH_STRT		(1 &lt;&lt; 16)
+#define FLASH_PSIZE_8	(0 &lt;&lt; 8)
+#define FLASH_PSIZE_16	(1 &lt;&lt; 8)
+#define FLASH_PSIZE_32	(2 &lt;&lt; 8)
+#define FLASH_PSIZE_64	(3 &lt;&lt; 8)
+#define FLASH_SNB(a) 	((a) &lt;&lt; 3)
+#define FLASH_LOCK		(1 &lt;&lt; 31)
+
+/* FLASH_SR register bits */
+
+#define FLASH_BSY		(1 &lt;&lt; 16)
+#define FLASH_PGSERR	(1 &lt;&lt; 7) // Programming sequence error
+#define FLASH_PGPERR	(1 &lt;&lt; 6) // Programming parallelism error
+#define FLASH_PGAERR	(1 &lt;&lt; 5) // Programming alignment error
+#define FLASH_WRPERR	(1 &lt;&lt; 4) // Write protection error
+#define FLASH_OPERR		(1 &lt;&lt; 1) // Operation error
+
+#define FLASH_ERROR (FLASH_PGSERR | FLASH_PGPERR | FLASH_PGAERR| FLASH_WRPERR| FLASH_OPERR)
+
+/* STM32_FLASH_OBR bit definitions (reading) */
+
+#define OPT_ERROR		0
+#define OPT_READOUT		1
+#define OPT_RDWDGSW		2
+#define OPT_RDRSTSTOP	3
+#define OPT_RDRSTSTDBY	4
+#define OPT_BFB2		5	/* dual flash bank only */
+
+/* register unlock keys */
+
+#define KEY1			0x45670123
+#define KEY2			0xCDEF89AB
+
+struct stm32x_flash_bank
+{
+	struct working_area *write_algorithm;
+	int probed;
+};
+
+
+/* flash bank stm32x &lt;base&gt; &lt;size&gt; 0 0 &lt;target#&gt;
+ */
+FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
+{
+	struct stm32x_flash_bank *stm32x_info;
+
+	if (CMD_ARGC &lt; 6)
+	{
+		LOG_WARNING(&quot;incomplete flash_bank stm32x configuration&quot;);
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	stm32x_info = malloc(sizeof(struct stm32x_flash_bank));
+	bank-&gt;driver_priv = stm32x_info;
+
+	stm32x_info-&gt;write_algorithm = NULL;
+	stm32x_info-&gt;probed = 0;
+
+	return ERROR_OK;
+}
+
+static inline int stm32x_get_flash_reg(struct flash_bank *bank, uint32_t reg)
+{
+	return reg;
+}
+
+static inline int stm32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
+{
+	struct target *target = bank-&gt;target;
+	return target_read_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR), status);
+}
+
+static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
+{
+	struct target *target = bank-&gt;target;
+	uint32_t status;
+	int retval = ERROR_OK;
+
+	/* wait for busy to clear */
+	for (;;)
+	{
+		retval = stm32x_get_flash_status(bank, &amp;status);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG(&quot;status: 0x%&quot; PRIx32 &quot;&quot;, status);
+		if ((status &amp; FLASH_BSY) == 0)
+			break;
+		if (timeout-- &lt;= 0)
+		{
+			LOG_ERROR(&quot;timed out waiting for flash&quot;);
+			return ERROR_FAIL;
+		}
+		alive_sleep(1);
+	}
+
+
+	if (status &amp; FLASH_WRPERR)
+	{
+		LOG_ERROR(&quot;stm32x device protected&quot;);
+		retval = ERROR_FAIL;
+	}
+
+	/* Clear but report errors */
+	if (status &amp; FLASH_ERROR)
+	{
+		/* If this operation fails, we ignore it and report the original
+		 * retval
+		 */
+		target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR),
+				status &amp; FLASH_ERROR);
+	}
+	return retval;
+}
+
+static int stm32x_unlock_reg(struct target *target)
+{
+	/* unlock flash registers */
+	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+	return ERROR_OK;
+}
+
+static int stm32x_protect_check(struct flash_bank *bank)
+{
+	return ERROR_OK;
+}
+
+static int stm32x_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank-&gt;target;
+	int i;
+
+	if (bank-&gt;target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	int retval;
+	retval = stm32x_unlock_reg(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	Sector Erase
+	To erase a sector, follow the procedure below:
+	1. Check that no Flash memory operation is ongoing by checking the BSY bit in the
+	  FLASH_SR register
+	2. Set the SER bit and select the sector (out of the 12 sectors in the main memory block)
+	  you wish to erase (SNB) in the FLASH_CR register
+	3. Set the STRT bit in the FLASH_CR register
+	4. Wait for the BSY bit to be cleared
+	 */
+
+	for (i = first; i &lt;= last; i++)
+	{
+		retval = target_write_u32(target,
+				stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_SER | FLASH_SNB(i) | FLASH_STRT);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
+		if (retval != ERROR_OK)
+			return retval;
+
+		bank-&gt;sectors[i].is_erased = 1;
+	}
+
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	return ERROR_OK;
+}
+
+static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+	struct target *target = bank-&gt;target;
+	uint32_t buffer_size = 16384;
+	struct working_area *source;
+	uint32_t address = bank-&gt;base + offset;
+	struct reg_param reg_params[5];
+	struct armv7m_algorithm armv7m_info;
+	int retval = ERROR_OK;
+
+	/* see contib/loaders/flash/stm32x.s for src */
+
+	static const uint16_t stm32x_flash_write_code_16[] = {
+//	00000000 &lt;write&gt;:
+	   0x4b07, //     	ldr	r3, [pc, #28]	(20 &lt;STM32_PROG16&gt;)
+	   0x6123,  //    	str	r3, [r4, #16]
+       0xf830, 0x3b02, 	//ldrh.w	r3, [r0], #2
+       0xf821, 0x3b02, 	//strh.w	r3, [r1], #2
+
+	//0000000c &lt;busy&gt;:
+	0x68e3,      	//ldr	r3, [r4, #12]
+0xf413, 0x3f80, // 	tst.w	r3, #65536	; 0x10000
+0xd0fb,      	//beq.n	c &lt;busy&gt;
+0xf013, 0x0ff0, 	//tst.w	r3, #240	; 0xf0
+0xd101,      	//bne.n	1e &lt;exit&gt;
+0x3a01,      	//subs	r2, #1
+0xd1f0,      	//bne.n	0 &lt;write&gt;
+	            	   	//0000001e &lt;exit&gt;:
+	0xbe00, //      	bkpt	0x0000
+
+	//00000020 &lt;STM32_PROG16&gt;:
+	0x0101, 0x0000, // 	.word	0x00000101
+
+	};
+
+	// Flip endian
+	uint8_t stm32x_flash_write_code[sizeof(stm32x_flash_write_code_16)*2];
+	for (unsigned i = 0; i &lt; sizeof(stm32x_flash_write_code_16) / 2; i++)
+	{
+		stm32x_flash_write_code[i*2 + 0] = stm32x_flash_write_code_16[i] &amp; 0xff;
+		stm32x_flash_write_code[i*2 + 1] = (stm32x_flash_write_code_16[i] &gt;&gt; 8) &amp; 0xff;
+	}
+
+	if (target_alloc_working_area(target, sizeof(stm32x_flash_write_code),
+			&amp;stm32x_info-&gt;write_algorithm) != ERROR_OK)
+	{
+		LOG_WARNING(&quot;no working area available, can't do block memory writes&quot;);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+
+	if ((retval = target_write_buffer(target, stm32x_info-&gt;write_algorithm-&gt;address,
+			sizeof(stm32x_flash_write_code),
+			(uint8_t*)stm32x_flash_write_code)) != ERROR_OK)
+		return retval;
+
+	/* memory buffer */
+	while (target_alloc_working_area_try(target, buffer_size, &amp;source) != ERROR_OK)
+	{
+		buffer_size /= 2;
+		if (buffer_size &lt;= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
+			if (stm32x_info-&gt;write_algorithm)
+				target_free_working_area(target, stm32x_info-&gt;write_algorithm);
+
+			LOG_WARNING(&quot;no large enough working area available, can't do block memory writes&quot;);
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	};
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARMV7M_MODE_ANY;
+
+	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT);
+	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT);
+	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT);
+	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_IN_OUT);
+	init_reg_param(&amp;reg_params[4], &quot;r4&quot;, 32, PARAM_OUT);
+
+	while (count &gt; 0)
+	{
+		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ?
+				(buffer_size / 2) : count;
+
+		if ((retval = target_write_buffer(target, source-&gt;address,
+				thisrun_count * 2, buffer)) != ERROR_OK)
+			break;
+
+		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
+		buf_set_u32(reg_params[1].value, 0, 32, address);
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+		// R3 is a return value only
+		buf_set_u32(reg_params[4].value, 0, 32, STM32_FLASH_BASE);
+
+		if ((retval = target_run_algorithm(target, 0, NULL,
+				sizeof(reg_params) / sizeof(*reg_params),
+				reg_params,
+				stm32x_info-&gt;write_algorithm-&gt;address,
+				0,
+				10000, &amp;armv7m_info)) != ERROR_OK)
+		{
+			LOG_ERROR(&quot;error executing stm32x flash write algorithm&quot;);
+			break;
+		}
+
+		uint32_t error = buf_get_u32(reg_params[3].value, 0, 32) &amp; FLASH_ERROR;
+
+		if (error &amp; FLASH_WRPERR)
+		{
+			LOG_ERROR(&quot;flash memory write protected&quot;);
+		}
+
+		if (error != 0)
+		{
+			LOG_ERROR(&quot;flash write failed = %08x&quot;, error);
+			/* Clear but report errors */
+			target_write_u32(target, STM32_FLASH_SR, error);
+			retval = ERROR_FAIL;
+			break;
+		}
+
+		buffer += thisrun_count * 2;
+		address += thisrun_count * 2;
+		count -= thisrun_count;
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, stm32x_info-&gt;write_algorithm);
+
+	destroy_reg_param(&amp;reg_params[0]);
+	destroy_reg_param(&amp;reg_params[1]);
+	destroy_reg_param(&amp;reg_params[2]);
+	destroy_reg_param(&amp;reg_params[3]);
+	destroy_reg_param(&amp;reg_params[4]);
+
+	return retval;
+}
+
+static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank-&gt;target;
+	uint32_t words_remaining = (count / 2);
+	uint32_t bytes_remaining = (count &amp; 0x00000001);
+	uint32_t address = bank-&gt;base + offset;
+	uint32_t bytes_written = 0;
+	int retval;
+
+	if (bank-&gt;target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset &amp; 0x1)
+	{
+		LOG_WARNING(&quot;offset 0x%&quot; PRIx32 &quot; breaks required 2-byte alignment&quot;, offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	retval = stm32x_unlock_reg(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* multiple half words (2-byte) to be programmed? */
+	if (words_remaining &gt; 0)
+	{
+		/* try using a block write */
+		if ((retval = stm32x_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
+		{
+			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+			{
+				/* if block write failed (no sufficient working area),
+				 * we use normal (slow) single dword accesses */
+				LOG_WARNING(&quot;couldn't use block writes, falling back to single memory accesses&quot;);
+			}
+		}
+		else
+		{
+			buffer += words_remaining * 2;
+			address += words_remaining * 2;
+			words_remaining = 0;
+		}
+	}
+
+	if ((retval != ERROR_OK) &amp;&amp; (retval != ERROR_TARGET_RESOURCE_NOT_AVAILABLE))
+		return retval;
+
+	/*
+	Standard programming
+	The Flash memory programming sequence is as follows:
+	1. Check that no main Flash memory operation is ongoing by checking the BSY bit in the
+	  FLASH_SR register.
+	2. Set the PG bit in the FLASH_CR register
+	3. Perform the data write operation(s) to the desired memory address (inside main
+	  memory block or OTP area):
+	&#226;&#128;&#147; &#226;&#128;&#147; Half-word access in case of x16 parallelism
+	&#226;&#128;&#147; Word access in case of x32 parallelism
+	&#226;&#128;&#147;
+	4.
+	Byte access in case of x8 parallelism
+	Double word access in case of x64 parallelism
+	Wait for the BSY bit to be cleared
+	*/
+	while (words_remaining &gt; 0)
+	{
+		uint16_t value;
+		memcpy(&amp;value, buffer + bytes_written, sizeof(uint16_t));
+
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
+				FLASH_PG | FLASH_PSIZE_16);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = target_write_u16(target, address, value);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, FLASH_WRITE_TIMEOUT);
+		if (retval != ERROR_OK)
+			return retval;
+
+		bytes_written += 2;
+		words_remaining--;
+		address += 2;
+	}
+
+	if (bytes_remaining)
+	{
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
+				FLASH_PG | FLASH_PSIZE_8);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u8(target, address, buffer[bytes_written]);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, FLASH_WRITE_TIMEOUT);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
+}
+
+static void setup_sector(struct flash_bank *bank, int start, int num, int size)
+{
+	for (int i = start; i &lt; (start + num) ; i++)
+	{
+		bank-&gt;sectors[i].offset = bank-&gt;size;
+		bank-&gt;sectors[i].size = size;
+		bank-&gt;size += bank-&gt;sectors[i].size;
+	}
+}
+
+static int stm32x_probe(struct flash_bank *bank)
+{
+	struct target *target = bank-&gt;target;
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+	int i;
+	uint16_t num_pages;
+	uint32_t device_id;
+	uint32_t base_address = 0x08000000;
+
+	stm32x_info-&gt;probed = 0;
+
+	/* read stm32 device id register */
+	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
+	if (retval != ERROR_OK)
+		return retval;
+	LOG_INFO(&quot;device id = 0x%08&quot; PRIx32 &quot;&quot;, device_id);
+
+	if ((device_id &amp; 0x7ff) != 0x411)
+	{
+		LOG_WARNING(&quot;Cannot identify target as a STM32 family, try the other STM32 drivers.&quot;);
+		return ERROR_FAIL;
+	}
+
+	/* sectors sizes vary, handle this in a different code path
+	 * than the rest.
+	 */
+	// Uhhh.... what to use here?
+
+	/* calculate numbers of pages*/
+	num_pages = 4 + 1 + 7;
+
+	if (bank-&gt;sectors)
+	{
+		free(bank-&gt;sectors);
+		bank-&gt;sectors = NULL;
+	}
+
+	bank-&gt;base = base_address;
+	bank-&gt;num_sectors = num_pages;
+	bank-&gt;sectors = malloc(sizeof(struct flash_sector) * num_pages);
+
+	bank-&gt;size = 0;
+	setup_sector(bank, 0, 4, 16 * 1024);
+	setup_sector(bank, 4, 1, 64 * 1024);
+	setup_sector(bank, 4+1, 7, 128 * 1024);
+
+	for (i = 0; i &lt; num_pages; i++)
+	{
+		bank-&gt;sectors[i].is_erased = -1;
+		bank-&gt;sectors[i].is_protected = 0;
+	}
+
+	LOG_INFO(&quot;flash size = %dkBytes&quot;, bank-&gt;size / 1024);
+
+	stm32x_info-&gt;probed = 1;
+
+	return ERROR_OK;
+}
+
+static int stm32x_auto_probe(struct flash_bank *bank)
+{
+	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
+	if (stm32x_info-&gt;probed)
+		return ERROR_OK;
+	return stm32x_probe(bank);
+}
+
+static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct target *target = bank-&gt;target;
+	uint32_t device_id;
+	int printed;
+
+	/* read stm32 device id register */
+	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((device_id &amp; 0x7ff) == 0x411)
+	{
+		printed = snprintf(buf, buf_size, &quot;stm32x (1mByte part) - Rev: &quot;);
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id &gt;&gt; 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, &quot;A&quot;);
+				break;
+
+			case 0x2000:
+				snprintf(buf, buf_size, &quot;B&quot;);
+				break;
+
+			case 0x1001:
+				snprintf(buf, buf_size, &quot;Z&quot;);
+				break;
+
+			case 0x2001:
+				snprintf(buf, buf_size, &quot;Y&quot;);
+				break;
+
+			default:
+				snprintf(buf, buf_size, &quot;unknown&quot;);
+				break;
+		}
+	}
+	else
+	{
+		snprintf(buf, buf_size, &quot;Cannot identify target as a stm32x\n&quot;);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration stm32x_exec_command_handlers[] = {
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration stm32x_command_handlers[] = {
+	{
+		.name = &quot;stm32f2x&quot;,
+		.mode = COMMAND_ANY,
+		.help = &quot;stm32f2x flash command group&quot;,
+		.chain = stm32x_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver stm32f2x_flash = {
+	.name = &quot;stm32f2x&quot;,
+	.commands = stm32x_command_handlers,
+	.flash_bank_command = stm32x_flash_bank_command,
+	.erase = stm32x_erase,
+	.protect = stm32x_protect,
+	.write = stm32x_write,
+	.read = default_flash_read,
+	.probe = stm32x_probe,
+	.auto_probe = stm32x_auto_probe,
+	.erase_check = default_flash_mem_blank_check,
+	.protect_check = stm32x_protect_check,
+	.info = get_stm32x_info,
+};
diff --git a/src/flash/nor/stm32f2xxx.c b/src/flash/nor/stm32f2xxx.c
deleted file mode 100644
index df50e84..0000000
--- a/src/flash/nor/stm32f2xxx.c
+++ /dev/null
@@ -1,707 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   Copyright (C) 2011 &#195;&#152;yvind Harboe                                      *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">oyvind.harboe at zylin.com</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;imp.h&quot;
-#include &lt;helper/binarybuffer.h&gt;
-#include &lt;target/algorithm.h&gt;
-#include &lt;target/armv7m.h&gt;
-
-/* Regarding performance:
- *
- * Short story - it might be best to leave the performance at
- * current levels.
- *
- * You may see a jump in speed if you change to using
- * 32bit words for the block programming.
- *
- * Its a shame you cannot use the double word as its
- * even faster - but you require external VPP for that mode.
- *
- * Having said all that 16bit writes give us the widest vdd
- * operating range, so may be worth adding a note to that effect.
- *
- */
-
-
-/* Danger!!!! The STM32F1xxxx and STM32F2xxxx series actually have
- * quite different flash controllers.
- *
- * What's more scary is that the names of the registers and their
- * addresses are the same, but the actual bits and what they do are
- * can be very different.
- *
- * To reduce testing complexity and dangers of regressions,
- * a seperate file is used for stm32fx2222.
- *
- * 1mByte part with 4 x 16, 1 x 64, 7 x 128kBytes sectors
- *
- * What's the protection page size???
- *
- * Tested with STM3220F-EVAL board.
- *
- * STM32F21xx series for reference.
- *
- * RM0033
- * <A HREF="http://www.st.com/internet/mcu/product/250192.jsp">http://www.st.com/internet/mcu/product/250192.jsp</A>
- *
- * PM0059
- * www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/PROGRAMMING_MANUAL/CD00233952.pdf
- *
- * STM32F1xxx series - notice that this code was copy, pasted and knocked
- * into a stm32f2xxx driver, so in case something has been converted or
- * bugs haven't been fixed, here are the original manuals:
- *
- * RM0008 - Reference manual
- *
- * RM0042, the Flash programming manual for low-, medium- high-density and
- * connectivity line STM32F10xxx devices
- *
- * PM0068, the Flash programming manual for XL-density STM32F10xxx devices.
- *
- */
-
- // Erase time can be as high as 1000ms, 10x this and it's toast...
-#define FLASH_ERASE_TIMEOUT 10000
-#define FLASH_WRITE_TIMEOUT 5
-
-
-#define STM32_FLASH_BASE	0x40023c00
-#define STM32_FLASH_ACR		0x40023c00
-#define STM32_FLASH_KEYR	0x40023c04
-#define STM32_FLASH_OPTKEYR	0x40023c08
-#define STM32_FLASH_SR		0x40023c0C
-#define STM32_FLASH_CR		0x40023c10
-#define STM32_FLASH_OPTCR	0x40023c14
-#define STM32_FLASH_OBR		0x40023c1C
-
-
-
-/* option byte location */
-
-#define STM32_OB_RDP		0x1FFFF800
-#define STM32_OB_USER		0x1FFFF802
-#define STM32_OB_DATA0		0x1FFFF804
-#define STM32_OB_DATA1		0x1FFFF806
-#define STM32_OB_WRP0		0x1FFFF808
-#define STM32_OB_WRP1		0x1FFFF80A
-#define STM32_OB_WRP2		0x1FFFF80C
-#define STM32_OB_WRP3		0x1FFFF80E
-
-/* FLASH_CR register bits */
-
-#define FLASH_PG		(1 &lt;&lt; 0)
-#define FLASH_SER		(1 &lt;&lt; 1)
-#define FLASH_MER		(1 &lt;&lt; 2)
-#define FLASH_STRT		(1 &lt;&lt; 16)
-#define FLASH_PSIZE_8	(0 &lt;&lt; 8)
-#define FLASH_PSIZE_16	(1 &lt;&lt; 8)
-#define FLASH_PSIZE_32	(2 &lt;&lt; 8)
-#define FLASH_PSIZE_64	(3 &lt;&lt; 8)
-#define FLASH_SNB(a) 	((a) &lt;&lt; 3)
-#define FLASH_LOCK		(1 &lt;&lt; 31)
-
-/* FLASH_SR register bits */
-
-#define FLASH_BSY		(1 &lt;&lt; 16)
-#define FLASH_PGSERR	(1 &lt;&lt; 7) // Programming sequence error
-#define FLASH_PGPERR	(1 &lt;&lt; 6) // Programming parallelism error
-#define FLASH_PGAERR	(1 &lt;&lt; 5) // Programming alignment error
-#define FLASH_WRPERR	(1 &lt;&lt; 4) // Write protection error
-#define FLASH_OPERR		(1 &lt;&lt; 1) // Operation error
-
-#define FLASH_ERROR (FLASH_PGSERR | FLASH_PGPERR | FLASH_PGAERR| FLASH_WRPERR| FLASH_OPERR)
-
-/* STM32_FLASH_OBR bit definitions (reading) */
-
-#define OPT_ERROR		0
-#define OPT_READOUT		1
-#define OPT_RDWDGSW		2
-#define OPT_RDRSTSTOP	3
-#define OPT_RDRSTSTDBY	4
-#define OPT_BFB2		5	/* dual flash bank only */
-
-/* register unlock keys */
-
-#define KEY1			0x45670123
-#define KEY2			0xCDEF89AB
-
-struct stm32x_flash_bank
-{
-	struct working_area *write_algorithm;
-	int probed;
-};
-
-
-/* flash bank stm32x &lt;base&gt; &lt;size&gt; 0 0 &lt;target#&gt;
- */
-FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
-{
-	struct stm32x_flash_bank *stm32x_info;
-
-	if (CMD_ARGC &lt; 6)
-	{
-		LOG_WARNING(&quot;incomplete flash_bank stm32x configuration&quot;);
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	stm32x_info = malloc(sizeof(struct stm32x_flash_bank));
-	bank-&gt;driver_priv = stm32x_info;
-
-	stm32x_info-&gt;write_algorithm = NULL;
-	stm32x_info-&gt;probed = 0;
-
-	return ERROR_OK;
-}
-
-static inline int stm32x_get_flash_reg(struct flash_bank *bank, uint32_t reg)
-{
-	return reg;
-}
-
-static inline int stm32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
-{
-	struct target *target = bank-&gt;target;
-	return target_read_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR), status);
-}
-
-static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
-{
-	struct target *target = bank-&gt;target;
-	uint32_t status;
-	int retval = ERROR_OK;
-
-	/* wait for busy to clear */
-	for (;;)
-	{
-		retval = stm32x_get_flash_status(bank, &amp;status);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG(&quot;status: 0x%&quot; PRIx32 &quot;&quot;, status);
-		if ((status &amp; FLASH_BSY) == 0)
-			break;
-		if (timeout-- &lt;= 0)
-		{
-			LOG_ERROR(&quot;timed out waiting for flash&quot;);
-			return ERROR_FAIL;
-		}
-		alive_sleep(1);
-	}
-
-
-	if (status &amp; FLASH_WRPERR)
-	{
-		LOG_ERROR(&quot;stm32x device protected&quot;);
-		retval = ERROR_FAIL;
-	}
-
-	/* Clear but report errors */
-	if (status &amp; FLASH_ERROR)
-	{
-		/* If this operation fails, we ignore it and report the original
-		 * retval
-		 */
-		target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR),
-				status &amp; FLASH_ERROR);
-	}
-	return retval;
-}
-
-static int stm32x_unlock_reg(struct target *target)
-{
-	/* unlock flash registers */
-	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
-	if (retval != ERROR_OK)
-		return retval;
-	return ERROR_OK;
-}
-
-static int stm32x_protect_check(struct flash_bank *bank)
-{
-	return ERROR_OK;
-}
-
-static int stm32x_erase(struct flash_bank *bank, int first, int last)
-{
-	struct target *target = bank-&gt;target;
-	int i;
-
-	if (bank-&gt;target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	int retval;
-	retval = stm32x_unlock_reg(target);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	Sector Erase
-	To erase a sector, follow the procedure below:
-	1. Check that no Flash memory operation is ongoing by checking the BSY bit in the
-	  FLASH_SR register
-	2. Set the SER bit and select the sector (out of the 12 sectors in the main memory block)
-	  you wish to erase (SNB) in the FLASH_CR register
-	3. Set the STRT bit in the FLASH_CR register
-	4. Wait for the BSY bit to be cleared
-	 */
-
-	for (i = first; i &lt;= last; i++)
-	{
-		retval = target_write_u32(target,
-				stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_SER | FLASH_SNB(i) | FLASH_STRT);
-		if (retval != ERROR_OK)
-			return retval;
-
-		retval = stm32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
-		if (retval != ERROR_OK)
-			return retval;
-
-		bank-&gt;sectors[i].is_erased = 1;
-	}
-
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return ERROR_OK;
-}
-
-static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
-{
-	return ERROR_OK;
-}
-
-static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
-		uint32_t offset, uint32_t count)
-{
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-	struct target *target = bank-&gt;target;
-	uint32_t buffer_size = 16384;
-	struct working_area *source;
-	uint32_t address = bank-&gt;base + offset;
-	struct reg_param reg_params[5];
-	struct armv7m_algorithm armv7m_info;
-	int retval = ERROR_OK;
-
-	/* see contib/loaders/flash/stm32x.s for src */
-
-	static const uint16_t stm32x_flash_write_code_16[] = {
-//	00000000 &lt;write&gt;:
-	   0x4b07, //     	ldr	r3, [pc, #28]	(20 &lt;STM32_PROG16&gt;)
-	   0x6123,  //    	str	r3, [r4, #16]
-       0xf830, 0x3b02, 	//ldrh.w	r3, [r0], #2
-       0xf821, 0x3b02, 	//strh.w	r3, [r1], #2
-
-	//0000000c &lt;busy&gt;:
-	0x68e3,      	//ldr	r3, [r4, #12]
-0xf413, 0x3f80, // 	tst.w	r3, #65536	; 0x10000
-0xd0fb,      	//beq.n	c &lt;busy&gt;
-0xf013, 0x0ff0, 	//tst.w	r3, #240	; 0xf0
-0xd101,      	//bne.n	1e &lt;exit&gt;
-0x3a01,      	//subs	r2, #1
-0xd1f0,      	//bne.n	0 &lt;write&gt;
-	            	   	//0000001e &lt;exit&gt;:
-	0xbe00, //      	bkpt	0x0000
-
-	//00000020 &lt;STM32_PROG16&gt;:
-	0x0101, 0x0000, // 	.word	0x00000101
-
-	};
-
-	// Flip endian
-	uint8_t stm32x_flash_write_code[sizeof(stm32x_flash_write_code_16)*2];
-	for (unsigned i = 0; i &lt; sizeof(stm32x_flash_write_code_16) / 2; i++)
-	{
-		stm32x_flash_write_code[i*2 + 0] = stm32x_flash_write_code_16[i] &amp; 0xff;
-		stm32x_flash_write_code[i*2 + 1] = (stm32x_flash_write_code_16[i] &gt;&gt; 8) &amp; 0xff;
-	}
-
-	if (target_alloc_working_area(target, sizeof(stm32x_flash_write_code),
-			&amp;stm32x_info-&gt;write_algorithm) != ERROR_OK)
-	{
-		LOG_WARNING(&quot;no working area available, can't do block memory writes&quot;);
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
-
-	if ((retval = target_write_buffer(target, stm32x_info-&gt;write_algorithm-&gt;address,
-			sizeof(stm32x_flash_write_code),
-			(uint8_t*)stm32x_flash_write_code)) != ERROR_OK)
-		return retval;
-
-	/* memory buffer */
-	while (target_alloc_working_area_try(target, buffer_size, &amp;source) != ERROR_OK)
-	{
-		buffer_size /= 2;
-		if (buffer_size &lt;= 256)
-		{
-			/* if we already allocated the writing code, but failed to get a
-			 * buffer, free the algorithm */
-			if (stm32x_info-&gt;write_algorithm)
-				target_free_working_area(target, stm32x_info-&gt;write_algorithm);
-
-			LOG_WARNING(&quot;no large enough working area available, can't do block memory writes&quot;);
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
-	};
-
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
-	armv7m_info.core_mode = ARMV7M_MODE_ANY;
-
-	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_IN_OUT);
-	init_reg_param(&amp;reg_params[4], &quot;r4&quot;, 32, PARAM_OUT);
-
-	while (count &gt; 0)
-	{
-		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ?
-				(buffer_size / 2) : count;
-
-		if ((retval = target_write_buffer(target, source-&gt;address,
-				thisrun_count * 2, buffer)) != ERROR_OK)
-			break;
-
-		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
-		buf_set_u32(reg_params[1].value, 0, 32, address);
-		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
-		// R3 is a return value only
-		buf_set_u32(reg_params[4].value, 0, 32, STM32_FLASH_BASE);
-
-		if ((retval = target_run_algorithm(target, 0, NULL,
-				sizeof(reg_params) / sizeof(*reg_params),
-				reg_params,
-				stm32x_info-&gt;write_algorithm-&gt;address,
-				0,
-				10000, &amp;armv7m_info)) != ERROR_OK)
-		{
-			LOG_ERROR(&quot;error executing stm32x flash write algorithm&quot;);
-			break;
-		}
-
-		uint32_t error = buf_get_u32(reg_params[3].value, 0, 32) &amp; FLASH_ERROR;
-
-		if (error &amp; FLASH_WRPERR)
-		{
-			LOG_ERROR(&quot;flash memory write protected&quot;);
-		}
-
-		if (error != 0)
-		{
-			LOG_ERROR(&quot;flash write failed = %08x&quot;, error);
-			/* Clear but report errors */
-			target_write_u32(target, STM32_FLASH_SR, error);
-			retval = ERROR_FAIL;
-			break;
-		}
-
-		buffer += thisrun_count * 2;
-		address += thisrun_count * 2;
-		count -= thisrun_count;
-	}
-
-	target_free_working_area(target, source);
-	target_free_working_area(target, stm32x_info-&gt;write_algorithm);
-
-	destroy_reg_param(&amp;reg_params[0]);
-	destroy_reg_param(&amp;reg_params[1]);
-	destroy_reg_param(&amp;reg_params[2]);
-	destroy_reg_param(&amp;reg_params[3]);
-	destroy_reg_param(&amp;reg_params[4]);
-
-	return retval;
-}
-
-static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
-		uint32_t offset, uint32_t count)
-{
-	struct target *target = bank-&gt;target;
-	uint32_t words_remaining = (count / 2);
-	uint32_t bytes_remaining = (count &amp; 0x00000001);
-	uint32_t address = bank-&gt;base + offset;
-	uint32_t bytes_written = 0;
-	int retval;
-
-	if (bank-&gt;target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (offset &amp; 0x1)
-	{
-		LOG_WARNING(&quot;offset 0x%&quot; PRIx32 &quot; breaks required 2-byte alignment&quot;, offset);
-		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
-	}
-
-	retval = stm32x_unlock_reg(target);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* multiple half words (2-byte) to be programmed? */
-	if (words_remaining &gt; 0)
-	{
-		/* try using a block write */
-		if ((retval = stm32x_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
-		{
-			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
-			{
-				/* if block write failed (no sufficient working area),
-				 * we use normal (slow) single dword accesses */
-				LOG_WARNING(&quot;couldn't use block writes, falling back to single memory accesses&quot;);
-			}
-		}
-		else
-		{
-			buffer += words_remaining * 2;
-			address += words_remaining * 2;
-			words_remaining = 0;
-		}
-	}
-
-	if ((retval != ERROR_OK) &amp;&amp; (retval != ERROR_TARGET_RESOURCE_NOT_AVAILABLE))
-		return retval;
-
-	/*
-	Standard programming
-	The Flash memory programming sequence is as follows:
-	1. Check that no main Flash memory operation is ongoing by checking the BSY bit in the
-	  FLASH_SR register.
-	2. Set the PG bit in the FLASH_CR register
-	3. Perform the data write operation(s) to the desired memory address (inside main
-	  memory block or OTP area):
-	&#226;&#128;&#147; &#226;&#128;&#147; Half-word access in case of x16 parallelism
-	&#226;&#128;&#147; Word access in case of x32 parallelism
-	&#226;&#128;&#147;
-	4.
-	Byte access in case of x8 parallelism
-	Double word access in case of x64 parallelism
-	Wait for the BSY bit to be cleared
-	*/
-	while (words_remaining &gt; 0)
-	{
-		uint16_t value;
-		memcpy(&amp;value, buffer + bytes_written, sizeof(uint16_t));
-
-		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
-				FLASH_PG | FLASH_PSIZE_16);
-		if (retval != ERROR_OK)
-			return retval;
-
-		retval = target_write_u16(target, address, value);
-		if (retval != ERROR_OK)
-			return retval;
-
-		retval = stm32x_wait_status_busy(bank, FLASH_WRITE_TIMEOUT);
-		if (retval != ERROR_OK)
-			return retval;
-
-		bytes_written += 2;
-		words_remaining--;
-		address += 2;
-	}
-
-	if (bytes_remaining)
-	{
-		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
-				FLASH_PG | FLASH_PSIZE_8);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = target_write_u8(target, address, buffer[bytes_written]);
-		if (retval != ERROR_OK)
-			return retval;
-
-		retval = stm32x_wait_status_busy(bank, FLASH_WRITE_TIMEOUT);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
-}
-
-static void setup_sector(struct flash_bank *bank, int start, int num, int size)
-{
-	for (int i = start; i &lt; (start + num) ; i++)
-	{
-		bank-&gt;sectors[i].offset = bank-&gt;size;
-		bank-&gt;sectors[i].size = size;
-		bank-&gt;size += bank-&gt;sectors[i].size;
-	}
-}
-
-static int stm32x_probe(struct flash_bank *bank)
-{
-	struct target *target = bank-&gt;target;
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-	int i;
-	uint16_t num_pages;
-	uint32_t device_id;
-	uint32_t base_address = 0x08000000;
-
-	stm32x_info-&gt;probed = 0;
-
-	/* read stm32 device id register */
-	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
-	if (retval != ERROR_OK)
-		return retval;
-	LOG_INFO(&quot;device id = 0x%08&quot; PRIx32 &quot;&quot;, device_id);
-
-	if ((device_id &amp; 0x7ff) != 0x411)
-	{
-		LOG_WARNING(&quot;Cannot identify target as a STM32 family, try the other STM32 drivers.&quot;);
-		return ERROR_FAIL;
-	}
-
-	/* sectors sizes vary, handle this in a different code path
-	 * than the rest.
-	 */
-	// Uhhh.... what to use here?
-
-	/* calculate numbers of pages*/
-	num_pages = 4 + 1 + 7;
-
-	if (bank-&gt;sectors)
-	{
-		free(bank-&gt;sectors);
-		bank-&gt;sectors = NULL;
-	}
-
-	bank-&gt;base = base_address;
-	bank-&gt;num_sectors = num_pages;
-	bank-&gt;sectors = malloc(sizeof(struct flash_sector) * num_pages);
-
-	bank-&gt;size = 0;
-	setup_sector(bank, 0, 4, 16 * 1024);
-	setup_sector(bank, 4, 1, 64 * 1024);
-	setup_sector(bank, 4+1, 7, 128 * 1024);
-
-	for (i = 0; i &lt; num_pages; i++)
-	{
-		bank-&gt;sectors[i].is_erased = -1;
-		bank-&gt;sectors[i].is_protected = 0;
-	}
-
-	LOG_INFO(&quot;flash size = %dkBytes&quot;, bank-&gt;size / 1024);
-
-	stm32x_info-&gt;probed = 1;
-
-	return ERROR_OK;
-}
-
-static int stm32x_auto_probe(struct flash_bank *bank)
-{
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-	if (stm32x_info-&gt;probed)
-		return ERROR_OK;
-	return stm32x_probe(bank);
-}
-
-static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
-{
-	struct target *target = bank-&gt;target;
-	uint32_t device_id;
-	int printed;
-
-	/* read stm32 device id register */
-	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if ((device_id &amp; 0x7ff) == 0x411)
-	{
-		printed = snprintf(buf, buf_size, &quot;stm32x (1mByte part) - Rev: &quot;);
-		buf += printed;
-		buf_size -= printed;
-
-		switch (device_id &gt;&gt; 16)
-		{
-			case 0x1000:
-				snprintf(buf, buf_size, &quot;A&quot;);
-				break;
-
-			case 0x2000:
-				snprintf(buf, buf_size, &quot;B&quot;);
-				break;
-
-			case 0x1001:
-				snprintf(buf, buf_size, &quot;Z&quot;);
-				break;
-
-			case 0x2001:
-				snprintf(buf, buf_size, &quot;Y&quot;);
-				break;
-
-			default:
-				snprintf(buf, buf_size, &quot;unknown&quot;);
-				break;
-		}
-	}
-	else
-	{
-		snprintf(buf, buf_size, &quot;Cannot identify target as a stm32x\n&quot;);
-		return ERROR_FAIL;
-	}
-
-	return ERROR_OK;
-}
-
-static const struct command_registration stm32x_exec_command_handlers[] = {
-	COMMAND_REGISTRATION_DONE
-};
-
-static const struct command_registration stm32x_command_handlers[] = {
-	{
-		.name = &quot;stm32f2xxx&quot;,
-		.mode = COMMAND_ANY,
-		.help = &quot;stm32f2xxx flash command group&quot;,
-		.chain = stm32x_exec_command_handlers,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-struct flash_driver stm32xf2xxx_flash = {
-	.name = &quot;stm32f2xxx&quot;,
-	.commands = stm32x_command_handlers,
-	.flash_bank_command = stm32x_flash_bank_command,
-	.erase = stm32x_erase,
-	.protect = stm32x_protect,
-	.write = stm32x_write,
-	.read = default_flash_read,
-	.probe = stm32x_probe,
-	.auto_probe = stm32x_auto_probe,
-	.erase_check = default_flash_mem_blank_check,
-	.protect_check = stm32x_protect_check,
-	.info = get_stm32x_info,
-};
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
deleted file mode 100644
index b4300be..0000000
--- a/src/flash/nor/stm32x.c
+++ /dev/null
@@ -1,1568 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-development">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;imp.h&quot;
-#include &lt;helper/binarybuffer.h&gt;
-#include &lt;target/algorithm.h&gt;
-#include &lt;target/armv7m.h&gt;
-
-/* stm32x register locations */
-
-#define STM32_FLASH_ACR		0x40022000
-#define STM32_FLASH_KEYR	0x40022004
-#define STM32_FLASH_OPTKEYR	0x40022008
-#define STM32_FLASH_SR		0x4002200C
-#define STM32_FLASH_CR		0x40022010
-#define STM32_FLASH_AR		0x40022014
-#define STM32_FLASH_OBR		0x4002201C
-#define STM32_FLASH_WRPR	0x40022020
-
-/* option byte location */
-
-#define STM32_OB_RDP		0x1FFFF800
-#define STM32_OB_USER		0x1FFFF802
-#define STM32_OB_DATA0		0x1FFFF804
-#define STM32_OB_DATA1		0x1FFFF806
-#define STM32_OB_WRP0		0x1FFFF808
-#define STM32_OB_WRP1		0x1FFFF80A
-#define STM32_OB_WRP2		0x1FFFF80C
-#define STM32_OB_WRP3		0x1FFFF80E
-
-/* FLASH_CR register bits */
-
-#define FLASH_PG		(1 &lt;&lt; 0)
-#define FLASH_PER		(1 &lt;&lt; 1)
-#define FLASH_MER		(1 &lt;&lt; 2)
-#define FLASH_OPTPG		(1 &lt;&lt; 4)
-#define FLASH_OPTER		(1 &lt;&lt; 5)
-#define FLASH_STRT		(1 &lt;&lt; 6)
-#define FLASH_LOCK		(1 &lt;&lt; 7)
-#define FLASH_OPTWRE	(1 &lt;&lt; 9)
-
-/* FLASH_SR register bits */
-
-#define FLASH_BSY		(1 &lt;&lt; 0)
-#define FLASH_PGERR		(1 &lt;&lt; 2)
-#define FLASH_WRPRTERR	(1 &lt;&lt; 4)
-#define FLASH_EOP		(1 &lt;&lt; 5)
-
-/* STM32_FLASH_OBR bit definitions (reading) */
-
-#define OPT_ERROR		0
-#define OPT_READOUT		1
-#define OPT_RDWDGSW		2
-#define OPT_RDRSTSTOP	3
-#define OPT_RDRSTSTDBY	4
-#define OPT_BFB2		5	/* dual flash bank only */
-
-/* register unlock keys */
-
-#define KEY1			0x45670123
-#define KEY2			0xCDEF89AB
-
-/* we use an offset to access the second bank on dual flash devices
- * strangely the protection of the second bank is done on the bank0 reg's */
-
-#define FLASH_OFFSET_B0	0x00
-#define FLASH_OFFSET_B1 0x40
-
-struct stm32x_options
-{
-	uint16_t RDP;
-	uint16_t user_options;
-	uint16_t protection[4];
-};
-
-struct stm32x_flash_bank
-{
-	struct stm32x_options option_bytes;
-	struct working_area *write_algorithm;
-	int ppage_size;
-	int probed;
-
-	bool has_dual_banks;
-	/* used to access dual flash bank stm32xl
-	 * 0x00 will address bank 0 flash
-	 * 0x40 will address bank 1 flash */
-	int register_offset;
-};
-
-static int stm32x_mass_erase(struct flash_bank *bank);
-
-/* flash bank stm32x &lt;base&gt; &lt;size&gt; 0 0 &lt;target#&gt;
- */
-FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
-{
-	struct stm32x_flash_bank *stm32x_info;
-
-	if (CMD_ARGC &lt; 6)
-	{
-		LOG_WARNING(&quot;incomplete flash_bank stm32x configuration&quot;);
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	stm32x_info = malloc(sizeof(struct stm32x_flash_bank));
-	bank-&gt;driver_priv = stm32x_info;
-
-	stm32x_info-&gt;write_algorithm = NULL;
-	stm32x_info-&gt;probed = 0;
-	stm32x_info-&gt;has_dual_banks = false;
-	stm32x_info-&gt;register_offset = FLASH_OFFSET_B0;
-
-	return ERROR_OK;
-}
-
-static inline int stm32x_get_flash_reg(struct flash_bank *bank, uint32_t reg)
-{
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-	return reg + stm32x_info-&gt;register_offset;
-}
-
-static inline int stm32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
-{
-	struct target *target = bank-&gt;target;
-	return target_read_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR), status);
-}
-
-static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
-{
-	struct target *target = bank-&gt;target;
-	uint32_t status;
-	int retval = ERROR_OK;
-
-	/* wait for busy to clear */
-	for (;;)
-	{
-		retval = stm32x_get_flash_status(bank, &amp;status);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG(&quot;status: 0x%&quot; PRIx32 &quot;&quot;, status);
-		if ((status &amp; FLASH_BSY) == 0)
-			break;
-		if (timeout-- &lt;= 0)
-		{
-			LOG_ERROR(&quot;timed out waiting for flash&quot;);
-			return ERROR_FAIL;
-		}
-		alive_sleep(1);
-	}
-
-	if (status &amp; FLASH_WRPRTERR)
-	{
-		LOG_ERROR(&quot;stm32x device protected&quot;);
-		retval = ERROR_FAIL;
-	}
-
-	if (status &amp; FLASH_PGERR)
-	{
-		LOG_ERROR(&quot;stm32x device programming failed&quot;);
-		retval = ERROR_FAIL;
-	}
-
-	/* Clear but report errors */
-	if (status &amp; (FLASH_WRPRTERR | FLASH_PGERR))
-	{
-		/* If this operation fails, we ignore it and report the original
-		 * retval
-		 */
-		target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR),
-				FLASH_WRPRTERR | FLASH_PGERR);
-	}
-	return retval;
-}
-
-int stm32x_check_operation_supported(struct flash_bank *bank)
-{
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-
-	/* if we have a dual flash bank device then
-	 * we need to perform option byte stuff on bank0 only */
-	if (stm32x_info-&gt;register_offset != FLASH_OFFSET_B0)
-	{
-		LOG_ERROR(&quot;Option Byte Operation's must use bank0&quot;);
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int stm32x_read_options(struct flash_bank *bank)
-{
-	uint32_t optiondata;
-	struct stm32x_flash_bank *stm32x_info = NULL;
-	struct target *target = bank-&gt;target;
-
-	stm32x_info = bank-&gt;driver_priv;
-
-	/* read current option bytes */
-	int retval = target_read_u32(target, STM32_FLASH_OBR, &amp;optiondata);
-	if (retval != ERROR_OK)
-		return retval;
-
-	stm32x_info-&gt;option_bytes.user_options = (uint16_t)0xFFF8 | ((optiondata &gt;&gt; 2) &amp; 0x07);
-	stm32x_info-&gt;option_bytes.RDP = (optiondata &amp; (1 &lt;&lt; OPT_READOUT)) ? 0xFFFF : 0x5AA5;
-
-	if (optiondata &amp; (1 &lt;&lt; OPT_READOUT))
-		LOG_INFO(&quot;Device Security Bit Set&quot;);
-
-	/* each bit refers to a 4bank protection */
-	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;optiondata);
-	if (retval != ERROR_OK)
-		return retval;
-
-	stm32x_info-&gt;option_bytes.protection[0] = (uint16_t)optiondata;
-	stm32x_info-&gt;option_bytes.protection[1] = (uint16_t)(optiondata &gt;&gt; 8);
-	stm32x_info-&gt;option_bytes.protection[2] = (uint16_t)(optiondata &gt;&gt; 16);
-	stm32x_info-&gt;option_bytes.protection[3] = (uint16_t)(optiondata &gt;&gt; 24);
-
-	return ERROR_OK;
-}
-
-static int stm32x_erase_options(struct flash_bank *bank)
-{
-	struct stm32x_flash_bank *stm32x_info = NULL;
-	struct target *target = bank-&gt;target;
-
-	stm32x_info = bank-&gt;driver_priv;
-
-	/* read current options */
-	stm32x_read_options(bank);
-
-	/* unlock flash registers */
-	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* unlock option flash registers */
-	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY1);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY2);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* erase option bytes */
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTER | FLASH_OPTWRE);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTER | FLASH_STRT | FLASH_OPTWRE);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = stm32x_wait_status_busy(bank, 10);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* clear readout protection and complementary option bytes
-	 * this will also force a device unlock if set */
-	stm32x_info-&gt;option_bytes.RDP = 0x5AA5;
-
-	return ERROR_OK;
-}
-
-static int stm32x_write_options(struct flash_bank *bank)
-{
-	struct stm32x_flash_bank *stm32x_info = NULL;
-	struct target *target = bank-&gt;target;
-
-	stm32x_info = bank-&gt;driver_priv;
-
-	/* unlock flash registers */
-	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* unlock option flash registers */
-	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY1);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY2);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* program option bytes */
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTPG | FLASH_OPTWRE);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* write user option byte */
-	retval = target_write_u16(target, STM32_OB_USER, stm32x_info-&gt;option_bytes.user_options);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = stm32x_wait_status_busy(bank, 10);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* write protection byte 1 */
-	retval = target_write_u16(target, STM32_OB_WRP0, stm32x_info-&gt;option_bytes.protection[0]);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = stm32x_wait_status_busy(bank, 10);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* write protection byte 2 */
-	retval = target_write_u16(target, STM32_OB_WRP1, stm32x_info-&gt;option_bytes.protection[1]);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = stm32x_wait_status_busy(bank, 10);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* write protection byte 3 */
-	retval = target_write_u16(target, STM32_OB_WRP2, stm32x_info-&gt;option_bytes.protection[2]);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = stm32x_wait_status_busy(bank, 10);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* write protection byte 4 */
-	retval = target_write_u16(target, STM32_OB_WRP3, stm32x_info-&gt;option_bytes.protection[3]);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = stm32x_wait_status_busy(bank, 10);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* write readout protection bit */
-	retval = target_write_u16(target, STM32_OB_RDP, stm32x_info-&gt;option_bytes.RDP);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = stm32x_wait_status_busy(bank, 10);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return ERROR_OK;
-}
-
-static int stm32x_protect_check(struct flash_bank *bank)
-{
-	struct target *target = bank-&gt;target;
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-
-	uint32_t protection;
-	int i, s;
-	int num_bits;
-	int set;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	int retval = stm32x_check_operation_supported(bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	/* medium density - each bit refers to a 4bank protection
-	 * high density - each bit refers to a 2bank protection */
-	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;protection);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* medium density - each protection bit is for 4 * 1K pages
-	 * high density - each protection bit is for 2 * 2K pages */
-	num_bits = (bank-&gt;num_sectors / stm32x_info-&gt;ppage_size);
-
-	if (stm32x_info-&gt;ppage_size == 2)
-	{
-		/* high density flash/connectivity line protection */
-
-		set = 1;
-
-		if (protection &amp; (1 &lt;&lt; 31))
-			set = 0;
-
-		/* bit 31 controls sector 62 - 255 protection for high density
-		 * bit 31 controls sector 62 - 127 protection for connectivity line */
-		for (s = 62; s &lt; bank-&gt;num_sectors; s++)
-		{
-			bank-&gt;sectors[s].is_protected = set;
-		}
-
-		if (bank-&gt;num_sectors &gt; 61)
-			num_bits = 31;
-
-		for (i = 0; i &lt; num_bits; i++)
-		{
-			set = 1;
-
-			if (protection &amp; (1 &lt;&lt; i))
-				set = 0;
-
-			for (s = 0; s &lt; stm32x_info-&gt;ppage_size; s++)
-				bank-&gt;sectors[(i * stm32x_info-&gt;ppage_size) + s].is_protected = set;
-		}
-	}
-	else
-	{
-		/* low/medium density flash protection */
-		for (i = 0; i &lt; num_bits; i++)
-		{
-			set = 1;
-
-			if (protection &amp; (1 &lt;&lt; i))
-				set = 0;
-
-			for (s = 0; s &lt; stm32x_info-&gt;ppage_size; s++)
-				bank-&gt;sectors[(i * stm32x_info-&gt;ppage_size) + s].is_protected = set;
-		}
-	}
-
-	return ERROR_OK;
-}
-
-static int stm32x_erase(struct flash_bank *bank, int first, int last)
-{
-	struct target *target = bank-&gt;target;
-	int i;
-
-	if (bank-&gt;target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if ((first == 0) &amp;&amp; (last == (bank-&gt;num_sectors - 1)))
-	{
-		return stm32x_mass_erase(bank);
-	}
-
-	/* unlock flash registers */
-	int retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
-	if (retval != ERROR_OK)
-		return retval;
-
-	for (i = first; i &lt;= last; i++)
-	{
-		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PER);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_AR),
-				bank-&gt;base + bank-&gt;sectors[i].offset);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = target_write_u32(target,
-				stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PER | FLASH_STRT);
-		if (retval != ERROR_OK)
-			return retval;
-
-		retval = stm32x_wait_status_busy(bank, 100);
-		if (retval != ERROR_OK)
-			return retval;
-
-		bank-&gt;sectors[i].is_erased = 1;
-	}
-
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return ERROR_OK;
-}
-
-static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
-{
-	struct stm32x_flash_bank *stm32x_info = NULL;
-	struct target *target = bank-&gt;target;
-	uint16_t prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
-	int i, reg, bit;
-	int status;
-	uint32_t protection;
-
-	stm32x_info = bank-&gt;driver_priv;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	int retval = stm32x_check_operation_supported(bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if ((first % stm32x_info-&gt;ppage_size) != 0)
-	{
-		LOG_WARNING(&quot;aligned start protect sector to a %d sector boundary&quot;,
-				stm32x_info-&gt;ppage_size);
-		first = first - (first % stm32x_info-&gt;ppage_size);
-	}
-	if (((last + 1) % stm32x_info-&gt;ppage_size) != 0)
-	{
-		LOG_WARNING(&quot;aligned end protect sector to a %d sector boundary&quot;,
-				stm32x_info-&gt;ppage_size);
-		last++;
-		last = last - (last % stm32x_info-&gt;ppage_size);
-		last--;
-	}
-
-	/* medium density - each bit refers to a 4bank protection
-	 * high density - each bit refers to a 2bank protection */
-	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;protection);
-	if (retval != ERROR_OK)
-		return retval;
-
-	prot_reg[0] = (uint16_t)protection;
-	prot_reg[1] = (uint16_t)(protection &gt;&gt; 8);
-	prot_reg[2] = (uint16_t)(protection &gt;&gt; 16);
-	prot_reg[3] = (uint16_t)(protection &gt;&gt; 24);
-
-	if (stm32x_info-&gt;ppage_size == 2)
-	{
-		/* high density flash */
-
-		/* bit 7 controls sector 62 - 255 protection */
-		if (last &gt; 61)
-		{
-			if (set)
-				prot_reg[3] &amp;= ~(1 &lt;&lt; 7);
-			else
-				prot_reg[3] |= (1 &lt;&lt; 7);
-		}
-
-		if (first &gt; 61)
-			first = 62;
-		if (last &gt; 61)
-			last = 61;
-
-		for (i = first; i &lt;= last; i++)
-		{
-			reg = (i / stm32x_info-&gt;ppage_size) / 8;
-			bit = (i / stm32x_info-&gt;ppage_size) - (reg * 8);
-
-			if (set)
-				prot_reg[reg] &amp;= ~(1 &lt;&lt; bit);
-			else
-				prot_reg[reg] |= (1 &lt;&lt; bit);
-		}
-	}
-	else
-	{
-		/* medium density flash */
-		for (i = first; i &lt;= last; i++)
-		{
-			reg = (i / stm32x_info-&gt;ppage_size) / 8;
-			bit = (i / stm32x_info-&gt;ppage_size) - (reg * 8);
-
-			if (set)
-				prot_reg[reg] &amp;= ~(1 &lt;&lt; bit);
-			else
-				prot_reg[reg] |= (1 &lt;&lt; bit);
-		}
-	}
-
-	if ((status = stm32x_erase_options(bank)) != ERROR_OK)
-		return status;
-
-	stm32x_info-&gt;option_bytes.protection[0] = prot_reg[0];
-	stm32x_info-&gt;option_bytes.protection[1] = prot_reg[1];
-	stm32x_info-&gt;option_bytes.protection[2] = prot_reg[2];
-	stm32x_info-&gt;option_bytes.protection[3] = prot_reg[3];
-
-	return stm32x_write_options(bank);
-}
-
-static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
-		uint32_t offset, uint32_t count)
-{
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-	struct target *target = bank-&gt;target;
-	uint32_t buffer_size = 16384;
-	struct working_area *source;
-	uint32_t address = bank-&gt;base + offset;
-	struct reg_param reg_params[4];
-	struct armv7m_algorithm armv7m_info;
-	int retval = ERROR_OK;
-
-	/* see contib/loaders/flash/stm32x.s for src */
-
-	static const uint8_t stm32x_flash_write_code[] = {
-									/* #define STM32_FLASH_CR_OFFSET	0x10 */
-									/* #define STM32_FLASH_SR_OFFSET	0x0C */
-									/* write: */
-		0x08, 0x4c,					/* ldr	r4, STM32_FLASH_BASE */
-		0x1c, 0x44,					/* add	r4, r3 */
-									/* write_half_word: */
-		0x01, 0x23,					/* movs	r3, #0x01 */
-		0x23, 0x61,					/* str	r3, [r4, #STM32_FLASH_CR_OFFSET] */
-		0x30, 0xf8, 0x02, 0x3b,		/* ldrh	r3, [r0], #0x02 */
-		0x21, 0xf8, 0x02, 0x3b,		/* strh	r3, [r1], #0x02 */
-									/* busy: */
-		0xe3, 0x68,					/* ldr	r3, [r4, #STM32_FLASH_SR_OFFSET] */
-		0x13, 0xf0, 0x01, 0x0f,		/* tst	r3, #0x01 */
-		0xfb, 0xd0,					/* beq	busy */
-		0x13, 0xf0, 0x14, 0x0f,		/* tst	r3, #0x14 */
-		0x01, 0xd1,					/* bne	exit */
-		0x01, 0x3a,					/* subs	r2, r2, #0x01 */
-		0xf0, 0xd1,					/* bne	write_half_word */
-									/* exit: */
-		0x00, 0xbe,					/* bkpt	#0x00 */
-		0x00, 0x20, 0x02, 0x40,		/* STM32_FLASH_BASE: .word 0x40022000 */
-	};
-
-	/* flash write code */
-	if (target_alloc_working_area(target, sizeof(stm32x_flash_write_code),
-			&amp;stm32x_info-&gt;write_algorithm) != ERROR_OK)
-	{
-		LOG_WARNING(&quot;no working area available, can't do block memory writes&quot;);
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
-
-	if ((retval = target_write_buffer(target, stm32x_info-&gt;write_algorithm-&gt;address,
-			sizeof(stm32x_flash_write_code),
-			(uint8_t*)stm32x_flash_write_code)) != ERROR_OK)
-		return retval;
-
-	/* memory buffer */
-	while (target_alloc_working_area_try(target, buffer_size, &amp;source) != ERROR_OK)
-	{
-		buffer_size /= 2;
-		if (buffer_size &lt;= 256)
-		{
-			/* if we already allocated the writing code, but failed to get a
-			 * buffer, free the algorithm */
-			if (stm32x_info-&gt;write_algorithm)
-				target_free_working_area(target, stm32x_info-&gt;write_algorithm);
-
-			LOG_WARNING(&quot;no large enough working area available, can't do block memory writes&quot;);
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
-	};
-
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
-	armv7m_info.core_mode = ARMV7M_MODE_ANY;
-
-	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_IN_OUT);
-
-	while (count &gt; 0)
-	{
-		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ?
-				(buffer_size / 2) : count;
-
-		if ((retval = target_write_buffer(target, source-&gt;address,
-				thisrun_count * 2, buffer)) != ERROR_OK)
-			break;
-
-		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
-		buf_set_u32(reg_params[1].value, 0, 32, address);
-		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
-		buf_set_u32(reg_params[3].value, 0, 32, stm32x_info-&gt;register_offset);
-
-		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
-				stm32x_info-&gt;write_algorithm-&gt;address,
-				0,
-				10000, &amp;armv7m_info)) != ERROR_OK)
-		{
-			LOG_ERROR(&quot;error executing stm32x flash write algorithm&quot;);
-			break;
-		}
-
-		if (buf_get_u32(reg_params[3].value, 0, 32) &amp; FLASH_PGERR)
-		{
-			LOG_ERROR(&quot;flash memory not erased before writing&quot;);
-			/* Clear but report errors */
-			target_write_u32(target, STM32_FLASH_SR, FLASH_PGERR);
-			retval = ERROR_FAIL;
-			break;
-		}
-
-		if (buf_get_u32(reg_params[3].value, 0, 32) &amp; FLASH_WRPRTERR)
-		{
-			LOG_ERROR(&quot;flash memory write protected&quot;);
-			/* Clear but report errors */
-			target_write_u32(target, STM32_FLASH_SR, FLASH_WRPRTERR);
-			retval = ERROR_FAIL;
-			break;
-		}
-
-		buffer += thisrun_count * 2;
-		address += thisrun_count * 2;
-		count -= thisrun_count;
-	}
-
-	target_free_working_area(target, source);
-	target_free_working_area(target, stm32x_info-&gt;write_algorithm);
-
-	destroy_reg_param(&amp;reg_params[0]);
-	destroy_reg_param(&amp;reg_params[1]);
-	destroy_reg_param(&amp;reg_params[2]);
-	destroy_reg_param(&amp;reg_params[3]);
-
-	return retval;
-}
-
-static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
-		uint32_t offset, uint32_t count)
-{
-	struct target *target = bank-&gt;target;
-	uint32_t words_remaining = (count / 2);
-	uint32_t bytes_remaining = (count &amp; 0x00000001);
-	uint32_t address = bank-&gt;base + offset;
-	uint32_t bytes_written = 0;
-	int retval;
-
-	if (bank-&gt;target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (offset &amp; 0x1)
-	{
-		LOG_WARNING(&quot;offset 0x%&quot; PRIx32 &quot; breaks required 2-byte alignment&quot;, offset);
-		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
-	}
-
-	/* unlock flash registers */
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* multiple half words (2-byte) to be programmed? */
-	if (words_remaining &gt; 0)
-	{
-		/* try using a block write */
-		if ((retval = stm32x_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
-		{
-			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
-			{
-				/* if block write failed (no sufficient working area),
-				 * we use normal (slow) single dword accesses */
-				LOG_WARNING(&quot;couldn't use block writes, falling back to single memory accesses&quot;);
-			}
-		}
-		else
-		{
-			buffer += words_remaining * 2;
-			address += words_remaining * 2;
-			words_remaining = 0;
-		}
-	}
-
-	if ((retval != ERROR_OK) &amp;&amp; (retval != ERROR_TARGET_RESOURCE_NOT_AVAILABLE))
-		return retval;
-
-	while (words_remaining &gt; 0)
-	{
-		uint16_t value;
-		memcpy(&amp;value, buffer + bytes_written, sizeof(uint16_t));
-
-		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PG);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = target_write_u16(target, address, value);
-		if (retval != ERROR_OK)
-			return retval;
-
-		retval = stm32x_wait_status_busy(bank, 5);
-		if (retval != ERROR_OK)
-			return retval;
-
-		bytes_written += 2;
-		words_remaining--;
-		address += 2;
-	}
-
-	if (bytes_remaining)
-	{
-		uint16_t value = 0xffff;
-		memcpy(&amp;value, buffer + bytes_written, bytes_remaining);
-
-		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_PG);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = target_write_u16(target, address, value);
-		if (retval != ERROR_OK)
-			return retval;
-
-		retval = stm32x_wait_status_busy(bank, 5);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
-}
-
-static int stm32x_probe(struct flash_bank *bank)
-{
-	struct target *target = bank-&gt;target;
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-	int i;
-	uint16_t num_pages;
-	uint32_t device_id;
-	int page_size;
-	uint32_t base_address = 0x08000000;
-
-	stm32x_info-&gt;probed = 0;
-	stm32x_info-&gt;register_offset = FLASH_OFFSET_B0;
-
-	/* read stm32 device id register */
-	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
-	if (retval != ERROR_OK)
-		return retval;
-	LOG_INFO(&quot;device id = 0x%08&quot; PRIx32 &quot;&quot;, device_id);
-
-	/* get flash size from target. */
-	retval = target_read_u16(target, 0x1FFFF7E0, &amp;num_pages);
-	if (retval != ERROR_OK)
-	{
-		LOG_WARNING(&quot;failed reading flash size, default to max target family&quot;);
-		/* failed reading flash size, default to max target family */
-		num_pages = 0xffff;
-	}
-
-	if ((device_id &amp; 0x7ff) == 0x410)
-	{
-		/* medium density - we have 1k pages
-		 * 4 pages for a protection area */
-		page_size = 1024;
-		stm32x_info-&gt;ppage_size = 4;
-
-		/* check for early silicon */
-		if (num_pages == 0xffff)
-		{
-			/* number of sectors incorrect on revA */
-			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 128k flash&quot;);
-			num_pages = 128;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x412)
-	{
-		/* low density - we have 1k pages
-		 * 4 pages for a protection area */
-		page_size = 1024;
-		stm32x_info-&gt;ppage_size = 4;
-
-		/* check for early silicon */
-		if (num_pages == 0xffff)
-		{
-			/* number of sectors incorrect on revA */
-			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 32k flash&quot;);
-			num_pages = 32;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x414)
-	{
-		/* high density - we have 2k pages
-		 * 2 pages for a protection area */
-		page_size = 2048;
-		stm32x_info-&gt;ppage_size = 2;
-
-		/* check for early silicon */
-		if (num_pages == 0xffff)
-		{
-			/* number of sectors incorrect on revZ */
-			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 512k flash&quot;);
-			num_pages = 512;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x418)
-	{
-		/* connectivity line density - we have 2k pages
-		 * 2 pages for a protection area */
-		page_size = 2048;
-		stm32x_info-&gt;ppage_size = 2;
-
-		/* check for early silicon */
-		if (num_pages == 0xffff)
-		{
-			/* number of sectors incorrect on revZ */
-			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 256k flash&quot;);
-			num_pages = 256;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x420)
-	{
-		/* value line density - we have 1k pages
-		 * 4 pages for a protection area */
-		page_size = 1024;
-		stm32x_info-&gt;ppage_size = 4;
-
-		/* check for early silicon */
-		if (num_pages == 0xffff)
-		{
-			/* number of sectors may be incorrrect on early silicon */
-			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 128k flash&quot;);
-			num_pages = 128;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x430)
-	{
-		/* xl line density - we have 2k pages
-		 * 2 pages for a protection area */
-		page_size = 2048;
-		stm32x_info-&gt;ppage_size = 2;
-		stm32x_info-&gt;has_dual_banks = true;
-
-		/* check for early silicon */
-		if (num_pages == 0xffff)
-		{
-			/* number of sectors may be incorrrect on early silicon */
-			LOG_WARNING(&quot;STM32 flash size failed, probe inaccurate - assuming 1024k flash&quot;);
-			num_pages = 1024;
-		}
-
-		/* split reported size into matching bank */
-		if (bank-&gt;base != 0x08080000)
-		{
-			/* bank 0 will be fixed 512k */
-			num_pages = 512;
-		}
-		else
-		{
-			num_pages -= 512;
-			/* bank1 also uses a register offset */
-			stm32x_info-&gt;register_offset = FLASH_OFFSET_B1;
-			base_address = 0x08080000;
-		}
-	}
-	else
-	{
-		LOG_WARNING(&quot;Cannot identify target as a STM32 family.&quot;);
-		return ERROR_FAIL;
-	}
-
-	LOG_INFO(&quot;flash size = %dkbytes&quot;, num_pages);
-
-	/* calculate numbers of pages */
-	num_pages /= (page_size / 1024);
-
-	if (bank-&gt;sectors)
-	{
-		free(bank-&gt;sectors);
-		bank-&gt;sectors = NULL;
-	}
-
-	bank-&gt;base = base_address;
-	bank-&gt;size = (num_pages * page_size);
-	bank-&gt;num_sectors = num_pages;
-	bank-&gt;sectors = malloc(sizeof(struct flash_sector) * num_pages);
-
-	for (i = 0; i &lt; num_pages; i++)
-	{
-		bank-&gt;sectors[i].offset = i * page_size;
-		bank-&gt;sectors[i].size = page_size;
-		bank-&gt;sectors[i].is_erased = -1;
-		bank-&gt;sectors[i].is_protected = 1;
-	}
-
-	stm32x_info-&gt;probed = 1;
-
-	return ERROR_OK;
-}
-
-static int stm32x_auto_probe(struct flash_bank *bank)
-{
-	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-	if (stm32x_info-&gt;probed)
-		return ERROR_OK;
-	return stm32x_probe(bank);
-}
-
-#if 0
-COMMAND_HANDLER(stm32x_handle_part_id_command)
-{
-	return ERROR_OK;
-}
-#endif
-
-static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
-{
-	struct target *target = bank-&gt;target;
-	uint32_t device_id;
-	int printed;
-
-	/* read stm32 device id register */
-	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if ((device_id &amp; 0x7ff) == 0x410)
-	{
-		printed = snprintf(buf, buf_size, &quot;stm32x (Medium Density) - Rev: &quot;);
-		buf += printed;
-		buf_size -= printed;
-
-		switch (device_id &gt;&gt; 16)
-		{
-			case 0x0000:
-				snprintf(buf, buf_size, &quot;A&quot;);
-				break;
-
-			case 0x2000:
-				snprintf(buf, buf_size, &quot;B&quot;);
-				break;
-
-			case 0x2001:
-				snprintf(buf, buf_size, &quot;Z&quot;);
-				break;
-
-			case 0x2003:
-				snprintf(buf, buf_size, &quot;Y&quot;);
-				break;
-
-			default:
-				snprintf(buf, buf_size, &quot;unknown&quot;);
-				break;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x412)
-	{
-		printed = snprintf(buf, buf_size, &quot;stm32x (Low Density) - Rev: &quot;);
-		buf += printed;
-		buf_size -= printed;
-
-		switch (device_id &gt;&gt; 16)
-		{
-			case 0x1000:
-				snprintf(buf, buf_size, &quot;A&quot;);
-				break;
-
-			default:
-				snprintf(buf, buf_size, &quot;unknown&quot;);
-				break;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x414)
-	{
-		printed = snprintf(buf, buf_size, &quot;stm32x (High Density) - Rev: &quot;);
-		buf += printed;
-		buf_size -= printed;
-
-		switch (device_id &gt;&gt; 16)
-		{
-			case 0x1000:
-				snprintf(buf, buf_size, &quot;A&quot;);
-				break;
-
-			case 0x1001:
-				snprintf(buf, buf_size, &quot;Z&quot;);
-				break;
-
-			default:
-				snprintf(buf, buf_size, &quot;unknown&quot;);
-				break;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x418)
-	{
-		printed = snprintf(buf, buf_size, &quot;stm32x (Connectivity) - Rev: &quot;);
-		buf += printed;
-		buf_size -= printed;
-
-		switch (device_id &gt;&gt; 16)
-		{
-			case 0x1000:
-				snprintf(buf, buf_size, &quot;A&quot;);
-				break;
-
-			case 0x1001:
-				snprintf(buf, buf_size, &quot;Z&quot;);
-				break;
-
-			default:
-				snprintf(buf, buf_size, &quot;unknown&quot;);
-				break;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x420)
-	{
-		printed = snprintf(buf, buf_size, &quot;stm32x (Value) - Rev: &quot;);
-		buf += printed;
-		buf_size -= printed;
-
-		switch (device_id &gt;&gt; 16)
-		{
-			case 0x1000:
-				snprintf(buf, buf_size, &quot;A&quot;);
-				break;
-
-			case 0x1001:
-				snprintf(buf, buf_size, &quot;Z&quot;);
-				break;
-
-			default:
-				snprintf(buf, buf_size, &quot;unknown&quot;);
-				break;
-		}
-	}
-	else if ((device_id &amp; 0x7ff) == 0x430)
-	{
-		printed = snprintf(buf, buf_size, &quot;stm32x (XL) - Rev: &quot;);
-		buf += printed;
-		buf_size -= printed;
-
-		switch (device_id &gt;&gt; 16)
-		{
-			case 0x1000:
-				snprintf(buf, buf_size, &quot;A&quot;);
-				break;
-
-			default:
-				snprintf(buf, buf_size, &quot;unknown&quot;);
-				break;
-		}
-	}
-	else
-	{
-		snprintf(buf, buf_size, &quot;Cannot identify target as a stm32x\n&quot;);
-		return ERROR_FAIL;
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(stm32x_handle_lock_command)
-{
-	struct target *target = NULL;
-	struct stm32x_flash_bank *stm32x_info = NULL;
-
-	if (CMD_ARGC &lt; 1)
-	{
-		command_print(CMD_CTX, &quot;stm32x lock &lt;bank&gt;&quot;);
-		return ERROR_OK;
-	}
-
-	struct flash_bank *bank;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	stm32x_info = bank-&gt;driver_priv;
-
-	target = bank-&gt;target;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	retval = stm32x_check_operation_supported(bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (stm32x_erase_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;stm32x failed to erase options&quot;);
-		return ERROR_OK;
-	}
-
-	/* set readout protection */
-	stm32x_info-&gt;option_bytes.RDP = 0;
-
-	if (stm32x_write_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;stm32x failed to lock device&quot;);
-		return ERROR_OK;
-	}
-
-	command_print(CMD_CTX, &quot;stm32x locked&quot;);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(stm32x_handle_unlock_command)
-{
-	struct target *target = NULL;
-
-	if (CMD_ARGC &lt; 1)
-	{
-		command_print(CMD_CTX, &quot;stm32x unlock &lt;bank&gt;&quot;);
-		return ERROR_OK;
-	}
-
-	struct flash_bank *bank;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	target = bank-&gt;target;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	retval = stm32x_check_operation_supported(bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (stm32x_erase_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;stm32x failed to unlock device&quot;);
-		return ERROR_OK;
-	}
-
-	if (stm32x_write_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;stm32x failed to lock device&quot;);
-		return ERROR_OK;
-	}
-
-	command_print(CMD_CTX, &quot;stm32x unlocked.\n&quot;
-			&quot;INFO: a reset or power cycle is required &quot;
-			&quot;for the new settings to take effect.&quot;);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(stm32x_handle_options_read_command)
-{
-	uint32_t optionbyte;
-	struct target *target = NULL;
-	struct stm32x_flash_bank *stm32x_info = NULL;
-
-	if (CMD_ARGC &lt; 1)
-	{
-		command_print(CMD_CTX, &quot;stm32x options_read &lt;bank&gt;&quot;);
-		return ERROR_OK;
-	}
-
-	struct flash_bank *bank;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	stm32x_info = bank-&gt;driver_priv;
-
-	target = bank-&gt;target;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	retval = stm32x_check_operation_supported(bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	retval = target_read_u32(target, STM32_FLASH_OBR, &amp;optionbyte);
-	if (retval != ERROR_OK)
-		return retval;
-	command_print(CMD_CTX, &quot;Option Byte: 0x%&quot; PRIx32 &quot;&quot;, optionbyte);
-
-	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_ERROR, 1))
-		command_print(CMD_CTX, &quot;Option Byte Complement Error&quot;);
-
-	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_READOUT, 1))
-		command_print(CMD_CTX, &quot;Readout Protection On&quot;);
-	else
-		command_print(CMD_CTX, &quot;Readout Protection Off&quot;);
-
-	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_RDWDGSW, 1))
-		command_print(CMD_CTX, &quot;Software Watchdog&quot;);
-	else
-		command_print(CMD_CTX, &quot;Hardware Watchdog&quot;);
-
-	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_RDRSTSTOP, 1))
-		command_print(CMD_CTX, &quot;Stop: No reset generated&quot;);
-	else
-		command_print(CMD_CTX, &quot;Stop: Reset generated&quot;);
-
-	if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_RDRSTSTDBY, 1))
-		command_print(CMD_CTX, &quot;Standby: No reset generated&quot;);
-	else
-		command_print(CMD_CTX, &quot;Standby: Reset generated&quot;);
-
-	if (stm32x_info-&gt;has_dual_banks)
-	{
-		if (buf_get_u32((uint8_t*)&amp;optionbyte, OPT_BFB2, 1))
-			command_print(CMD_CTX, &quot;Boot: Bank 0&quot;);
-		else
-			command_print(CMD_CTX, &quot;Boot: Bank 1&quot;);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(stm32x_handle_options_write_command)
-{
-	struct target *target = NULL;
-	struct stm32x_flash_bank *stm32x_info = NULL;
-	uint16_t optionbyte = 0xF8;
-
-	if (CMD_ARGC &lt; 4)
-	{
-		command_print(CMD_CTX, &quot;stm32x options_write &lt;bank&gt; &lt;SWWDG | HWWDG&gt; &quot;
-				&quot;&lt;RSTSTNDBY | NORSTSTNDBY&gt; &lt;RSTSTOP | NORSTSTOP&gt; &lt;BOOT0 | BOOT1&gt;&quot;);
-		return ERROR_OK;
-	}
-
-	struct flash_bank *bank;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	stm32x_info = bank-&gt;driver_priv;
-
-	target = bank-&gt;target;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	retval = stm32x_check_operation_supported(bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	/* REVISIT: ignores some options which we will display...
-	 * and doesn't insist on the specified syntax.
-	 */
-
-	/* OPT_RDWDGSW */
-	if (strcmp(CMD_ARGV[1], &quot;SWWDG&quot;) == 0)
-	{
-		optionbyte |= (1 &lt;&lt; 0);
-	}
-	else	/* REVISIT must be &quot;HWWDG&quot; then ... */
-	{
-		optionbyte &amp;= ~(1 &lt;&lt; 0);
-	}
-
-	/* OPT_RDRSTSTOP */
-	if (strcmp(CMD_ARGV[2], &quot;NORSTSTOP&quot;) == 0)
-	{
-		optionbyte |= (1 &lt;&lt; 1);
-	}
-	else	/* REVISIT must be &quot;RSTSTNDBY&quot; then ... */
-	{
-		optionbyte &amp;= ~(1 &lt;&lt; 1);
-	}
-
-	/* OPT_RDRSTSTDBY */
-	if (strcmp(CMD_ARGV[3], &quot;NORSTSTNDBY&quot;) == 0)
-	{
-		optionbyte |= (1 &lt;&lt; 2);
-	}
-	else	/* REVISIT must be &quot;RSTSTOP&quot; then ... */
-	{
-		optionbyte &amp;= ~(1 &lt;&lt; 2);
-	}
-
-	if (CMD_ARGC &gt; 4 &amp;&amp; stm32x_info-&gt;has_dual_banks)
-	{
-		/* OPT_BFB2 */
-		if (strcmp(CMD_ARGV[4], &quot;BOOT0&quot;) == 0)
-		{
-			optionbyte |= (1 &lt;&lt; 3);
-		}
-		else
-		{
-			optionbyte &amp;= ~(1 &lt;&lt; 3);
-		}
-	}
-
-	if (stm32x_erase_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;stm32x failed to erase options&quot;);
-		return ERROR_OK;
-	}
-
-	stm32x_info-&gt;option_bytes.user_options = optionbyte;
-
-	if (stm32x_write_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;stm32x failed to write options&quot;);
-		return ERROR_OK;
-	}
-
-	command_print(CMD_CTX, &quot;stm32x write options complete.\n&quot;
-				&quot;INFO: a reset or power cycle is required &quot;
-				&quot;for the new settings to take effect.&quot;);
-
-	return ERROR_OK;
-}
-
-static int stm32x_mass_erase(struct flash_bank *bank)
-{
-	struct target *target = bank-&gt;target;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* unlock option flash registers */
-	int retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY1);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_KEYR), KEY2);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* mass erase flash memory */
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER | FLASH_STRT);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = stm32x_wait_status_busy(bank, 100);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(stm32x_handle_mass_erase_command)
-{
-	int i;
-
-	if (CMD_ARGC &lt; 1)
-	{
-		command_print(CMD_CTX, &quot;stm32x mass_erase &lt;bank&gt;&quot;);
-		return ERROR_OK;
-	}
-
-	struct flash_bank *bank;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	retval = stm32x_mass_erase(bank);
-	if (retval == ERROR_OK)
-	{
-		/* set all sectors as erased */
-		for (i = 0; i &lt; bank-&gt;num_sectors; i++)
-		{
-			bank-&gt;sectors[i].is_erased = 1;
-		}
-
-		command_print(CMD_CTX, &quot;stm32x mass erase complete&quot;);
-	}
-	else
-	{
-		command_print(CMD_CTX, &quot;stm32x mass erase failed&quot;);
-	}
-
-	return retval;
-}
-
-static const struct command_registration stm32x_exec_command_handlers[] = {
-	{
-		.name = &quot;lock&quot;,
-		.handler = stm32x_handle_lock_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;bank_id&quot;,
-		.help = &quot;Lock entire flash device.&quot;,
-	},
-	{
-		.name = &quot;unlock&quot;,
-		.handler = stm32x_handle_unlock_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;bank_id&quot;,
-		.help = &quot;Unlock entire protected flash device.&quot;,
-	},
-	{
-		.name = &quot;mass_erase&quot;,
-		.handler = stm32x_handle_mass_erase_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;bank_id&quot;,
-		.help = &quot;Erase entire flash device.&quot;,
-	},
-	{
-		.name = &quot;options_read&quot;,
-		.handler = stm32x_handle_options_read_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;bank_id&quot;,
-		.help = &quot;Read and display device option byte.&quot;,
-	},
-	{
-		.name = &quot;options_write&quot;,
-		.handler = stm32x_handle_options_write_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;bank_id ('SWWDG'|'HWWDG') &quot;
-			&quot;('RSTSTNDBY'|'NORSTSTNDBY') &quot;
-			&quot;('RSTSTOP'|'NORSTSTOP')&quot;,
-		.help = &quot;Replace bits in device option byte.&quot;,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-static const struct command_registration stm32x_command_handlers[] = {
-	{
-		.name = &quot;stm32x&quot;,
-		.mode = COMMAND_ANY,
-		.help = &quot;stm32x flash command group&quot;,
-		.chain = stm32x_exec_command_handlers,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-struct flash_driver stm32x_flash = {
-	.name = &quot;stm32x&quot;,
-	.commands = stm32x_command_handlers,
-	.flash_bank_command = stm32x_flash_bank_command,
-	.erase = stm32x_erase,
-	.protect = stm32x_protect,
-	.write = stm32x_write,
-	.read = default_flash_read,
-	.probe = stm32x_probe,
-	.auto_probe = stm32x_auto_probe,
-	.erase_check = default_flash_mem_blank_check,
-	.protect_check = stm32x_protect_check,
-	.info = get_stm32x_info,
-};
-- 
1.7.0.4


________________________________________________________________________
This e-mail has been scanned for all viruses by Star. The
service is powered by MessageLabs. For more information on a proactive
anti-virus service working around the clock, around the globe, visit:
<A HREF="http://www.star.net.uk">http://www.star.net.uk</A>
________________________________________________________________________

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020389.html">[Openocd-development] [PATCH]rename stm32 flash drivers
</A></li>
	<LI>Next message: <A HREF="020402.html">[Openocd-development] [PATCH 1/4] flash: update stm32 driver	names
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20391">[ date ]</a>
              <a href="thread.html#20391">[ thread ]</a>
              <a href="subject.html#20391">[ subject ]</a>
              <a href="author.html#20391">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-development">More information about the Openocd-development
mailing list</a><br>
</body></html>
